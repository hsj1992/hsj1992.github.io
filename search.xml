<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第六章-3]]></title>
      <url>https://codingme.xyz/2016/09/22/javascript-note-6-3/</url>
      <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>许多 OO 语言都支持两种继承方式：接口继承和实现继承。<br>接口继承只继承方法签名，而实现继承则继承实际的方法。<br>由于函数没有签名，在 ECMAScript 中无法实现接口继承。<br>ECMAScript 只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>ECMAScript 将原型链作为实现继承的主要方法。<br>基本思想:利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>基本模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//继承了 SuperType</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue()); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>SuperType 和 SubType 主要区别是 SubType 继承了 SuperType ，<br>而继承是通过创建 SuperType 的实例，并将该实例赋给SubType.prototype 实现的。<br>实现的本质是重写原型对象，代之以一个新类型的实例。<br>原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。<br>新原型不仅具有作为一个 SuperType 的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了 SuperType 的原型。</p>
<p>instance 指向 SubType的原型 ，<br>SubType 的原型又指向 SuperType 的原型 。<br>getSuperValue() 方法仍然还在SuperType.prototype 中，<br>但 property 则位于 SubType.prototype(SuperType实例) 中。<br>instance.constructor 现在指向的是 SuperType ，<br>这是因为原来 SubType.prototype 中的 constructor 被重写了的缘故(现在的SubType.prototype即SuperType实例，其原型SuperType 的 constructor指向SuperType构造函数)。</p>
<p>通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。<br>调用instance.getSuperValue() 会经历三个搜索步骤：<br>1）搜索实例；<br>2）搜索 SubType.prototype ；<br>3）搜索 SuperType.prototype ，最后一步才会找到该方法。</p>
<h3 id="别忘记默认的原型"><a href="#别忘记默认的原型" class="headerlink" title="别忘记默认的原型"></a>别忘记默认的原型</h3><p>前面例子中展示的原型链还少一环。所有引用类型默认都继承了 Object ，而这个继承也是通过原型链实现的。<br>有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype 。<br>这也正是所有自定义类型都会继承 toString() 、valueOf() 等默认方法的根本原因。<br>SubType 继承了 SuperType ，而 SuperType 继承了 Object 。当调用 instance.toString()时，实际上调用的是保存在 Object.prototype 中的那个方法。</p>
<h3 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><p>可以通过两种方式来确定原型和实例之间的关系。<br>1.使用 instanceof 操作符。用这个操作符来测试<strong>实例</strong>与原型链中出现过的<strong>构造函数</strong>，结果就会返回 true 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">//true</span></div><div class="line">alert(instance <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>2.使用 isPrototypeOf() 方法。同样，只要是原型链中出现过的<strong>原型</strong>，都可以说是该原型链所派生的<strong>实例的原型</strong>，因此 isPrototypeOf() 方法也会返回 true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></div><div class="line">alert(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></div><div class="line">alert(SubType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h3 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h3><p>给原型添加方法的代码一定要放在替换原型的语句之后。<br>在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//继承了 SuperType</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line"><span class="comment">// 使用字面量添加新方法，会导致上一行代码无效</span></div><div class="line">SubType.prototype = &#123;</div><div class="line">getSubValue : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;,</div><div class="line">someOtherMethod : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在的原型包含的是一个 Object 的实例，而非 SuperType 的实例，<br>因此我们设想中的原型链已经被切断—— SubType 和 SuperType 之间已经没有关系了。</p>
<h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>1.最主要的问题来自包含引用类型值的原型。<br>包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。<br>在通过原型来实现继承时，原型实际上会变成另一个类型的实例。<br>于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</p>
<p>2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。<br>应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
<p>因此，实践中很少会单独使用原型链。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>在解决<strong>原型中包含引用类型值</strong>所带来问题的过程中，开发人员开始使用一种叫做<strong>借用构造函数</strong>（constructor stealing）的技术（有时候也叫做<strong>伪造对象</strong>或<strong>经典继承</strong>）。<br>基本思想：即在子类型构造函数的内部调用超类型构造函数。<br>函数只不过是在特定环境中执行代码的对象，因此通过使用 apply() 和 call() 方法也可以在（将来）新创建的对象上执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">// 继承了 SuperType</span></div><div class="line">SuperType.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></div></pre></td></tr></table></figure>
<p>“借调”了超类型的构造函数。通过使用 call() 方法（或 apply() 方法也可以），<br>我们实际上是在（未来将要）新创建的 SubType 实例的环境下调用了 SuperType 构造函数。</p>
<p>结果，SubType 的每个实例就都会具有自己的 colors 属性的副本了。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//继承了 SuperType，同时还传递了参数</span></div><div class="line">SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</div><div class="line"><span class="comment">//实例属性</span></div><div class="line"><span class="keyword">this</span>.age = <span class="number">29</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.name); <span class="comment">//"Nicholas";</span></div><div class="line">alert(instance.age); <span class="comment">//29</span></div></pre></td></tr></table></figure>
<h3 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h3><p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，(于是就有了一个接一个的函数实例)<br>因此函数复用就无从谈起了。<br>而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。<br>考虑到这些问题，借用构造函数的技术也是很少单独使用的。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。<br>思路：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//继承属性</span></div><div class="line">SuperType.call(<span class="keyword">this</span>, name);</div><div class="line"></div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//继承方法</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></div><div class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></div><div class="line">instance1.sayAge(); <span class="comment">//29</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</div><div class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></div><div class="line">instance2.sayName(); <span class="comment">//"Greg";</span></div><div class="line">instance2.sayAge(); <span class="comment">//27</span></div></pre></td></tr></table></figure>
<p>在这个例子中 SubType 利用 call()/apply() 方法调用 SuperType 构造函数，继承了 SuperType 构造函数的属性（color）,并传入 name 参数，<br>又定义了它自己的属性 age 。之后将 SuperType 的实例赋值给 SubType 的原型实现了继承方法，然后又在该新原型上定义了方法 sayAge() 。<br>这样一来，就可以让两个不同的 SubType 实例既分别拥有自己属性——包括 colors 属性，又可以使用相同的方法了。</p>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。<br>而且， instanceof 和 isPrototypeOf() 也能够用于识别基于组合继承创建的对象。</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>道格拉斯·克罗克福德在 2006年写了一篇文章，题为 Prototypal Inheritance in JavaScript （JavaScript中的原型式继承）。<br>想法：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">F.prototype = o;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 object() 函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。<br>从本质上讲， object() 对传入其中的对象执行了一次浅复制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">name: <span class="string">"Nicholas"</span>,</div><div class="line">friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson = object(person);</div><div class="line">anotherPerson.name = <span class="string">"Greg"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</div><div class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</div><div class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</div><div class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></div></pre></td></tr></table></figure>
<p>这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。<br>如果有这么一个对象的话，可以把它传递给 object() 函数，然后再根据具体需求对得到的对象加以修改即可。<br>在这个例子中，可以作为另一个对象基础的是 person 对象，<br>于是我们把它传入到 object() 函数中，然后该函数就会返回一个新对象。<br>这个新对象将 person 作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。<br>这意味着 person.friends 不仅属于 person 所有，而且也会被 anotherPerson以及 yetAnotherPerson 共享。<br>实际上，这就相当于又创建了 person (实例)对象的两个副本。</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>ECMAScript 5 通过新增 Object.create() 方法规范化了原型式继承。<br>这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。<br>在传入一个参数的情况下，Object.create() 与 object() 方法的行为相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">name: <span class="string">"Nicholas"</span>,</div><div class="line">friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</div><div class="line">anotherPerson.name = <span class="string">"Greg"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</div><div class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</div><div class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</div><div class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></div></pre></td></tr></table></figure>
<p>Object.create() 方法的第二个参数与 Object.defineProperties() 方法的第二个参数格式相同：<br>每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">name: <span class="string">"Nicholas"</span>,</div><div class="line">friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</div><div class="line">name: &#123;</div><div class="line">value: <span class="string">"Greg"</span></div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name); <span class="comment">//"Greg"</span></div></pre></td></tr></table></figure>
<p>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。<br>不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。<br>思路:与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，<br>该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></div><div class="line">clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//以某种方式来增强这个对象</span></div><div class="line">alert(<span class="string">"hi"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">name: <span class="string">"Nicholas"</span>,</div><div class="line">friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></div></pre></td></tr></table></figure>
<p>这个例子中的代码基于 person 返回了一个新对象—— anotherPerson 。<br>新对象不仅具有 person的所有属性和方法，而且还有自己的 sayHi() 方法。<br>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。<br>前面示范继承模式时使用的 object() 函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。<br>组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：<br>一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。<br>子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。<br>基本思路:不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。<br>本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></div><div class="line">prototype.constructor = subType; <span class="comment">//增强对象</span></div><div class="line">subType.prototype = prototype; <span class="comment">//指定对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一步是创建超类型原型的一个副本。<br>第二步是为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性。<br>最后一步，将新创建的对象（即副本）赋值给子类型的原型。</p>
<p>原版：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">SuperType.call(<span class="keyword">this</span>, name); <span class="comment">// 第二次调用 SuperType()</span></div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 第一次调用 SuperType()</span></div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用寄生式组合继承的版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">SuperType.call(<span class="keyword">this</span>, name);</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样就只需要调用一次 SuperType 构造函数，避免了在SubType.prototype 上面创建不必要的、多余的属性。<br>与此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和 isPrototypeOf() 。<br>开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。<br>YUI 的 YAHOO.lang.extend() 方法采用了寄生组合继承，从而让这种模式首次出现在了一个应用非常广泛的 JavaScript 库中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第六章-2]]></title>
      <url>https://codingme.xyz/2016/09/20/javascript-note-6-2/</url>
      <content type="html"><![CDATA[<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：<br>使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。<br>考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.name = name;</div><div class="line">o.age = age;</div><div class="line">o.job = job;</div><div class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决<strong>对象识别的问题（即怎样知道一个对象的类型）</strong>。<br>随着 JavaScript的发展，又一个新模式出现了。</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>构造函数可用来创建特定类型的对象。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。<br>此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.job = job;</div><div class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>与工厂模式的createPerson()的不同之处：</p>
<ol>
<li>没有显式地创建对象；</li>
<li>直接将属性和方法赋给了 this 对象；</li>
<li>没有 return 语句。</li>
</ol>
<p>函数名 Person 使用的是大写字母 P。<br>按照惯例，<strong>构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</strong></p>
<p>要创建 Person 的新实例，必须使用 new 操作符。会经历以下 4个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
<p>在前面例子的最后， person1 和 person2 分别保存着 Person 的一个不同的实例。<br>这两个对象都有一个 constructor （构造函数）属性，该属性指向 Person。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对象的 constructor 属性最初是用来标识对象类型的。</span></div><div class="line">alert(person1.constructor == Person); <span class="comment">//true</span></div><div class="line">alert(person2.constructor == Person); <span class="comment">//true</span></div><div class="line"></div><div class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。<br>以这种方式定义的构造函数是定义在 Global 对象（在浏览器中是 window 对象）中的。</p>
<h3 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h3><p>造函数与其他函数的唯一区别，就在于调用它们的方式不同。<br>任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当作构造函数使用</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">person.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line"><span class="comment">// 作为普通函数调用</span></div><div class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>); <span class="comment">// 添加到 window</span></div><div class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//"Greg"</span></div><div class="line"><span class="comment">// 在另一个对象的作用域中调用</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</div><div class="line">o.sayName(); <span class="comment">//"Kristen"</span></div></pre></td></tr></table></figure>
<p>当在全局作用域中调用一个函数时， this 对象总是指向 Global 对象（在浏览器中就是 window 对象）。<br>因此，在调用完函数之后，可以通过 window 对象来调用 sayName() 方法，并且还返回了 “Greg” 。</p>
<h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>使用构造函数的主要问题，就是<strong>每个方法都要在每个实例上重新创建一遍</strong>。<br>person1 和 person2 都有一个名为 sayName() 的方法，但那两个方法不是同一个 Function 的实例。<br>ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.job = job;</div><div class="line"><span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(this.name)"</span>); <span class="comment">//  与声明函数在逻辑上是等价的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以这种方式创建函数，会导致不同的作用域链和标识符解析，<br>但创建 Function 新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的。<br><code>alert(person1.sayName == person2.sayName); //false</code><br>创建两个完成同样任务的 Function 实例的确没有必要；<br>况且有 this 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。<br>因此，大可通过把函数定义转移到构造函数外部来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.job = job;</div><div class="line"><span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。<br>而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，<br>于是我们这个自定义的引用类型就丝毫没有封装性可言了。<br>于是就有了原型模式。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>我们创建的每个函数都有一个 prototype （原型）属性，<br>这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<br>如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。<br>使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。<br>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。<br>但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。</p>
<h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype属性，这个属性指向函数的原型对象。<br>在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。<br>Person.prototype. constructor 指向 Person 。<br>而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。<br>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则都是从 Object 继承而来的。<br>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。<br>ECMA-262 第 5 版中管这个指针叫 [[Prototype]] 。<br>虽然在脚本中没有标准的方式访问 [[Prototype]] ，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性<code>__proto__</code> ；而在其他实现中，这个属性对脚本则是完全不可见的。</p>
<p>新构造函数Person.prototype属性-&gt; Person Prototype原型对象<br>Person.prototype(原型对象).constructor属性 -&gt;  构造函数Person<br>person1、person2（实例）. [[Prototype]] -&gt; Person Prototype</p>
<p>虽然这两个实例都不包含属性和方法，但我们却可以调用 person1.sayName() 。这是通过查找对象属性的过程来实现的。<br>查找对象属性：每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。<br>搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；<br>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。<br>如果在原型对象中找到了这个属性，则返回该属性的值。<br>在我们调用 person1.sayName() 的时候，会先后执行两次搜索。<br>首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。”<br>然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。”<br>于是，它就读取那个保存在原型对象中的函数。<br>要点：原型最初只包含 constructor 属性，而该属性也是共享的，因此可以通过对象实例访问。<br>但是不能通过对象实例重写原型中的值。<br>要重新从对象实例中访问原型对象的属性的话，可以使用 delete 删除对象实例屏蔽的同名属性。</p>
<p>虽然在所有实现中都无法访问到 [[Prototype]] ，但可以通过 isPrototypeOf() 方法来确定对象之间是否存在这种关系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Person.prototype.isPrototypeOf(person1)); <span class="comment">//true</span></div><div class="line">alert(Person.prototype.isPrototypeOf(person2)); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h4 id="Object-getPrototypeOf-ECMAScript5"><a href="#Object-getPrototypeOf-ECMAScript5" class="headerlink" title="Object.getPrototypeOf()(ECMAScript5)"></a>Object.getPrototypeOf()(ECMAScript5)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span></div><div class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>使用 Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。</p>
<h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h4><p>使用 hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中。(是从 Object 继承来的)<br>如果来自实例则为true，来自原型则为false。</p>
<h4 id="Object-getOwnPropertyDescriptor-ECMAScript5"><a href="#Object-getOwnPropertyDescriptor-ECMAScript5" class="headerlink" title="Object.getOwnPropertyDescriptor()(ECMAScript5)"></a>Object.getOwnPropertyDescriptor()(ECMAScript5)</h4><p>ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法只能用于实例属性，<br>要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor() 方法。</p>
<h3 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 in 操作符</h3><p>使用 in 操作符的两种方式：<br>单独使用和在 for-in 循环中使用。</p>
<p><strong>1.</strong>在单独使用时， in 操作符会在通过对象能够访问给定属性时返回 true ，无论该属性存在于实例中还是原型中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">person1.name = <span class="string">"Greg"</span>;</div><div class="line">alert(person1.name); <span class="comment">//"Greg" ——来自实例</span></div><div class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//true</span></div><div class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">//true</span></div><div class="line">alert(person2.name); <span class="comment">//"Nicholas" ——来自原型</span></div><div class="line">alert(person2.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//false</span></div><div class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person2); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>两者可结合写成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</div><div class="line">&#125;</div><div class="line">person.name = <span class="string">"Greg"</span>;</div><div class="line">alert(hasPrototypeProperty(person, <span class="string">"name"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>即使原型中仍然有 name 属性，但由于现在实例中也有了这个属性，因此原型中的 name 属性就用不到了。所以返回false。</p>
<p><strong>2.</strong>在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。<br>屏蔽了原型中不可枚举属性（即将[[Enumerable]] 标记为 false 的属性）的实例属性也会在 for-in 循环中返回，<br>因为根据规定，所有开发人员定义的属性都是可枚举的——只有在 IE8 及更早版本中例外。<br>IE的BUG:<br>IE 早期版本的实现中存在一个 bug，即屏蔽不可枚举属性的实例属性不会出现在 for-in 循环中。<br>该 bug 会影响默认不可枚举的所有属性和方法，包括：hasOwnProperty() 、 propertyIsEnumerable() 、 toLocaleString() 、 toString() 和 valueOf() 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"My Object"</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o)&#123;</div><div class="line"><span class="keyword">if</span> (prop == <span class="string">"toString"</span>)&#123;</div><div class="line">alert(<span class="string">"Found toString"</span>); <span class="comment">//在 IE 中不会显示</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ECMAScript 5 也将 constructor 和 prototype 属性的 [[Enumerable]] 特性设置为 false ，但并不是所有浏览器都照此实现。</p>
<h4 id="Object-keys-ECMAScript5"><a href="#Object-keys-ECMAScript5" class="headerlink" title="Object.keys()(ECMAScript5)"></a>Object.keys()(ECMAScript5)</h4><p>要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 Object.keys() 方法。<br>这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。<br>如果是通过实例调用，则 Object.keys()返回的数组只包含实例属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</div><div class="line">alert(keys); <span class="comment">//"name,age,job,sayName"</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">p1.name = <span class="string">"Rob"</span>;</div><div class="line">p1.age = <span class="number">31</span>;</div><div class="line"><span class="keyword">var</span> p1keys = <span class="built_in">Object</span>.keys(p1);</div><div class="line">alert(p1keys); <span class="comment">//"name,age"</span></div></pre></td></tr></table></figure>
<p>如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames()方法。(同样是ECMAScript5)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype);</div><div class="line">alert(keys); <span class="comment">//"constructor,name,age,job,sayName"</span></div></pre></td></tr></table></figure>
<h3 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h3><p>用一个包含所有属性和方法的对象字面量来重写整个原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">name : <span class="string">"Nicholas"</span>,</div><div class="line">age : <span class="number">29</span>,</div><div class="line">job: <span class="string">"Software Engineer"</span>,</div><div class="line">sayName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>例子的最终结果相同，但有一个例外： constructor 属性不再指向 Person 了。<br>我们在这里使用的语法，本质上完全重写了默认的 prototype 对象，<br>因此 constructor 属性也就变成了新对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line">alert(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(friend <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line">alert(friend.constructor == Person); <span class="comment">//false</span></div><div class="line">alert(friend.constructor == <span class="built_in">Object</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>如果 constructor 的值真的很重要，可以特意将它设置回适当的值。<br><code>constructor : Person,</code><br>注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true。<br>默认情况下，原生的 constructor 属性是不可枚举的。<br>如果使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty() 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 重设构造函数，只适用于 ECMAScript 5  兼容的浏览器</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</div><div class="line">enumerable: <span class="literal">false</span>,</div><div class="line">value: Person</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来<br>——即使是先创建了实例后修改原型也照样如此。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="string">"hi"</span>);</div><div class="line">&#125;;</div><div class="line">friend.sayHi(); <span class="comment">//"hi"（没有问题！）</span></div></pre></td></tr></table></figure>
<p>原因可以归结为实例与原型之间的松散连接关系。当我们调用 person.sayHi()时，首先会在实例中搜索名为 sayHi 的属性，<br>在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，<br>因此就可以在原型中找到新的 sayHi 属性并返回保存在那里的函数。</p>
<p>如果是重写整个原型对象，那么情况就不一样了。调用构造函数时会为实例添加一个指向最初原型的[[Prototype]] 指针，<br>而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。<br><strong>实例中的指针仅指向原型，而不指向构造函数。</strong><br>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。</p>
<h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。<br>所有原生引用类型（ Object 、 Array 、 String ，等等）都在其构造函数的原型上定义了方法。</p>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。<br>可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。<br><strong>尽管可以这样做，但不推荐在产品化的程序中修改原生对象的原型。当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。</strong><br><strong>这样做也可能会意外地重写原生方法。</strong></p>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><ol>
<li>省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。</li>
<li>最大问题是由其共享的本性所导致的。<br> 原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。<br> 对于那些包含基本值的属性倒也说得过去，毕竟，通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。<br> 然而，对于包含引用类型值的属性来说，问题就比较突出了。<br> 实例一般都是要有属于自己的全部属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。</li>
</ol>
<h2 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h2><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。<br>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。<br>结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。<br>另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.job = job;</div><div class="line"><span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line"><span class="keyword">constructor</span> : Person,</div><div class="line">sayName : function()&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种构造函数与原型混成的模式，是目前在 ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>动态原型模式致力于解决 有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时的困惑。<br>它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="comment">//属性</span></div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.job = job;</div><div class="line"></div><div class="line"><span class="comment">// 方法</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<p>这里只在 sayName() 方法不存在的情况下，才会将它添加到原型中。这<br>段代码只会在初次调用构造函数时才会执行。<br>此后，原型已经完成初始化，不需要再做什么修改了。这里对原型所做的修改，能够立即在所有实例中得到反映。<br>对于采用这种模式创建的对象，还可以使用 instanceof 操作符确定它的类型。</p>
<p>使用动态原型模式时，不能使用对象字面量重写原型。否则会切断现有实例与新原型之间的联系。</p>
<h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><p>在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。<br>基本思想：<br>创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；<br>但从表面上看，这个函数又很像是典型的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.name = name;</div><div class="line">o.age = age;</div><div class="line">o.job = job;</div><div class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName(); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。<br>返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。<br>为此，不能依赖 instanceof 操作符来确定对象类型。<br>(所以面对的问题也是一样的：对象识别问题、函数实例化问题)<br>所以建议在可以使用其他模式的情况下，不要使用这种模式。</p>
<p>使用示例：<br>可以在特殊的情况下用来为对象创建构造函数。<br>假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//创建数组</span></div><div class="line"><span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="comment">//添加值</span></div><div class="line">values.push.apply(values, <span class="built_in">arguments</span>);</div><div class="line"><span class="comment">//添加方法</span></div><div class="line">values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">//返回数组</span></div><div class="line"><span class="keyword">return</span> values;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</div><div class="line">alert(colors.toPipedString()); <span class="comment">//"red|blue|green"</span></div></pre></td></tr></table></figure>
<h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><p>道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的稳妥对象（durable objects）这个概念。<br>指的是没有公共属性，而且其方法也不引用 this 的对象。<br>稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new ），或者在防止数据被其他应用程序（如 Mashup程序）改动时使用。</p>
<p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：<br>一是新创建对象的实例方法不引用 this ；<br>二是不使用 new 操作符调用构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"><span class="comment">//创建要返回的对象</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line"><span class="comment">//可以在这里定义私有变量和函数</span></div><div class="line"><span class="comment">//公共变量：</span></div><div class="line"><span class="comment">//this.name = name;</span></div><div class="line"><span class="comment">//私有变量：</span></div><div class="line"><span class="comment">//var name = name;</span></div><div class="line"><span class="comment">//一般来说加下划线的变量为私有变量,这是常规都比较遵守的一种代码规范。</span></div><div class="line"><span class="comment">//var _name = name;</span></div><div class="line"></div><div class="line"><span class="comment">//添加方法</span></div><div class="line">o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(name);</div><div class="line">&#125;;</div><div class="line"><span class="comment">//返回对象</span></div><div class="line"><span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName(); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>变量 friend 中保存的是一个稳妥对象，除了使用 sayName() 方法之外，没有其他办法访问 name 的值。</p>
<p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有意义。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第六章-1]]></title>
      <url>https://codingme.xyz/2016/09/20/javascript-note-6-1/</url>
      <content type="html"><![CDATA[<h1 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h1><p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”<br>严格来讲，这就相当于说对象是一组没有特定顺序的值。<br>对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。<br>我们可以把 ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。<br>每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员定义的类型。</p>
<p>创建自定义对象最简单方式就是创建一个 Object 的实例，然后再为它添加属性和方法。<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"Nicholas"</span>;</div><div class="line">person.age = <span class="number">29</span>;</div><div class="line">person.job = <span class="string">"Software Engineer"</span>;</div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*早期JavaScript开发人员经常用这种模式创建新对象，</span></div><div class="line">几年后，对象字面量成为创建这种对象的首选模式。</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">name: <span class="string">"Nicholas"</span>,</div><div class="line">age: <span class="number">29</span>,</div><div class="line">job: <span class="string">"Software Engineer"</span>,</div><div class="line">sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些属性在创建时都带有一些特征值（characteristic），JavaScript通过这些特征值来定义它们的行为。</p>
<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><p>ECMAScript 中有两种属性：数据属性和访问器属性。</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的特性。</p>
<ol>
<li>[[Configurable]] ：(能否被配置)<br> 表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。<br> 像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true 。</li>
<li>[[Enumerable]] ：(能否被枚举)<br> 表示能否通过 for-in 循环返回属性。<br> 像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true 。</li>
<li>[[Writable]] ：(能否被修改)<br> 表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，<br> 它们的这个特性默认值为 true 。</li>
<li>[[Value]] ：(数据值)<br> 包含这个属性的数据值。读取属性值的时候，从这个位置读；<br> 写入属性值的时候，把新值保存在这个位置。<br> 这个特性的默认值为 undefined 。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">name: <span class="string">"Nicholas"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里创建了一个名为 name 的属性，为它指定的值是 “Nicholas” 。<br>也就是说， [[Value]] 特性将被设置为 “Nicholas” ，而对这个值的任何修改都将反映在这个位置。<br>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty() 方法。<br>这个方法接收三个参数：<strong>属性所在的对象</strong>、<strong>属性的名字</strong>和<strong>一个描述符对象</strong>。<br>其中，描述符（descriptor）对象的属性必须是： configurable 、 enumerable 、 writable 和 value 。<br>设置其中的一或多个值，可以修改对应的特性值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">这个例子创建了一个名为 name 的属性，它的值 "Nicholas" 是只读的。这个属性的值是不可修改</div><div class="line">的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导</div><div class="line">致抛出错误。</div><div class="line">*/</div><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">writable: <span class="literal">false</span>,</div><div class="line">value: <span class="string">"Nicholas"</span></div><div class="line">&#125;);</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div><div class="line">person.name = <span class="string">"Greg"</span>;</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>可以多次调用 Object.defineProperty() 方法修改同一个属性，但在把 configurable特性设置为 false 之后就会有限制了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">configurable: <span class="literal">false</span>,</div><div class="line">value: <span class="string">"Nicholas"</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//抛出错误</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">configurable: <span class="literal">true</span>,</div><div class="line">value: <span class="string">"Nicholas"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在调用 Object.defineProperty() 方法时，<br>如果不指定， configurable 、 enumerable 和writable 特性的默认值都是 false 。<br>多数情况下，可能都没有必要利用 Object.defineProperty()方法提供的这些高级功能。</p>
<p>IE的BUG：IE8 是第一个实现 Object.defineProperty() 方法的浏览器版本。<br>然而由于实现不彻底，建议不要在 IE8 中使用 Object.defineProperty()方法。</p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。<br>在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；<br>在写入访问器属性时，会调用setter 函数并传入新值，这个函数负责决定如何处理数据。<br>访问器属性有如下 4 个特性。</p>
<ol>
<li>[[Configurable]] ：<br> 表示能否通过 delete 删除属性从而重新定义属性，<br> 能否修改属性的特性，或者能否把属性修改为数据属性。<br> 对于直接在对象上定义的属性，这个特性的默认值为true 。</li>
<li>[[Enumerable]] ：<br> 表示能否通过 for-in 循环返回属性。<br> 对于直接在对象上定义的属性，这个特性的默认值为 true 。</li>
<li>[[Get]] ：<br> 在读取属性时调用的函数。默认值为 undefined 。</li>
<li>[[Set]] ：<br> 在写入属性时调用的函数。默认值为 undefined 。</li>
</ol>
<p>访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">_year: <span class="number">2004</span>,</div><div class="line">edition: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">&#125;,</div><div class="line">set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line"><span class="keyword">this</span>._year = newValue;</div><div class="line"><span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。<br>setter 函数通过计算来确定正确的版本。因此，把 year 属性修改为 2005 会导致 _year 变成 2005，而 edition 变为 2。<br>这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。</p>
<p>不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性是不能写，尝试写入属性会被忽略。<br>在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。<br>类似地，只指定 setter 函数的属性也不能读，否则在非严格模式下会返回 undefined ，而在严格模式下会抛出错误。<br>支持 ECMAScript 5 的这个方法的浏览器有 IE9+（IE8 只是部分实现）、Firefox 4+、Safari 5+、Opera 12+和 Chrome。<br>在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：<br><code>__defineGetter__()</code> 和 <code>__defineSetter__()</code>。<br>这两个方法最初是由 Firefox 引入的，后来 Safari 3、Chrome 1和 Opera 9.5 也给出了相同的实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">_year: <span class="number">2004</span>,</div><div class="line">edition: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 定义访问器的旧有方法</span></div><div class="line">book.__defineGetter__(<span class="string">"year"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">&#125;);</div><div class="line">book.__defineSetter__(<span class="string">"year"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line"><span class="keyword">this</span>._year = newValue;</div><div class="line"><span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>在 不 支 持 Object.defineProperty() 方 法 的 浏 览 器 中 不 能 修 改 [[Configurable]] 和[[Enumerable]] 。</p>
<h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>支持 Object.defineProperties() 方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。<br>由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个 Object.defineProperties() 方法。<br>利用这个方法可以通过描述符一次定义多个属性。<br>这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</div><div class="line">_year: &#123;</div><div class="line">value: <span class="number">2004</span></div><div class="line">&#125;,</div><div class="line">edition: &#123;</div><div class="line">value: <span class="number">1</span></div><div class="line">&#125;,</div><div class="line">year: &#123;</div><div class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">&#125;,</div><div class="line">set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line"><span class="keyword">this</span>._year = newValue;</div><div class="line"><span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法，可以取得给定属性的描述<br>符。<br>这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。<br>返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable 、 enumerable 、 get 和 set ；<br>如果是数据属性，这个对象的属性有 configurable 、 enumerable 、 writable 和 value 。<br>在 JavaScript 中，可以针对任何对象——包括 DOM 和 BOM 对象，使用 Object.getOwnPropertyDescriptor() 方法。<br>支持这个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</div><div class="line">alert(descriptor.value); <span class="comment">//2004</span></div><div class="line">alert(descriptor.configurable); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>对于数据属性 _year ， value 等于最初的值， configurable 是 false ，而 get 等于undefined 。<br>对于访问器属性 year ， value 等于 undefined ， enumerable 是 false ，而 get 是一个指向 getter函数的指针。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第五章-5]]></title>
      <url>https://codingme.xyz/2016/09/20/javascript-note-5-5/</url>
      <content type="html"><![CDATA[<h1 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h1><p>内置对象的定义是：“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。”<br>开发人员不必显式地实例化内置对象，因为它们已经实例化了。<br>大多数内置对象，例如 Object 、 Array 和 String 。<br>ECMA-262 还定义了两个单体内置对象： Global 和 Math 。</p>
<h2 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h2><p>Global （全局）对象可以说是 ECMAScript 中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。<br>ECMAScript 中的 Global 对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。<br>换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。<br><strong>事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。</strong></p>
<p>诸如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat() ，实际上全都是 Global对象的方法。<br>除此之外， Global 对象还包含其他一些方法。</p>
<a id="more"></a>
<h3 id="URI-编码方法"><a href="#URI-编码方法" class="headerlink" title="URI 编码方法"></a>URI 编码方法</h3><p>encodeURI() 和 encodeURIComponent() 方法。<br>这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。</p>
<p>encodeURI() 主要用于整个 URI（例如，<a href="http://www.wrox.com/illegalvalue.htm/" target="_blank" rel="external">http://www.wrox.com/illegalvalue.htm/</a>），<br>而 encode-URIComponent() 主要用于对 URI 中的某一段（例如前面 URI 中的 illegal value.htm ）进行编码。</p>
<p>主要区别在于， encodeURI() 不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；<br>而 encodeURIComponent() 则会对它发现的任何非标准字符进行编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> uri = <span class="string">"http://www.wrox.com/illegal value.htm#start"</span>;</div><div class="line"><span class="comment">//"http://www.wrox.com/illegal%20value.htm#start"</span></div><div class="line">alert(<span class="built_in">encodeURI</span>(uri));</div><div class="line"><span class="comment">//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span></div><div class="line">alert(<span class="built_in">encodeURIComponent</span>(uri));</div></pre></td></tr></table></figure>
<p>一般来说，我们使用encodeURIComponent()方法的时候要比使用encodeURI()更多，<br>因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码。</p>
<p>与 encodeURI() 和 encodeURIComponent() 方法对应的两个方法分别是 decodeURI() 和decodeURIComponent() 。<br>decodeURI() 只能对使用 encodeURI() 替换的字符进行解码。<br>例如，它可将 <code>%20</code> 替换成一个空格，但不会对 <code>%23</code> 作任何处理，因为 <code>%23</code> 表示井字号（ # ），而井字号不是使用encodeURI() 替换的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> uri = <span class="string">"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span>;</div><div class="line"><span class="comment">//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start</span></div><div class="line">alert(<span class="built_in">decodeURI</span>(uri));</div><div class="line"><span class="comment">//http://www.wrox.com/illegal value.htm#start</span></div><div class="line">alert(<span class="built_in">decodeURIComponent</span>(uri));</div></pre></td></tr></table></figure>
<p>URI 方法 encodeURI() 、 encodeURIComponent() 、 decodeURI() 和 decodeURIComponent() 用于替代已经被ECMA-262第3版废弃的 escape() 和 unescape()方法。<br>URI方法能够编码所有 Unicode字符，而原来的方法只能正确地编码 ASCII字符。<br>因此在开发实践中，特别是在产品级的代码中，一定要使用URI方法，不要使用 escape()和 unescape() 方法。</p>
<h3 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval() 方法"></a>eval() 方法</h3><p>大概是整个 ECMAScript语言中最强大的一个方法： eval() 。<br>eval()方法就像是一个完整的 ECMAScript 解析器，<br>它只接受一个参数，即要执行的 ECMAScript （或 JavaScript）字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"alert('hi')"</span>);</div><div class="line"><span class="comment">//等价于</span></div><div class="line">alert(<span class="string">"hi"</span>);</div></pre></td></tr></table></figure>
<p>当解析器发现代码中调用 eval() 方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置。<br>通过 eval() 执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。<br>这意味着通过 eval() 执行的代码可以引用在包含环境中定义的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">eval</span>(<span class="string">"alert(msg)"</span>); <span class="comment">//"hello world"</span></div><div class="line"></div><div class="line"><span class="built_in">eval</span>(<span class="string">"function sayHi() &#123; alert('hi'); &#125;"</span>);</div><div class="line">sayHi();</div><div class="line"></div><div class="line"><span class="built_in">eval</span>(<span class="string">"var msg = 'hello world'; "</span>);</div><div class="line">alert(msg); <span class="comment">//"hello world"</span></div></pre></td></tr></table></figure>
<p>在 eval() 中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；<br>它们只在 eval() 执行的时候创建。<br>严格模式下，在外部访问不到 eval() 中创建的任何变量或函数,为 eval 赋值也会导致错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="built_in">eval</span> = <span class="string">"hi"</span>; <span class="comment">//causes error</span></div></pre></td></tr></table></figure>
<p>要点：能够解释代码字符串的能力非常强大，但也非常危险。因此在使用 eval() 时必须极为谨慎，<br>特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）。</p>
<h3 id="Global-对象的属性"><a href="#Global-对象的属性" class="headerlink" title="Global 对象的属性"></a>Global 对象的属性</h3><pre><code>undefined   Date            NaN
RegExp      Infinity        Error
Object      EvalError       Array
RangeError  Function        ReferenceError
Boolean     SyntaxError     String
TypeError   Number          URIError
</code></pre><p>ECMAScript 5 明确禁止给 undefined 、 NaN 和 Infinity 赋值，这样做即使在非严格模式下也会导致错误。</p>
<h3 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h3><p>ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为window 对象的一部分加以实现的。<br>因此，在全局作用域中声明的所有变量和函数，就都成为了 window对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="built_in">window</span>.color);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.sayColor(); <span class="comment">//"red"</span></div></pre></td></tr></table></figure>
<p>JavaScript中的 window 对象除了扮演ECMAScript规定的 Global 对象的角色外，还承担了很多别的任务。</p>
<p>另一种取得 Global 对象的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<h2 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h2><h3 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h3><pre><code>属性          说明
Math.E          自然对数的底数，即常量e的值
Math.LN10       10的自然对数
Math.LN2        2的自然对数
Math.LOG2E      以2为底e的对数
Math.LOG10E     以10为底e的对数
Math.PI         π的值
Math.SQRT1_2    1/2的平方根（即2的平方根的倒数）
Math.SQRT2      2的平方根
</code></pre><h3 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min() 和 max() 方法"></a>min() 和 max() 方法</h3><p>这两个方法经常用于避免多余的循环和在 if 语句中确定一组数的最大值。<br>要找到数组中的最大或最小值，可以像下面这样使用 apply() 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</div><div class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</div></pre></td></tr></table></figure>
<h3 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h3><p>Math.ceil() 执行向上舍入，即它总是将数值向上舍入为最接近的整数；<br>Math.floor() 执行向下舍入，即它总是将数值向下舍入为最接近的整数；<br>Math.round() 执行标准舍入，即它总是将数值四舍五入为最接近的整数（这也是我们在数学课上学到的舍入规则）。</p>
<h3 id="random-方法"><a href="#random-方法" class="headerlink" title="random() 方法"></a>random() 方法</h3><p><code>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</code><br>想选择一个 1到 10 之间的数值的话，<br><code>var num = Math.floor(Math.random() * 10 + 1);</code><br>想要选择一个介于 2 到 10 之间的值的话,<br><code>var num = Math.floor(Math.random() * 9 + 2);</code></p>
<p>也可以写成函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> choices = upperValue - lowerValue + <span class="number">1</span>;</div><div class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lowerValue);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> num = selectFrom(<span class="number">2</span>, <span class="number">10</span>);</div><div class="line">alert(num); <span class="comment">// 介于 2 和 10 之间（包括 2 和 10）的一个数值</span></div></pre></td></tr></table></figure>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><pre><code>Math.abs(num)           返回 num 的绝对值
Math.asin(x)            返回 x 的反正弦值
Math.exp(num)           返回 Math.E 的 num 次幂
Math.atan(x)            返回 x 的反正切值
Math.log(num)           返回 num 的自然对数
Math.atan2(y,x)         返回 y/x 的反正切值
Math.pow(num,power)     返回 num 的 power 次幂
Math.cos(x)             返回 x 的余弦值
Math.sqrt(num)          返回 num 的平方根
Math.sin(x)             返回 x 的正弦值
Math.acos(x)            返回 x 的反余弦值
Math.tan(x)             返回 x 的正切值
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第五章-4]]></title>
      <url>https://codingme.xyz/2016/09/20/javascript-note-5-4/</url>
      <content type="html"><![CDATA[<h1 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h1><p>为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型： Boolean 、 Number 和String 。<br>这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。<br>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</div><div class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">//等同于</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</div><div class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</div><div class="line">s1 = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>后台操作：<br>(1) 创建 String 类型的一个实例；<br>(2) 在实例上调用指定的方法；<br>(3) 销毁这个实例。<br>这三个步骤也分别适用于 Boolean和 Number 类型对应的布尔值和数字值。<br><a id="more"></a><br>引用类型与基本包装类型的主要区别就是对象的生存期。<br>要点：<strong>引用类型与基本包装类型的主要区别就是对象的生存期。</strong><br>使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。<br>而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</div><div class="line">s1.color = <span class="string">"red"</span>;</div><div class="line">alert(s1.color); <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了。<br>第三行代码又创建自己的 String 对象，而该对象没有 color 属性。</p>
<p>当然，可以显式地调用 Boolean 、 Number 和 String 来创建基本包装类型的对象。<br>不过，应该在绝对必要的情况下再这样做，<br>因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。<br>对基本包装类型的实例调用 typeof 会返回 “object” ，<br>而且所有基本包装类型的对象都会被转换为布尔值 true 。</p>
<p>Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);</div><div class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>使用 new 调用<strong>基本包装类型的构造函数</strong>，与直接调用同名的<strong>转型函数</strong>是不一样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</div><div class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">//转型函数</span></div><div class="line">alert(<span class="keyword">typeof</span> number); <span class="comment">//"number"</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数</span></div><div class="line">alert(<span class="keyword">typeof</span> obj); <span class="comment">//"object"</span></div></pre></td></tr></table></figure>
<p>变量 number 中保存的是基本类型的值 25，而变量 obj 中保存的是 Number 的实例。</p>
<h2 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><p><code>var booleanObject = new Boolean(true);</code><br>Boolean 类型的实例重写了 valueOf() 方法，返回基本类型值 true 或 false ；<br>重写了 toString()方法，返回字符串 “true” 和 “false” 。<br>可是 Boolean 对象在 ECMAScript 中的用处不大，因为它经常会造成人们的误解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</div><div class="line">alert(result); <span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> falseValue = <span class="literal">false</span>;</div><div class="line">result = falseValue &amp;&amp; <span class="literal">true</span>;</div><div class="line">alert(result); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(<span class="keyword">typeof</span> falseObject); <span class="comment">//object</span></div><div class="line">alert(<span class="keyword">typeof</span> falseValue); <span class="comment">//boolean</span></div><div class="line">alert(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></div><div class="line">alert(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>理解基本类型的布尔值与 Boolean 对象之间的区别非常重要<br>——当然，我们的建议是<strong>永远不要使用 Boolean 对象。</strong></p>
<h2 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h2><p><code>var numberObject = new Number(10);</code></p>
<p>Number 类型也重写了 valueOf() 、 toLocaleString() 和 toString()方法。<br>重写后的 valueOf() 方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。<br>还可以为 toString() 方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。<br>除了继承的方法之外， Number 类型还提供了一些用于将数值格式化为字符串的方法。</p>
<h3 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed()"></a>toFixed()</h3><p>toFixed() 方法会按照指定的小数位返回数值的字符串表示。<br>toFixed()方法能够自动舍入，还能填补必要的小数位。</p>
<p>IE的小BUG:在给 toFixed() 传入 0 的情况下，IE8 及之前版本不能正确舍入范围在{(-0.94,-0.5],[0.5,0.94)}之间的值。<br>对于这个范围内的值，IE 会返回 0，而不是-1 或 1；<br>其他浏览器都能返回正确的值。IE9 修复了这个问题。</p>
<h3 id="toExponential"><a href="#toExponential" class="headerlink" title="toExponential()"></a>toExponential()</h3><p>该方法返回以指数表示法（也称 e 表示法）表示的数值的字符串形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toExponential(<span class="number">1</span>)); <span class="comment">//"1.0e+1"</span></div></pre></td></tr></table></figure>
<h3 id="toPrecision"><a href="#toPrecision" class="headerlink" title="toPrecision()"></a>toPrecision()</h3><p>可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；<br>具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">99</span>;</div><div class="line">alert(num.toPrecision(<span class="number">1</span>)); <span class="comment">//"1e+2"</span></div><div class="line">alert(num.toPrecision(<span class="number">2</span>)); <span class="comment">//"99"</span></div><div class="line">alert(num.toPrecision(<span class="number">3</span>)); <span class="comment">//"99.0"</span></div></pre></td></tr></table></figure>
<p>因为一位数无法准确地表示 99，因此 toPrecision() 就将它向上舍入为 100,结果是 “1e+2”。<br>实际上， toPrecision() 会根据要处理的数值决定到底是调用 toFixed() 还是调用 toExponential() 。<br>而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。<br>toPrecision() 方法可以表现 1 到 21 位小数。某些浏览器支持的范围更大，但这是典型实现的范围。</p>
<p>不建议直接实例化 Number 类型，而原因与显式创建 Boolean 对象一样。<br>在使用typeof 和 instanceof 操作符测试基本类型数值与引用类型数值时，得到的结果完全不同。</p>
<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p><code>var stringObject = new String(&quot;hello world&quot;);</code></p>
<p>length属性即使字符串中包含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符。<br>String 类型提供了很多方法，用于辅助完成对 ECMAScript 中字符串的解析和操作。</p>
<h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>charAt() 和 charCodeAt() 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line">alert(stringValue.charAt(<span class="number">1</span>)); <span class="comment">//"e"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line">alert(stringValue.charCodeAt(<span class="number">1</span>)); <span class="comment">// 输出"101"</span></div></pre></td></tr></table></figure>
<p><strong>ECMAScript 5</strong>还定义了另一个访问个别字符的方法。(兼容性问题…)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line">alert(stringValue[<span class="number">1</span>]); <span class="comment">//"e"</span></div></pre></td></tr></table></figure>
<h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><p>concat() ，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。跟Array的方法等同。<br>虽然 concat() 是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符（+）。<br>而且，使用加号操作符在大多数情况下都比使用 concat()方法要简便易行（特别是在拼接多个字符串的情况下）。</p>
<p>ECMAScript还提供了三个基于子字符串创建新字符串的方法： slice() 、 substr() 和 substring() 。<br>这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。<br>第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。<br>它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。</p>
<h4 id="slice-和substr-、substring-的区别"><a href="#slice-和substr-、substring-的区别" class="headerlink" title="slice() 和substr()、substring() 的区别"></a>slice() 和substr()、substring() 的区别</h4><p>当传入参数是非负数时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ar stringValue = <span class="string">"hello world"</span>;</div><div class="line">alert(stringValue.slice(<span class="number">3</span>));</div><div class="line"><span class="comment">//"lo world"</span></div><div class="line">alert(stringValue.substring(<span class="number">3</span>));</div><div class="line"><span class="comment">//"lo world"</span></div><div class="line">alert(stringValue.substr(<span class="number">3</span>));</div><div class="line"><span class="comment">//"lo world"</span></div><div class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>));</div><div class="line"><span class="comment">//"lo w"</span></div><div class="line">alert(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>));</div><div class="line"><span class="comment">//"lo w"</span></div><div class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>));</div><div class="line"><span class="comment">//"lo worl"  substr() 的第二个参数指定的则是返回的字符个数。</span></div></pre></td></tr></table></figure>
<p>当传入参数是负数时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line">alert(stringValue.slice(<span class="number">-3</span>));</div><div class="line"><span class="comment">//"rld"    slice() 方法会将传入的负值与字符串的长度相加。</span></div><div class="line">alert(stringValue.substring(<span class="number">-3</span>));</div><div class="line"><span class="comment">//"hello world"  substring() 方法会把所有负值参数都转换为 0。</span></div><div class="line">alert(stringValue.substr(<span class="number">-3</span>));</div><div class="line"><span class="comment">//"rld"</span></div><div class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">-4</span>));</div><div class="line"><span class="comment">//"lo w"</span></div><div class="line">alert(stringValue.substring(<span class="number">3</span>, <span class="number">-4</span>));</div><div class="line"><span class="comment">//"hel"</span></div><div class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">-4</span>));</div><div class="line"><span class="comment">//"" （空字符串） substr() 方法将负的第一个参数加上字符串的长度，</span></div><div class="line"><span class="comment">//而将负的第二个参数转换为 0。</span></div></pre></td></tr></table></figure>
<p>IE的BUG:IE 的 JavaScript 实现在处理向 substr() 方法传递负值的情况时存在问题，<br>它会返回原始的字符串。IE9 修复了这个问题。</p>
<h3 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h3><p>indexOf() 和 lastIndexOf()。<br>都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回 -1 ）。<br>可选的第二个参数，表示从字符串中的哪个位置开始搜索。<br>循环调用 indexOf() 或 lastIndexOf() 来找到所有匹配的子字符串例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"Lorem ipsum dolor sit amet, consectetur adipisicing elit"</span>;</div><div class="line"><span class="keyword">var</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> pos = stringValue.indexOf(<span class="string">"e"</span>);</div><div class="line"><span class="keyword">while</span>(pos &gt; <span class="number">-1</span>)&#123;</div><div class="line">positions.push(pos);</div><div class="line">pos = stringValue.indexOf(<span class="string">"e"</span>, pos + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">alert(positions); <span class="comment">//"3,24,32,35,52"</span></div></pre></td></tr></table></figure>
<h3 id="trim-方法-（ECMAScript-5）"><a href="#trim-方法-（ECMAScript-5）" class="headerlink" title="trim()方法 （ECMAScript 5）"></a>trim()方法 （ECMAScript 5）</h3><p>这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。<br>支持这个方法的浏览器有 IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和 Chrome。<br>此外，Firefox 3.5+、Safari 5+和 Chrome 8+还支持非标准的 trimLeft() 和 trimRight() 方法，<br>分别用于删除字符串开头和末尾的空格。</p>
<h3 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h3><p>toLowerCase() 、 toLocaleLowerCase() 、 toUpperCase() 和 toLocaleUpperCase()<br>一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。</p>
<h3 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h3><h4 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h4><p>在字符串上调用这个方法，本质上与调用 RegExp 的 exec() 方法相同。<br>只接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象。</p>
<h4 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h4><p>这个方法的唯一参数与 match() 方法的参数相同。<br>search() 方法返回字符串中第一个匹配项的索引；<br>如果没有找到匹配项，则返回 -1 。<br>而且， search() 方法始终是从字符串开头向后查找模式。</p>
<h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace() 方法"></a>replace() 方法</h4><p>这个方法接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），<br>第二个参数可以是一个字符串或者一个函数。<br>如果第一个参数是字符串，那么只会替换第一个子字符串。<br>要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（ g ）标志。</p>
<pre><code>字符序列    替换文本
$$          $
$&amp;          匹配整个模式的子字符串。与 RegExp.lastMatch 的值相同
$&apos;          匹配的子字符串之前的子字符串。与 RegExp.leftContext 的值相同
$`          匹配的子字符串之后的子字符串。与 RegExp.rightContext 的值相同
$n          匹配第n个捕获组的子字符串，其中n等于0～9。例如， $1 是匹配第一个捕获组的子字符串，$2 是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串
$nn         匹配第nn个捕获组的子字符串，其中nn等于01～99。例如， $01 是匹配第一个捕获组的子字符串， $02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串
</code></pre><p>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</div><div class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($1)"</span>);</div><div class="line">alert(result); <span class="comment">//word (cat), word (bat), word (sat), word (fat)</span></div></pre></td></tr></table></figure>
<p>replace() 方法的第二个参数也可以是一个函数。<br>只有一个匹配项（即与模式匹配的字符串）的情况下，<br>会向这个函数传递 3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。</p>
<p>在正则表达式中定义了多个捕获组的情况下，<br>传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，<br>但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。<br>这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace() 方法的第二个参数可以实现更加精细的替换操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>)</span>&#123;</div><div class="line"><span class="keyword">switch</span>(match)&#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"&lt;"</span>:</div><div class="line"><span class="keyword">return</span> <span class="string">"&amp;lt;"</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">"&gt;"</span>:</div><div class="line"><span class="keyword">return</span> <span class="string">"&amp;gt;"</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">"&amp;"</span>:</div><div class="line"><span class="keyword">return</span> <span class="string">"&amp;amp;"</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">"\""</span>:</div><div class="line"><span class="keyword">return</span> <span class="string">"&amp;quot;"</span>;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">alert(htmlEscape(<span class="string">"&lt;p class=\"greeting\"&gt;Hello world!&lt;/p&gt;"</span>));</div><div class="line"><span class="comment">//&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;</span></div></pre></td></tr></table></figure>
<h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><p>基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。<br>分隔符可以是字符串，也可以是一个 RegExp 对象（这个方法不会将字符串看成正则表达式）。<br>split() 方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>;</div><div class="line"><span class="keyword">var</span> colors1 = colorText.split(<span class="string">","</span>); <span class="comment">//["red", "blue", "green", "yellow"]</span></div><div class="line"><span class="keyword">var</span> colors2 = colorText.split(<span class="string">","</span>, <span class="number">2</span>); <span class="comment">//["red", "blue"]</span></div><div class="line"><span class="keyword">var</span> colors3 = colorText.split(<span class="regexp">/[^\,]+/</span>); <span class="comment">//["", ",", ",", ",", ""]</span></div></pre></td></tr></table></figure>
<p>在最后一次调用 split() 返回的数组中，第一项和最后一项是两个空字符串。<br>之所以会这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头（即子字符串 “red” ）和末尾（即子字符串 “yellow” ）。<br>对 split() 中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现匹配项以及带有捕获组的模式，匹配的行为就不大相同了。<br>以下是几种常见的差别。</p>
<p>IE8 及之前版本会忽略捕获组。ECMA-262 规定应该把捕获组拼接到结果数组中。IE9 能正确地在结果中包含捕获组。<br>Firefox 3.6 及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262 规定没有匹配项的捕获组在结果数组中应该用 undefined 表示。</p>
<p>参考：要了解关于 split() 方法以及捕获组的跨浏览器问题的更多讨论，请参考 StevenLevithan 的文章<br>“JavaScript split bugs：Fixed!”（<a href="http://blog.stevenlevithan.com/archives/cross-browser-split/" target="_blank" rel="external">http://blog.stevenlevithan.com/archives/cross-browser-split/</a>）。</p>
<h3 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a>localeCompare() 方法</h3><p>这个方法比较两个字符串，并返回下列值中的一个:</p>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是 -1 ，具体的值要视实现而定）；</li>
<li>如果字符串等于字符串参数，则返回 0 ；</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1 ，具体的值同样要视实现而定）。</li>
</ul>
<p>因为 localeCompare() 返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineOrder</span>(<span class="params">value</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> result = stringValue.localeCompare(value);</div><div class="line"><span class="keyword">if</span> (result &lt; <span class="number">0</span>)&#123;</div><div class="line">alert(<span class="string">"The string 'yellow' comes before the string '"</span> + value + <span class="string">"'."</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</div><div class="line">alert(<span class="string">"The string 'yellow' comes after the string '"</span> + value + <span class="string">"'."</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    alert(<span class="string">"The string 'yellow' is equal to the string '"</span> + value + <span class="string">"'."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">determineOrder(<span class="string">"brick"</span>);</div><div class="line">determineOrder(<span class="string">"yellow"</span>);</div><div class="line">determineOrder(<span class="string">"zoo"</span>);</div></pre></td></tr></table></figure>
<p>localeCompare() 方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个方法的行为。<br>比如，美国以英语作为 ECMAScript 实现的标准语言，因此 localeCompare() 就是区分大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。<br>不过，在其他地区恐怕就不是这种情况了。</p>
<h3 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode() 方法"></a>fromCharCode() 方法</h3><p>静态方法,任务是接收一或多个字符编码，然后将它们转换成一个字符串。<br>从本质上来看，这个方法与实例方法 charCodeAt()执行的是相反的操作。<br><code>alert(String.fromCharCode(104, 101, 108, 108, 111)); //&quot;hello&quot;</code></p>
<h3 id="HTML-方法"><a href="#HTML-方法" class="headerlink" title="HTML 方法"></a>HTML 方法</h3><p>应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。</p>
<pre><code>方 法     输出结果
anchor(name)        &lt;a name= &quot;name&quot;&gt;string&lt;/a&gt;
big()               &lt;big&gt;string&lt;/big&gt;
bold()              &lt;b&gt;string&lt;/b&gt;
fixed()             &lt;tt&gt;string&lt;/tt&gt;
fontcolor(color)    &lt;font color=&quot;color&quot;&gt;string&lt;/font&gt;
fontsize(size)      &lt;font size=&quot;size&quot;&gt;string&lt;/font&gt;
italics()           &lt;i&gt;string&lt;/i&gt;
link(url)           &lt;a href=&quot;url&quot;&gt;string&lt;/a&gt;
small()             &lt;small&gt;string&lt;/small&gt;
strike()            &lt;strike&gt;string&lt;/strike&gt;
sub()               &lt;sub&gt;string&lt;/sub&gt;
sup()               &lt;sup&gt;string&lt;/sup&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第五章-3]]></title>
      <url>https://codingme.xyz/2016/09/19/javascript-note-5-3/</url>
      <content type="html"><![CDATA[<h1 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h1><p>ECMAScript 中最有意思的是函数——因为函数实际上是对象。<br>JavaScript 最有特色的地方。<br>每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。<br>由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*等同于*/</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>); <span class="comment">// 不推荐</span></div></pre></td></tr></table></figure>
<p>在使用函数表达式定义函数时，没有必要使用函数名——通过变量 sum 即可以引用函数。<br>另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。<br>最后一种定义函数的方式是使用 Function 构造函数。<br>但是不推荐这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规 ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。</p>
<p>使用不带圆括号的函数名是访问函数指针，而非调用函数。<br><a id="more"></a></p>
<h2 id="没有重载（深入理解）"><a href="#没有重载（深入理解）" class="headerlink" title="没有重载（深入理解）"></a>没有重载（深入理解）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> num + <span class="number">100</span>;</div><div class="line">&#125;;</div><div class="line">addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> num + <span class="number">200</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></div></pre></td></tr></table></figure>
<p>在创建第二个函数时，实际上覆盖了引用第一个函数的变量 addSomeNumber 。</p>
<h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><p>实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。<br>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；<br>至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码完全可以正常运行。<br>因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，<br>读取并将函数声明添加到执行环境中。<br>对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。<br>下面的例子则会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>原因在于函数位于一个初始化语句中，而不是一个函数声明。<br>换句话说，在执行到函数所在的语句之前，变量 sum 中不会保存有对函数的引用；<br>而且，由于第一行代码就会导致“unexpected identifier”（意外标识符）错误，实际上也不会执行到下一行。</p>
<p>除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。</p>
<p>Safari 中同时使用函数声明和函数表达式会导致错误。</p>
<h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> someFunction(someArgument);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> num + <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result1 = callSomeFunction(add10, <span class="number">10</span>);</div><div class="line">alert(result1); <span class="comment">//20</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result2 = callSomeFunction(getGreeting, <span class="string">"Nicholas"</span>);</div><div class="line">alert(result2); <span class="comment">//"Hello, Nicholas"</span></div></pre></td></tr></table></figure>
<p>要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。</p>
<p>例子2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line"><span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line"><span class="keyword">if</span> (value1 &lt; value2)&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = [&#123;name: <span class="string">"Zachary"</span>, age: <span class="number">28</span>&#125;, &#123;name: <span class="string">"Nicholas"</span>, age: <span class="number">29</span>&#125;];</div><div class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));</div><div class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Nicholas</span></div><div class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</div><div class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Zachary</span></div></pre></td></tr></table></figure>
<h2 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h2><p>arguments 和 this。</p>
<h3 id="arguments-的-callee"><a href="#arguments-的-callee" class="headerlink" title="arguments 的 callee"></a>arguments 的 callee</h3><p>arguments 的 callee 的属性是一个指针，指向拥有这个 arguments 对象的函数。<br>当函数在严格模式下运行时，访问 arguments.callee 会导致错误。<br>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*阶乘函数。问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">使用arguments.callee消除这种紧密耦合的现象。</div><div class="line">这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">变量 trueFactorial 获得了 factorial 的值，实际上是在另一个位置上保存了一个函数的指针。</div><div class="line">又将一个简单地返回 0 的函数赋值给 factorial 变量。</div><div class="line">在解除了函数体内的代码与函数名的耦合状态之后， trueFactorial() 仍然能够正常地计算阶乘。</div><div class="line">*/</div><div class="line"><span class="keyword">var</span> trueFactorial = factorial;</div><div class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line">alert(trueFactorial(<span class="number">5</span>)); <span class="comment">//120</span></div><div class="line">alert(factorial(<span class="number">5</span>)); <span class="comment">//0</span></div></pre></td></tr></table></figure>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this引用的是函数据以执行的环境对象。<br>（当在网页的全局作用域中调用函数时，this 对象引用的就是 window ）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; color: <span class="string">"blue"</span> &#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor(); <span class="comment">//"red"</span></div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor(); <span class="comment">//"blue"</span></div></pre></td></tr></table></figure>
<p>要点：<strong>函数的名字仅仅是一个包含指针的变量而已。</strong></p>
<h3 id="caller-ECMAScript5"><a href="#caller-ECMAScript5" class="headerlink" title="caller(ECMAScript5)"></a>caller(ECMAScript5)</h3><p>ECMAScript 5 也规范化了另一个函数对象的属性： caller 。ECMAScript 3 并没有定义。<br>这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null 。<br>ECMAScript 5 还定义了arguments.caller 属性，但在严格模式下访问它也会导致错误，<br>而在非严格模式下这个属性始终是undefined 。定义这个属性是为了分清 arguments.caller 和函数的 caller 属性。<br>以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。<br>严格模式还有一个限制：不能为函数的 caller 属性赋值，否则会导致错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">inner();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(inner.caller);</div><div class="line">&#125;</div><div class="line">outer();</div><div class="line"><span class="comment">/*</span></div><div class="line">以上代码会导致警告框中显示 outer() 函数的源代码。</div><div class="line">因为 outer() 调用了 inter() ，所以inner.caller 就指向 outer() 。</div><div class="line">为了实现更松散的耦合，也可以通过 arguments.callee.caller来访问相同的信息。</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">inner();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="built_in">arguments</span>.callee.caller);</div><div class="line">&#125;</div><div class="line">outer();</div></pre></td></tr></table></figure>
<h2 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h2><p>每个函数都包含两个属性： length 和 prototype 。<br>每个函数都包含两个非继承而来的方法： apply() 和 call() 。<br>这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</p>
<h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>length 属性表示函数希望接收的命名参数的个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">alert(name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="string">"hi"</span>);</div><div class="line">&#125;</div><div class="line">alert(sayName.length); <span class="comment">//1</span></div><div class="line">alert(sum.length); <span class="comment">//2</span></div><div class="line">alert(sayHi.length); <span class="comment">//0</span></div></pre></td></tr></table></figure>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味。<br>对于ECMAScript 中的引用类型而言， prototype 是保存它们所有实例方法的真正所在。<br>换句话说，诸如toString() 和 valueOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。<br>在创建自定义引用类型以及实现继承时， prototype 属性的作用是极为重要的。<br>在 ECMAScript 5 中， prototype 属性是不可枚举的，因此使用 for-in 无法发现。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>apply() 方法接收两个参数：一个是<strong>在其中运行函数的作用域</strong>，另一个是<strong>参数数组</strong>。<br>其中，第二个参数可以是 Array 的实例，也可以是arguments 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入 arguments 对象</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></div><div class="line">&#125;</div><div class="line">alert(callSum1(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div><div class="line">alert(callSum2(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div><div class="line"><span class="comment">/*</span></div><div class="line">callSum1() 在执行 sum() 函数时传入了 this 作为 this 值</div><div class="line">（因为是在全局作用域中调用的，所以传入的就是 window 对象）</div><div class="line">和 arguments 对象。</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>在严格模式下，未指定环境对象而调用函数，则 this 值不会转型为 window 。<br>除非明确把函数添加到某个对象或者调用 apply() 或 call() ，否则 this 值将是undefined 。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p>call() 方法与 apply() 方法的作用相同，它们的区别仅在于接收参数的方式不同。<br>对于 call()方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。<br>换句话说，在使用call() 方法时，传递给函数的参数必须逐个列举出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</div><div class="line">&#125;</div><div class="line">alert(callSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div></pre></td></tr></table></figure>
<h3 id="apply-与-call-的取舍"><a href="#apply-与-call-的取舍" class="headerlink" title="apply() 与 call() 的取舍"></a>apply() 与 call() 的取舍</h3><p>取决于你采取哪种给函数传递参数的方式最方便。<br>如果你打算直接传入 arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用 apply()肯定更方便；<br>否则，选择 call() 可能更合适。<br>（在不给函数传递参数的情况下，使用哪个方法都无所谓。）</p>
<h3 id="apply-与-call-的用武之地"><a href="#apply-与-call-的用武之地" class="headerlink" title="apply() 与 call() 的用武之地"></a>apply() 与 call() 的用武之地</h3><p>它们真正强大的地方是能够扩充函数赖以运行的作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; color: <span class="string">"blue"</span> &#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor(); <span class="comment">//red</span></div><div class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">//red</span></div><div class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></div><div class="line">sayColor.call(o); <span class="comment">//blue</span></div></pre></td></tr></table></figure>
<p>sayColor() 也是作为全局函数定义的,<br>当在全局作用域中调用它时，会显示 “red”。<br>因为对 this.color 的求值会转换成对 window.color 的求值。<br>而 sayColor.call(this) 和 sayColor.call(window) ，<br>则是两种<strong>显式地</strong>在全局作用域中调用函数的方式。<br>当运行 sayColor.call(o)时，函数的执行环境就不一样了，<br>因为此时函数体内的 this 对象指向了 o ，于是结果显示的是 “blue”。</p>
<p>使用 call() （或 apply() ）来扩充作用域的最大好处，就是<strong>对象不需要与方法有任何耦合关系</strong>。</p>
<h3 id="bind-ECMAScript5"><a href="#bind-ECMAScript5" class="headerlink" title="bind() (ECMAScript5)"></a>bind() (ECMAScript5)</h3><p>这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; color: <span class="string">"blue"</span> &#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</div><div class="line">objectSayColor(); <span class="comment">//blue</span></div></pre></td></tr></table></figure>
<p>sayColor() 调用 bind() 并传入对象 o ，创建了 objectSayColor() 函数。<br>objectSayColor() 函数的 this 值等于 o。<br>优点请参考第 22 章。</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>每个函数继承的 toLocaleString() 和 toString() 方法始终都返回函数的代码。<br>返回代码的格式则因浏览器而异。<br>另外一个继承的valueOf() 方法同样也只返回函数代码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第五章-2]]></title>
      <url>https://codingme.xyz/2016/09/19/javascript-note-5-2/</url>
      <content type="html"><![CDATA[<h1 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h1><p>创建一个Date对象，使用 new 操作符和 Date 构造函数即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div></pre></td></tr></table></figure>
<p>在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。<br>如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数。（从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数）<br>了简化这一计算过程，ECMAScript 提供了两个方法： Date.parse()和 Date.UTC() 。<br><a id="more"></a></p>
<ul>
<li>Date.parse() 方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。<br>  ECMA-262 没有定义 Date.parse() 应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。<br>  如果传入 Date.parse() 方法的字符串不能表示日期，那么它会返回 NaN 。<br>  要点：日期对象及其在不同浏览器中的实现有许多奇怪的行为。<br>  在解析 “January 32, 2007”时，有的浏览器会将其解释为 “February 1, 2007” 。<br>  而 Opera 则倾向于插入当前月份的当前日期，返回 “January 当前日期， 2007” 。<br>  如果在 2007 年 9 月21 日运行前面的代码，将会得到 “January 21, 2007” （都是 21 日）。<ul>
<li>“月/日/年”，如 6/13/2004；</li>
<li>“英文月名 日,年”，如 January 12,2004；</li>
<li>“英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700。</li>
<li>ISO 8601 扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ（例如 2004-05-25T00:00:00）。只有兼容ECMAScript 5的实现支持这种格式。<br>实际上，如果直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 Date.parse() 。<br><code>var someDate = new Date(&quot;May 25, 2004&quot;);</code>等同于<code>var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;));</code></li>
</ul>
</li>
<li><p>Date.UTC() 方法同样也返回表示日期的毫秒数。<br>  Date.UTC() 的参数分别是年份、基于 0 的月份（一月是 0，二月是 1，以此类推）、月中的哪一天（1 到 31）、小时数（0 到 23）、分钟、秒以及毫秒数。<br>  在这些参数中，只有前两个参数（年和月）是必需的。<br>  如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GMT 时间 2000 年 1 月 1 日午夜零时</span></div><div class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>));</div><div class="line"><span class="comment">// GMT 时间 2005 年 5 月 5 日下午 5:55:55</span></div><div class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</div></pre></td></tr></table></figure>
<p>  如同模仿 Date.parse() 一样， Date 构造函数也会模仿 Date.UTC() ，但有一点明显不同：日期和时间都基于本地时区而非 GMT 来创建。<br>  <code>var allFives = new Date(2005, 4, 5, 17, 55, 55);</code>等同于<code>var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));</code></p>
</li>
<li><p>Data.now() 方法，ECMAScript 5 添加,返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用 Data 对象分析代码的工作。例如：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得开始时间</span></div><div class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</div><div class="line"><span class="comment">//调用函数</span></div><div class="line">doSomething();</div><div class="line"><span class="comment">//取得停止时间</span></div><div class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now(),</div><div class="line">result = stop – start;</div></pre></td></tr></table></figure>
<p>  在不支持它的浏览器中，使用+操作符把 Data 对象转换成字符串，也可以达到同样的目的。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得开始时间</span></div><div class="line"><span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="comment">//调用函数</span></div><div class="line">doSomething();</div><div class="line"><span class="comment">//取得停止时间</span></div><div class="line"><span class="keyword">var</span> stop = +<span class="keyword">new</span> <span class="built_in">Date</span>(),</div><div class="line">result = stop - start;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>Date 类型也重写了 toLocaleString() 、 toString() 和 valueOf() 方法。<br>在不同浏览器中调用toLocaleString() 和 toString() 方法，返回的日期和时间格式可谓大相径庭。<br>事实上，toLocaleString() 和 toString() 的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。<br>Date 类型的 valueOf() 方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符（小于或大于）来比较日期值。</p>
<h2 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h2><ul>
<li>toDateString() ——以特定于实现的格式显示星期几、月、日和年；</li>
<li>toTimeString() ——以特定于实现的格式显示时、分、秒和时区；</li>
<li>toLocaleDateString() ——以特定于地区的格式显示星期几、月、日和年；</li>
<li>toLocaleTimeString() ——以特定于实现的格式显示时、分、秒；</li>
<li>toUTCString() ——以特定于实现的格式完整的 UTC 日期。</li>
</ul>
<p>与 toLocaleString() 和 toString() 方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。<br>还有一个名叫 toGMTString() 的方法，这是一个与toUTCString() 等价的方法，其存在目的在于确保向后兼容。<br>不过，ECMAScript 推荐现在编写的代码一律使用 toUTCString() 方法。</p>
<h2 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h2><ul>
<li>getTime()：    返回表示日期的毫秒数；与 valueOf() 方法返回的值相同</li>
<li>setTime( 毫秒 ) ：   以毫秒数设置日期，会改变整个日期</li>
<li>getFullYear()：    取得4位数的年份（如2007而非仅07）</li>
<li>getUTCFullYear()： 返回UTC日期的4位数年份</li>
<li>setFullYear( 年 )：  设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）</li>
<li>setUTCFullYear( 年 )：  设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）</li>
<li>getMonth()：   返回日期中的月份，其中0表示一月，11表示十二月</li>
<li>getUTCMonth()：    返回UTC日期中的月份，其中0表示一月，11表示十二月</li>
<li>setMonth( 月 )：  设置日期的月份。传入的月份值必须大于0，超过11则增加年份</li>
<li>setUTCMonth( 月 )：  设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份</li>
<li>getDate()：    返回日期月份中的天数（1到31）</li>
<li>getUTCDate()： 返回UTC日期月份中的天数（1到31）</li>
<li>setDate( 日 )：  设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份</li>
<li>setUTCDate( 日 )：  设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份</li>
<li>getDay()： 返回日期中星期的星期几（其中0表示星期日，6表示星期六）</li>
<li>getUTCDay()：  返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六）</li>
<li>getHours()：   返回日期中的小时数（0到23）</li>
<li>getUTCHours()：    返回UTC日期中的小时数（0到23）</li>
<li>setHours( 时 )：  设置日期中的小时数。传入的值超过了23则增加月份中的天数</li>
<li>setUTCHours( 时 )：  设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数</li>
<li>getMinutes()： 返回日期中的分钟数（0到59）</li>
<li>getUTCMinutes()：  返回UTC日期中的分钟数（0到59）</li>
<li>setMinutes( 分 )：  设置日期中的分钟数。传入的值超过59则增加小时数</li>
<li>setUTCMinutes( 分 )：  设置UTC日期中的分钟数。传入的值超过59则增加小时数</li>
<li>getSeconds()： 返回日期中的秒数（0到59）</li>
<li>getUTCSeconds()：  返回UTC日期中的秒数（0到59）</li>
<li>setSeconds( 秒 )：  设置日期中的秒数。传入的值超过了59会增加分钟数</li>
<li>setUTCSeconds( 秒 )：  设置UTC日期中的秒数。传入的值超过了59会增加分钟数</li>
<li>getMilliseconds()：    返回日期中的毫秒数</li>
<li>getUTCMilliseconds()： 返回UTC日期中的毫秒数</li>
<li>setMilliseconds( 毫秒 )  设置日期中的毫秒数</li>
</ul>
<h1 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h1><p>ECMAScript 通过 RegExp 类型来支持正则表达式。<br><code>var expression = / pattern / flags ;</code></p>
<h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><p>g ：表示全局（global）模式，<br>i ：表示不区分大小写（case-insensitive）模式，<br>m ：表示多行（multiline）模式。即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( [ &#123; \ ^ $ | ) ? * + .]&#125;</div></pre></td></tr></table></figure>
<p>如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。</p>
<h2 id="定义正则表达式的方式："><a href="#定义正则表达式的方式：" class="headerlink" title="定义正则表达式的方式："></a>定义正则表达式的方式：</h2><p>字面量形式定义正则表达式：<br><code>var pattern1 = /[bc]at/i;</code></p>
<p>构造函数定义正则表达式：<br><code>var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</code><br>传递给 RegExp 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给 RegExp 构造函数）。<br>所以在某些情况下要对字符进行双重转义。<br>    字面量模式           等价的字符串<br>    /[bc]at/          “\[bc\]at”<br>    /.at/              “\.at”<br>    /name\/age/         “name\/age”<br>    /\d.\d{1,2}/        “\d.\d{1,2}”<br>    /\w\hello\123/    “\w\\hello\\123”</p>
<h2 id="ECMAScript-3的正则表达式字面量共享实例问题"><a href="#ECMAScript-3的正则表达式字面量共享实例问题" class="headerlink" title="ECMAScript 3的正则表达式字面量共享实例问题"></a>ECMAScript 3的正则表达式字面量共享实例问题</h2><p>在 ECMAScript 3 中，正则表达式字面量始终会共享同一个 RegExp 实例。<br>而使用构造函数创建的每一个新 RegExp 实例都是一个新实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="literal">null</span>,</div><div class="line">i;</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">re = <span class="regexp">/cat/g</span>;</div><div class="line">re.test(<span class="string">"catastrophe"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"cat"</span>, <span class="string">"g"</span>);</div><div class="line">re.test(<span class="string">"catastrophe"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在第一个循环中，即使是循环体中指定的，但实际上只为 /cat/ 创建了一个 RegExp 实例。<br>由于实例属性不会重置，所以在循环中再次调用 test() 方法会失败。<br>第一次调用 test() 找到了 “cat” ，但第二次调用是从索引为 3 的字符（上一次匹配的末尾）开始的，所以就找不到它了。<br>由于会测试到字符串末尾，所以下一次再调用 test() 就又从开头开始了。<br>所以第一个循环应该是：成功、失败失败失败，又从头开始的时候成功，失败失败…..</p>
<p>第二个循环使用 RegExp 构造函数在每次循环中创建正则表达式。<br>因为每次迭代都会创建一个新的RegExp 实例，所以每次调用 test() 都会返回 true 。</p>
<p>ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用 RegExp 构造函数一样，每次都创建新的 RegExp 实例。<br>IE9+、Firefox 4+和 Chrome 都据此做出了修改。</p>
<h2 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h2><ul>
<li>global ：布尔值，表示是否设置了 g 标志。</li>
<li>ignoreCase ：布尔值，表示是否设置了 i 标志。</li>
<li>lastIndex ：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。</li>
<li>multiline ：布尔值，表示是否设置了 m 标志。</li>
<li>source ：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
</ul>
<p>通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。</p>
<h2 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>RegExp 对象的主要方法是 exec() ，该方法是专门为<strong>捕获组</strong>而设计的。<br>接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null 。<br>返回的数组虽然是 Array 的实例，但包含两个额外的属性： index 和 input 。<br>index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</div><div class="line"><span class="keyword">var</span> matches = pattern.exec(text);</div><div class="line">alert(matches.index); <span class="comment">// 0</span></div><div class="line">alert(matches.input); <span class="comment">// "mom and dad and baby"</span></div><div class="line">alert(matches[<span class="number">0</span>]); <span class="comment">// "mom and dad and baby"</span></div><div class="line">alert(matches[<span class="number">1</span>]); <span class="comment">// " and dad and baby"</span></div><div class="line">alert(matches[<span class="number">2</span>]); <span class="comment">// " and baby"</span></div></pre></td></tr></table></figure>
<p>这个例子中的模式包含两个捕获组。<br>最内部的捕获组匹配 “and baby” ，<br>而包含它的捕获组匹配 “and dad” 或者 “and dad and baby” 。<br>数组中的第一项是匹配的整个字符串，<br>第二项包含与第一个捕获组匹配的内容，<br>第三项包含与第二个捕获组匹配的内容。</p>
<p>对于 exec() 方法而言，即使在模式中设置了全局标志（ g ），它每次也只会返回一个匹配项。<br>在不设置全局标志的情况下，在同一个字符串上多次调用 exec() 将始终返回第一个匹配项的信息。<br>而在设置全局标志的情况下，每次调用 exec() 则都会在字符串中继续查找新匹配项。</p>
<p>IE:IE 的 JavaScript 实现在 lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex 属性每次也会变化。</p>
<h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><p>正则表达式的第二个方法是 test() ，它接受一个字符串参数。<br>在模式与该参数匹配的情况下返回true ；否则，返回 false 。<br>在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。<br>因此， test() 方法经常被用在 if 语句中。</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>RegExp 实例继承的 toLocaleString() 和 toString() 方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。<br>正则表达式的 valueOf() 方法返回正则表达式本身。</p>
<h2 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h2><p>Opera 不支持短属性名.</p>
<pre><code>input  $_
最近一次要匹配的字符串。Opera未实现此属性
lastMatch  $&amp;
最近一次的匹配项。Opera未实现此属性
lastParen  $+
最近一次匹配的捕获组。Opera未实现此属性
leftContext  $`
input字符串中lastMatch之前的文本
multiline  $*
布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性
rightContext  $&apos;
Input字符串中lastMatch之后的文本
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">* 注意：Opera 不支持 input、lastMatch、lastParen 和 multiline 属性</div><div class="line">* Internet Explorer 不支持 multiline 属性</div><div class="line">*/</div><div class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</div><div class="line">alert(<span class="built_in">RegExp</span>.input); <span class="comment">// this has been a short summer</span></div><div class="line">alert(<span class="built_in">RegExp</span>.leftContext); <span class="comment">// this has been a</span></div><div class="line">alert(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// summer</span></div><div class="line">alert(<span class="built_in">RegExp</span>.lastMatch); <span class="comment">// short</span></div><div class="line">alert(<span class="built_in">RegExp</span>.lastParen); <span class="comment">// s</span></div><div class="line">alert(<span class="built_in">RegExp</span>.multiline); <span class="comment">// false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用短属性名的话：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">* 注意：Opera 不支持 input、lastMatch、lastParen 和 multiline 属性</div><div class="line">* Internet Explorer 不支持 multiline 属性</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</div><div class="line">alert(<span class="built_in">RegExp</span>.$_); <span class="comment">// this has been a short summer</span></div><div class="line">alert(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]); <span class="comment">// this has been a</span></div><div class="line">alert(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]); <span class="comment">// summer</span></div><div class="line">alert(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]); <span class="comment">// short</span></div><div class="line">alert(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]); <span class="comment">// s</span></div><div class="line">alert(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]); <span class="comment">// false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。访问这些属性的语法是 RegExp.$1 、 RegExp.$2 … RegExp.$9 ，分别用于存储第一、第二……第九个匹配的捕获组。</p>
<h2 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h2><p>尽管 ECMAScript 中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是 Perl）所支持的高级正则表达式特性。<br>比如：<br>匹配字符串开始和结尾的 \A 和 \Z 锚（但是支持以插入符号（^）和美元符号（$）来匹配字符串的开始和结尾。)<br>向后查找（lookbehind）(但完全支持向前查找（lookahead）)<br>并集和交集类<br>原子组（atomic grouping）<br>Unicode 支持（单个字符除外，如 \uFFFF ）<br>命名的捕获组( 但支持编号的捕获组)<br>s （single，单行）和 x （free-spacing，无间隔）匹配模式<br>条件匹配<br>正则表达式注释</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第五章-1]]></title>
      <url>https://codingme.xyz/2016/09/17/javascript-note-5-1/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 ECMAScript 中，<strong>引用类型</strong>是一种数据结构，用于将数据和功能组织在一起。<br>它也常被称为<strong>类</strong>，但这种称呼并不妥当。<br>ECMAScript不具备传统的面向对象语言所支持的<strong>类和接口</strong>等基本结构。<br>引用类型有时候也被称为<strong>对象定义</strong>，因为它们描述的是一类<strong>对象所具有的属性和方法</strong>。</p>
<p>虽然引用类型与类看起来相似，但它们并不是相同的概念。<br><strong>对象(Object)是某个特定引用类型的实例。</strong><br>新对象是使用 new 操作符后跟一个构造函数来创建的。</p>
<h1 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h1><p>Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为。</p>
<h2 id="创建-Object-实例的方式"><a href="#创建-Object-实例的方式" class="headerlink" title="创建 Object 实例的方式"></a>创建 Object 实例的方式</h2><ol>
<li>使用 new 操作符后跟 Object 构造函数:<code>var person = new Object();</code></li>
<li><p>使用对象字面量表示法：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line"><span class="string">"name"</span> : <span class="string">"Nicholas"</span>,</div><div class="line"><span class="string">"age"</span> : <span class="number">29</span>,</div><div class="line"><span class="number">5</span> : <span class="literal">true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> 左边的花括号（ { ）表示对象字面量的开始，如果是在 if 语句的后面，则表示一个语句块的开始。<br> 在使用对象字面量语法时，属性名也可以使用字符串。5会自动转化为字符串。<br> 使用字面量表示法不会调用Object构造函数。<br> 使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象。<code>var person = {}; //与 new Object()相同</code><br> 关于对象字面量语法，我们推荐只在考虑对象属性名的可读性时使用。<br> 因为这种语法要求的代码量少，而且能够给人封装数据的感觉，开发人员更青睐对象字面量语法。<br> 对象字面量也是向函数传递大量可选参数的首选方式。<br> 在函数中的使用：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">displayInfo(&#123;</div><div class="line">name: <span class="string">"Nicholas"</span>,</div><div class="line">age: <span class="number">29</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。</p>
</li>
</ol>
<a id="more"></a>
<h2 id="访问对象属性的方法"><a href="#访问对象属性的方法" class="headerlink" title="访问对象属性的方法"></a>访问对象属性的方法</h2><ol>
<li>点表示法</li>
<li><p>方括号表示法（JavaScript中)<br> 在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中。<br> 主要优点是可以通过变量来访问属性。例如：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</div><div class="line">alert(person[propertyName]); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p> 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。比如带空格的属性”first name”。<br> 通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。</p>
</li>
</ol>
<h1 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h1><ol>
<li>都是有序列表。</li>
<li>每一项可以保存任何类型的数据。</li>
<li>数组的大小是可以动态调整的。</li>
</ol>
<h2 id="创建数组的基本方式"><a href="#创建数组的基本方式" class="headerlink" title="创建数组的基本方式"></a>创建数组的基本方式</h2><ol>
<li><p>第一种:使用 Array 构造函数。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</div></pre></td></tr></table></figure>
<p> 在使用 Array 构造函数时也可以省略 new 操作符。</p>
</li>
<li><p>第二种:数组字面量表示法。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></div><div class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></div><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">// 不要这样！这样会创建一个包含 2 或 3 项的数组</span></div><div class="line"><span class="keyword">var</span> options = [,,,,,]; <span class="comment">// 不要这样！这样会创建一个包含 5 或 6 项的数组</span></div></pre></td></tr></table></figure>
<p> IE的BUG：在 IE 中， values 会成为一个包含 3 个项且每项的值分别为 1、2 和 undefined 的数组。<br> 原因是 IE8 及之前版本中的 ECMAScript 实现在数组字面量方面存在 bug。<br> 所以强烈建议不要使用<code>var values = [1,2,];</code>这种写法。<br> 在使用数组字面量表示法时，也不会调用 Array 构造函数。</p>
</li>
</ol>
<h2 id="读取和设置数组"><a href="#读取和设置数组" class="headerlink" title="读取和设置数组"></a>读取和设置数组</h2><p>使用方括号并提供相应值的基于 0 的数字索引。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 定义一个字符串数组</span></div><div class="line">alert(colors[<span class="number">0</span>]); <span class="comment">// 显示第一项</span></div><div class="line">colors[<span class="number">2</span>] = <span class="string">"black"</span>; <span class="comment">// 修改第三项</span></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"brown"</span>; <span class="comment">// 新增第四项</span></div></pre></td></tr></table></figure>
<h2 id="数组的-length"><a href="#数组的-length" class="headerlink" title="数组的 length"></a>数组的 length</h2><p>它不是只读的。因此，</p>
<ol>
<li>通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。<br> 往小了设置，可以移除最后几项；<br> 往大了设置，可以新增几项undefined。</li>
<li>利用 length 属性也可以方便地在数组末尾添加新项。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></div><div class="line">colors[colors.length] = <span class="string">"black"</span>; <span class="comment">// （在位置 3 ）添加一种颜色</span></div><div class="line">colors[colors.length] = <span class="string">"brown"</span>; <span class="comment">// （在位置 4</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>数组最多可以包含 4 294 967 295 个项,如果超过这个上限值，就会发生异常。<br>而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。</p>
<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>对于 ECMAScript3 来说，使用 instanceof 。<br>存在问题：<br>如果网页包含多个框架，那实际上存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。<br>解决方法：<br>ECMAScript5 新增了Array,isArray()方法。<br>支持 Array.isArray() 方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 10.5+和 Chrome。<br>要在尚未实现这个方法中的浏览器中准确检测数组，请参考 22 章节。</p>
<h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>所有对象都具有 toLocaleString() 、 toString() 和 valueOf() 方法。</p>
<ul>
<li>toString() ：返回由数组中每个值的字符串形式拼接而成的<strong>一个以逗号分隔的字符串</strong>。</li>
<li>valueOf() ：返回的还是数组。</li>
<li>toLocaleString()：也会创建一个数组值的以逗号分隔的字符串。为了取得每一项的值，调用的是每一项的 toLocale-String() 方法，而不是 toString() 方法。</li>
</ul>
<p>例子中使用了对象字面量表示法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = &#123;</div><div class="line">toLocaleString : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"Nikolaos"</span>;</div><div class="line">&#125;,</div><div class="line">toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"Nicholas"</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果数组中的某一项的值是 null 或者 undefined ，那么该值在 join() 、toLocaleString() 、 toString() 和 valueOf() 方法返回的结果中以空字符串表示。</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>如果使用join()方法，可以使用不同分隔符来构建字符串。<br>如果不给 join() 方法传入任何值，或者给它传入 undefined ，则使用逗号作为分隔符。<br>IE7 及更早版本会错误的使用字符串 “undefined” 作为分隔符。</p>
<h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>数组可以表现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。<br>ECMAScript 为数组专门提供了 push() 和 pop() 方法，以便实现类似栈的行为。</p>
<h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>栈数据结构的访问规则是 LIFO（后进先出），而队列数据结构的访问规则是 FIFO（First-In-First-Out，先进先出）。<br><strong>兼容性要点</strong>：IE7 及更早版本对 JavaScript 的实现中存在一个偏差，其 unshift() 方法总是返回 undefined 而不是数组的新长度。IE8 在非兼容模式下会返回正确的长度值。</p>
<h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p> reverse() 和 sort()</p>
<p><code>sort()</code>方法是根据测试字符串的结果改变原来的顺序，所以会造成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort();</div><div class="line">alert(values); <span class="comment">//0,1,10,15,5</span></div></pre></td></tr></table></figure>
<p>要解决这个问题，可以使用比较函数。<br>比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort(compare);</div><div class="line">alert(values); <span class="comment">//0,1,5,10,15</span></div></pre></td></tr></table></figure>
<p>对于数值类型或者其 valueOf() 方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可。</p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul>
<li>concat() 方法：<br>  基于当前数组中的所有项创建一个新数组。<br>  具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。<br>  没有给 concat() 方法传递参数的情况下，它只是复制当前数组并返回副本。<br>  如果传递给 concat() 方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。<br>  concat() 方法不会影响原始数组。</li>
<li>slice()方法：<br>  基于当前数组中的一或多个项创建一个新数组。<br>  slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。<br>  在只有一个参数的情况下， slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。<br>  slice() 方法不会影响原始数组。<br>  要点：如果 slice() 方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。<br>  在一个包含 5 项的数组上调用 slice(-2,-1) 与调用 slice(3,4) 得到的结果相同。如果结束位置小于起始位置，则返回空数组。</li>
<li>splice() 方法：<br>  恐怕要算是最强大的数组方法。<br>  splice() 方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。<br>  使用方式有3种：<ul>
<li><strong>删除</strong>：<br>可以删除任意数量的项。<br>只需指定 2 个参数：要删除的第一项的位置，要删除的项数。<br>例如， splice(0,2) 会删除数组中的前两项。</li>
<li><strong>插入</strong>：可以向指定位置插入任意数量的项。<br>只需提供 3 个参数：起始位置，0（要删除的项数），要插入的项。<br>如果要插入多个项，可以再传入第四、第五，以至任意多个项。</li>
<li><strong>替换</strong>：可以向指定位置插入任意数量的项，且同时删除任意数量的项。<br>只需指定 3 个参数：起始位置，要删除的项数，要插入的任意数量的项。<br>插入的项数不必与删除的项数相等。</li>
</ul>
</li>
</ul>
<h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p>ECMAScript 5 新增的两个位置方法。 indexOf() 和 lastIndexOf() 。<br>indexOf() 方法从数组的开头（位置 0）开始向后查找， lastIndexOf() 方法则从数组的末尾开始向前查找。<br>这两个方法在比较查找的项时，都使用全等操作符（===）</p>
<p>支持它们的浏览器包括 IE9+、Firefox 2+、Safari 3+、Opera 9.5+和 Chrome。<br>（也就是说，对于IE7、8来说，这两个位置方法不能用..）</p>
<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>ECMAScript 5 为数组定义了 5 个迭代方法。<br>支持这些迭代方法的浏览器有IE9+、Firefox 2+、Safari 3+、Opera 9.5+和 Chrome。<br>(一个问题：也就是说ECMAScript 3 不支持吧？跟前面的位置方法一样，如果要兼容IE7、8，就得考虑迭代方法的兼容问题)<br>每个方法都接收两个参数：要在每一项上运行的<strong>函数</strong>，（可选的）运行该函数的<strong>作用域对象</strong>——影响 <strong>this</strong> 的值。<br>传入这些方法中的函数会接收三个参数：数组项的值，该项在数组中的位置，数组对象本身。</p>
<ul>
<li>every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true 。<br>  使用示例：数组中每个值都大于2的话，则返回true。</li>
<li>filter() ：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。<br>  使用示例：返回 数组中所有大于2的值 的数组。</li>
<li>forEach() ：对数组中的每一项运行给定函数。这个方法没有返回值。<br>  使用示例：基本等同于 for 语句。</li>
<li>map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>  使用示例：返回 数组中所有值乘以2 的数组。</li>
<li>some() ：对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true 。<br>  使用示例：数组中有一个值大于2的话，返回true。</li>
</ul>
<p>以上方法都不会修改数组中的包含的值。<br>every()就像是 与，some()就像是 或。两者都返回布尔值。</p>
<h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p>ECMAScript 5 新增了两个归并数组的方法： reduce() 和 reduceRight() 。<br>支持这些归并方法的浏览器有IE9+、Firefox 2+、Safari 3+、Opera 9.5+和 Chrome。<br>(一个问题：又是说ECMAScript 3 不支持吧？跟前面的迭代方法一样，如果要兼容IE7、8，就得考虑归并方法的兼容问题)<br>reduce() 方法从数组的第一项开始，逐个遍历到最后。而 reduceRight() 则从数组的最后一项开始，向前遍历到第一项。<br>都接收两个参数：一个在每一项上调用的函数，（可选的）作为归并基础的初始值。<br>reduce() 和 reduceRight() 的函数接收 4 个参数：前一个值，当前值，项的索引，数组对象。<br>求和示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum); <span class="comment">//15</span></div></pre></td></tr></table></figure>
<p>reduceRight() 的作用类似，方向相反。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第四章]]></title>
      <url>https://codingme.xyz/2016/09/17/javascript-note-4/</url>
      <content type="html"><![CDATA[<h1 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h1><p>基本数据类型： Undefined 、 Null 、 Boolean 、 Number 和 String 。<br>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中。<br>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。</p>
<p>引用类型的值是保存在内存中的对象(Object)。<br>引用类型的值是对象，保存在堆内存中。<br>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。<br>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</p>
<p>JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。<br>在操作对象时，实际上是在操作对象的引用而不是实际的对象。<br>为此，引用类型的值是按引用访问的。(当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际<br>的对象。)</p>
<p>在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。<br>ECMAScript放弃了这一传统。</p>
<h2 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h2><p>对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。(Object)<br>只能给引用类型值动态地添加属性，以便将来使用。（给基本类型的添加了也是undefined)</p>
<a id="more"></a>
<h2 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h2><p>基本类型：如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。<br>引用类型：当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。</p>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript 中所有函数的参数都是按值传递的。<br>有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。</p>
<p>基本类型：在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。<br>引用类型：在向参数传递引用类型的值时，会把这个值在内存中的地址（引用/指针）复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部(引用类型的值会被修改）。</p>
<p>有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">obj.name = <span class="string">"Nicholas"</span>;</div><div class="line">obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">obj.name = <span class="string">"Greg"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值为 “Greg” 的新对象。<br>但是，当接下来再访问 person.name 时，显示的值仍然是 “Nicholas” 。<br>这说明即使在函数内部修改了参数的值，但<strong>原始的引用仍然保持未变</strong>。<br>实际上，当在函数内部重写 obj 时，这个变量引用的就是另一个对象，一个局部对象了。<br>而这个局部对象会在函数执行完毕后立即被销毁。<br>可以把 ECMAScript 函数的参数想象成局部变量。</p>
<h2 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h2><p>typeof:检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。<br>instanceof:如果变量是给定引用类型的实例，那么instanceof 操作符就会返回 true 。如果使用 instanceof 操作符检测基本类型的值，则该操作符始终会返回 false ，因为基本类型不是对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// 变量 person 是 Object 吗？</span></div><div class="line">alert(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// 变量 colors 是 Array 吗？</span></div><div class="line">alert(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// 变量 pattern 是 RegExp 吗？</span></div></pre></td></tr></table></figure>
<p>使用 typeof 操作符检测函数时，该操作符会返回 “function” 。<br>ECMA-262 规定任何在内部实现 [[Call]] 方法的对象都应该在应用 typeof 操作符时返回 “function” 。<br>(在 Safari 5 及之前版本和 Chrome 7 及之前版本中使用 typeof 检测正则表达式时，浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用 typeof 会返回 “function” )<br>(在IE 和 Firefox中，对正则表达式应用 typeof 会返回 “object”)</p>
<h1 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h1><h2 id="全局执行环境"><a href="#全局执行环境" class="headerlink" title="全局执行环境"></a>全局执行环境</h2><p><strong>全局执行环境</strong>是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）</p>
<h2 id="执行流"><a href="#执行流" class="headerlink" title="执行流"></a>执行流</h2><p>ECMAScript 程序中的<strong>执行流</strong>的控制机制：每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。<br>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链。</p>
<p>用途：是保证对执行环境有权访问的所有变量和函数的有序访问。</p>
<p>当前的变量对象——&gt;<br>活动对象作为变量对象（环境若是函数）——&gt;<br>活动对象最开始只包含 arguments 对象——&gt;<br>下一个变量对象来自包含（外部）环境——&gt;<br>再下一个来自下一个包含（外部）环境——&gt;<br>……<br>直到全局执行环境。</p>
<p>标识符（name)解析是沿着作用域链一级一级地搜索标识符的过程。（如果找不到标识符，通常会导致错误发生）</p>
<p>函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><ol>
<li>try-catch 语句的 catch 块；</li>
<li>with 语句。</li>
</ol>
<p>这两个语句都会在作用域链的前端添加一个变量对象。<br>对 with 语句来说，会将指定的对象添加到作用域链中。<br>对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</div><div class="line"><span class="keyword">with</span>(location)&#123;</div><div class="line"><span class="keyword">var</span> url = href + qs;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> url;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>url成了函数执行环境中的一部分，所以可以当作函数的值被返回。</p>
<p>旧浏览器的BUG:<br>在 IE8 及之前版本的 JavaScript 实现中，存在一个与标准不一致的地方，<br>即在catch 语句中捕获的错误对象会被添加到执行环境的变量对象，而不是 catch 语句的变量对象中。<br>换句话说，即使是在 catch 块的外部也可以访问到错误对象。<br>IE9 修复了这个问题。</p>
<h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line">&#125;</div><div class="line">alert(color); <span class="comment">//"blue"</span></div></pre></td></tr></table></figure>
<p>如果是在 C、C++或 Java中， color 会在 if 语句执行完毕后被销毁。<br>但在 JavaScript 中， if 语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。<br>在使用 for 语句时尤其要牢记这一差异。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">doSomething(i);</div><div class="line">&#125;</div><div class="line">alert(i); <span class="comment">//10</span></div></pre></td></tr></table></figure>
<p>对于有块级作用域的语言来说， for 语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。<br>而对于 JavaScript 来说，由 for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会存在于循环外部的执行环境中。</p>
<ol>
<li>声明变量：<br> 使用 var 声明的变量会自动被添加到最接近的环境中。<br> 在函数内部，最接近的环境就是函数的局部环境；<br> 在 with 语句中，最接近的环境是函数环境。<br> 如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。<br> 要点：<br> 在编写 JavaScript 代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。<br> 我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。<br> <strong>在严格模式下，初始化未经声明的变量会导致错误。</strong></li>
<li>查询标识符：<br> 如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。<br> 换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。<br> 变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。<br> JavaScript 引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。</li>
</ol>
<h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><p>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。<br>用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。</p>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>JavaScript 中最常用的垃圾收集方式（mark-and-sweep）。<br>当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。<br>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。<br>而当变量离开环境时，则将其标记为“离开环境”。<br>如何标记变量其实并不重要，关键在于采取什么策略。</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。——[mark all]<br>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。——[delete used]<br>在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。——[mark garbage]<br>最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。——[swap]</p>
<p>到 2008 年为止，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript 实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>另一种不太常见的垃圾收集策略。<br>含义是跟踪记录每个值被引用的次数。<br>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。<br>如果同一个值又被赋给另一个变量，则该值的引用次数加 1。<br>相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。<br>当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。<br>当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p>
<p>Netscape Navigator 3.0是最早使用引用计数策略的浏览器。</p>
<h3 id="严重问题：循环引用。"><a href="#严重问题：循环引用。" class="headerlink" title="严重问题：循环引用。"></a>严重问题：循环引用。</h3><p>所以Netscape 在 Navigator 4.0 中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。<br>可是引用计数导致的麻烦并未就此终结。</p>
<p>IE 中有一部分对象并不是原生 JavaScript 对象。<br>例如，其 BOM 和 DOM 中的对象就是使用 C++以 COM（Component Object Model，组件对象模型）对象的形式实现的，<br>而 COM 对象的垃圾收集机制采用的就是引用计数策略。<br>即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，<br>但JavaScript 访问的 COM 对象依然是基于引用计数策略的。<br>换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</div><div class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">myObject.element = element;</div><div class="line">element.someObject = myObject;</div></pre></td></tr></table></figure>
<p>这个例子在一个 DOM 元素（ element ）与一个原生 JavaScript 对象（ myObject ）之间创建了循环引用。<br>其中，变量 myObject 有一个名为 element 的属性指向 element 对象；<br>而变量 element 也有一个属性名叫 someObject 回指 myObject 。<br>由于存在这个循环引用，即使将例子中的 DOM 从页面中移除，它也永远不会被回收。</p>
<p>为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与DOM 元素之间的连接。<br>例如可以使用下面的代码消除前面例子创建的循环引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myObject.element = <span class="literal">null</span>;</div><div class="line">element.someObject = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。</p>
<p>在IE9时把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。</p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><h3 id="IE-声名狼藉的性能问题。"><a href="#IE-声名狼藉的性能问题。" class="headerlink" title="IE 声名狼藉的性能问题。"></a>IE 声名狼藉的性能问题。</h3><p>IE 的垃圾收集器是根据内存分配量运行的，<br>具体一点说就是 256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者 64KB 的字符串。<br>达到上述任何一个临界值，垃圾收集器就会运行。</p>
<p>问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。<br>而这样一来，垃圾收集器就不得不频繁地运行。</p>
<p>由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。<br>IE7触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。</p>
<p>临界值在初始时与 IE6 相等。<br>如果垃圾收集例程回收的内存分配量低于 15%，则临界值加倍。<br>如果例程回收了 85%的内存分配量，则将各种临界值重置回默认值。</p>
<p><strong>事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。</strong>在IE 中，调用 window.CollectGarbage() 方法会立即执行垃圾收集。</p>
<h1 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h1><p>JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。</p>
<p>最主要的一个问题，就是分配给 Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。<br>目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。<br><strong>内存限制问题</strong>不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。</p>
<p>优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。<br>一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。<br>这一做法适用于大多数全局变量和全局对象的属性。<br>局部变量会在它们离开执行环境时自动被解除引用。</p>
<p>解除一个值的引用并不意味着自动回收该值所占用的内存。<br>解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。<br>为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第三章-3]]></title>
      <url>https://codingme.xyz/2016/09/17/javascript-note-3-3/</url>
      <content type="html"><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>ECMA-262 规定了一组语句（也称为流控制语句）。</p>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) statement1 <span class="keyword">else</span> statement2</div></pre></td></tr></table></figure>
<p>其中的 condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。<br>ECMAScript 会自动调用 Boolean() 转换函数将这个表达式的结果转换为一个布尔值。</p>
<p><strong>业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。</strong>因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。</p>
<h2 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h2><p>要点：<strong>像 do-while 这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。</strong></p>
<h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p>while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。</p>
<h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。</p>
<p><strong>使用 while 循环做不到的，使用 for 循环同样也做不到。</strong>也就是说， for 循环只是把与循环有关的代码集中在了一个位置。</p>
<p>由于 ECMAScript 中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。</p>
<p>for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部省略，就会创建一个无限循环。</p>
<a id="more"></a>
<h2 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h2><p>for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (property <span class="keyword">in</span> expression) statement</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line"><span class="built_in">document</span>.write(propName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName 。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。</p>
<p>与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，<strong>为了保证使用局部变量</strong>，我们推荐上面例子中的这种做法。</p>
<p>ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。</p>
<p>如果表示要迭代的对象的变量值为 null 或 undefined ， for-in 语句会抛出错误。ECMAScript 5 更正了这一行为；<br>为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined 。</p>
<h2 id="label-语句"><a href="#label-语句" class="headerlink" title="label 语句"></a>label 语句</h2><p>使用 label 语句可以在代码中添加标签，以便将来使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">label: statement</div><div class="line"></div><div class="line">start: <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">alert(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中定义的 start 标签可以在将来由 break 或 continue 语句引用。<br>加标签的语句一般都要与 for 语句等循环语句配合使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line">outPoint:</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; j++)&#123;</div><div class="line">          <span class="keyword">if</span>( i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span> )&#123;</div><div class="line">                <span class="keyword">break</span> outPoint;</div><div class="line">          &#125;</div><div class="line">     num++;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">alert(num); <span class="comment">// 循环在 i 为5，j 为5的时候跳出双循环，返回到outPoint层继续执行，输出 55</span></div></pre></td></tr></table></figure>
<p>由例子可见 label 语句可以用来实现break跳出内层循环回到外层这样的功能。<br>然而，就像 Java 中的 goto 语句一样，对于 label 语句：</p>
<p>标记（Labels）在 JavaScript 中并不经常被使用，这是因为它们会使程序变得更难于阅读和理解。<br>应该尽可能地避免使用，根据情况，选择<strong>调用函数</strong> 或 <strong>抛出异常</strong>。——<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label/" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label/</a></p>
<h2 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h2><p>虽然联用 break 、 continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，<strong>一定要使用描述性的标签，同时不要嵌套过多的循环。</strong></p>
<h2 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h2><p>with 语句的作用是将代码的作用域设置到一个特定的对象中。<br>定义 with 语句的目的主要是为了简化多次编写同一个对象的工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> hostName = location.hostname;</div><div class="line"><span class="keyword">var</span> url = location.href;</div></pre></td></tr></table></figure>
<p>上面几行代码都包含 location 对象。如果使用 with 语句:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span>(location)&#123;</div><div class="line"><span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> hostName = hostname;</div><div class="line"><span class="keyword">var</span> url = href;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提示：<strong>严格模式下不允许使用 with 语句，否则将视为语法错误。</strong><br>提示1：由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在<strong>开发大型应用程序时，不建议使用 with 语句。</strong></p>
<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><p>ECMAScript 中 switch 语句的语法与其他基于 C 的语言非常接近。<br>从根本上讲， switch 语句就是为了让开发人员免于编写多个 if else 重复代码。<br>如果需要省略break合并几种情况，不要忘了在代码中添加注释，说明你是有意省略了 break 关键字。<br>ECMAScript 中可以在switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。<br>其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (<span class="string">"hello world"</span>) &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"hello"</span> + <span class="string">" world"</span>:</div><div class="line">alert(<span class="string">"Greeting was found."</span>);</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">"goodbye"</span>:</div><div class="line">alert(<span class="string">"Closing was found."</span>);</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">alert(<span class="string">"Unexpected message was found."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">25</span>;</div><div class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</div><div class="line"><span class="keyword">case</span> num &lt; <span class="number">0</span>:</div><div class="line">alert(<span class="string">"Less than 0."</span>);</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</div><div class="line">alert(<span class="string">"Between 0 and 10."</span>);</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</div><div class="line">alert(<span class="string">"Between 10 and 20."</span>);</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">alert(<span class="string">"More than 20."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要点：<strong>switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串 “10” 不等于数值 10）。</strong></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>ECMAScript 中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过return 语句后跟要返回的值来实现返回值。<br>要点：<strong>推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。</strong><br>实际上，未指定返回值的函数返回的是一个特殊的 undefined 值。</p>
<h2 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h2><ul>
<li>不能把函数命名为 eval 或 arguments ；</li>
<li>不能把参数命名为 eval 或 arguments ；</li>
<li>不能出现两个命名参数同名的情况。</li>
</ul>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="参数特点"><a href="#参数特点" class="headerlink" title="参数特点"></a>参数特点</h3><ul>
<li>ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。<br>  原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。</li>
<li>没有传递值的命名参数将自动被赋予 undefined 值。</li>
<li>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。</li>
</ul>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>arguments 对象只是与数组类似（它并不是 Array 的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是 arguments[0] ，第二个元素是 argumetns[1] ，以此类推），使用 length 属性来确定传递进来多少个参数。</p>
<p>arguments的使用体现ECMAScript 函数的一个重要特点：<strong>命名的参数只提供便利，但不是必需的。</strong></p>
<h4 id="arguments-特点："><a href="#arguments-特点：" class="headerlink" title="arguments 特点："></a>arguments 特点：</h4><ul>
<li>arguments 对象可以与命名参数一起使用。</li>
<li>它的值永远与对应命名参数的值保持同步。<strong>并不是说读取第一个命名参数和arguments[0]这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。</strong></li>
<li>严格模式下，对arguments赋值会变得无效。其次，重写arguments 的值会导致语法错误（代码将不会执行）。</li>
</ul>
<h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><p>ECMAScirpt函数没有签名，真正的重载是不可能做到的。<br>如果在 ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。<br>通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第三章-2]]></title>
      <url>https://codingme.xyz/2016/09/17/javascript-note-3-2/</url>
      <content type="html"><![CDATA[<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>包括算术操作符（如加号和减号）、位操作符、关系操作符和相等操作符。<br>ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。<br>不过，<strong>在应用于对象时，相应的操作符通常都会调用对象的 valueOf()和（或） toString() 方法，以便取得可以操作的值。</strong></p>
<h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><h3 id="递增递减操作符"><a href="#递增递减操作符" class="headerlink" title="递增递减操作符"></a>递增递减操作符</h3><p>执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种情况通常被称作副效应。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</div><div class="line"><span class="keyword">var</span> anotherAge = --age + <span class="number">2</span>;</div><div class="line">alert(age); <span class="comment">// 输出 28</span></div><div class="line">alert(anotherAge); <span class="comment">// 输出 30</span></div></pre></td></tr></table></figure>
<p>后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> num3 = num1-- + num2; <span class="comment">//  等于 22</span></div><div class="line"><span class="keyword">var</span> num4 = num1 + num2; <span class="comment">// 等于 21</span></div></pre></td></tr></table></figure>
<p>作用数据类型时候，等同于先Number()再加减1，会像 Number() 转型函数一样对这个值执行转换。</p>
<a id="more"></a>
<h3 id="一元加操作符"><a href="#一元加操作符" class="headerlink" title="一元加操作符"></a>一元加操作符</h3><p>对数值不会产生任何影响。<br>对非数值应用一元加操作符时，该操作符会像 Number() 转型函数一样对这个值执行转换。<br>所以<strong>疑问</strong>：一元加操作符乃至于递增递减操作符和Number()有什么关系？感觉好像都会经由Number()转换。</p>
<h3 id="一元减操作符"><a href="#一元减操作符" class="headerlink" title="一元减操作符"></a>一元减操作符</h3><p>对数值会让其变成其负数。<br>对非数值跟一元加操作符相同，最后再转换成负数。</p>
<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。<br>而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。<br>对于开发人员来说，由于 64 位存储格式是透明的，因此整个过程就像是只存在 32 位的整数一样。</p>
<p>对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正数，1 表示负数。<br>这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。<br>正数以纯二进制格式存储，31 位中的每一位都表示 2 的幂。<br>负数同样以二进制码存储，但使用的格式是二进制补码。<br>这个转换过程也导致了一个严重的副效应，即在<strong>对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。</strong></p>
<h3 id="按位非-NOT"><a href="#按位非-NOT" class="headerlink" title="按位非 NOT"></a>按位非 NOT</h3><p>按位非操作符由一个波浪线（~）表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">25</span>; <span class="comment">// 二进制 00000000000000000000000000011001</span></div><div class="line"><span class="keyword">var</span> num2 = ~num1; <span class="comment">// 二进制 11111111111111111111111111100110</span></div><div class="line">alert(num2); <span class="comment">// -26</span></div></pre></td></tr></table></figure>
<h3 id="按位与-AND"><a href="#按位与-AND" class="headerlink" title="按位与 AND"></a>按位与 AND</h3><p>按位与操作符由一个和号字符（ &amp; ）表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;</div><div class="line">alert(result); <span class="comment">//1</span></div></pre></td></tr></table></figure>
<h3 id="按位或-OR"><a href="#按位或-OR" class="headerlink" title="按位或 OR"></a>按位或 OR</h3><p>按位或操作符由一个竖线符号（|）表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="number">25</span> | <span class="number">3</span>;</div><div class="line">alert(result); <span class="comment">//27</span></div></pre></td></tr></table></figure>
<h3 id="按位异或-XOR"><a href="#按位异或-XOR" class="headerlink" title="按位异或 XOR"></a>按位异或 XOR</h3><p>按位异或操作符由一个插入符号（^）表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="number">25</span> ^ <span class="number">3</span>;</div><div class="line">alert(result); <span class="comment">//26</span></div></pre></td></tr></table></figure>
<h3 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h3><p>左移操作符由两个小于号（&lt;&lt;）表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oldValue = <span class="number">2</span>; <span class="comment">// 等于二进制的 10</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue &lt;&lt; <span class="number">5</span>; <span class="comment">// 等于二进制的 1000000，十进制的 64</span></div></pre></td></tr></table></figure>
<p>注意，左移不会影响操作数的符号位。换句话说，如果将-2向左移动 5位，结果将是-64，而非 64。<br><strong>也就是说，符号位是不会有变化，而是符号位右边的位会变化</strong></p>
<h3 id="有符号右移"><a href="#有符号右移" class="headerlink" title="有符号右移"></a>有符号右移</h3><p>有符号的右移操作符由两个大于号（&gt;&gt;）表示。<br>会将数值向右移动，但保留符号位。<br> ECMAScript 会用符号位的值来填充所有空位。<br> <strong>即如果是负数的话，填充空位用的是1，反之为0</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oldValue = <span class="number">64</span>; <span class="comment">// 等于二进制的 1000000</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt; <span class="number">5</span>; <span class="comment">// 等于二进制的 10 ，即十进制的 2</span></div></pre></td></tr></table></figure>
<h3 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h3><p>无符号右移操作符由 3 个大于号（&gt;&gt;&gt;）表示。<br>对正数来说，无符号右移的结果与有符号右移相同。<br>无符号右移是以 0 来填充空位，而不是像有符号右移那样以符号位的值来填充空位。</p>
<p>无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。<strong>（填充了无数个0，反码计算回去，十进制的数字无限大）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oldValue = <span class="number">-64</span>; <span class="comment">//  等于二进制的 11111111111111111111111111000000</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>; <span class="comment">// 等于十进制的 134217726</span></div></pre></td></tr></table></figure>
<h3 id="无符号左移"><a href="#无符号左移" class="headerlink" title="无符号左移"></a>无符号左移</h3><p>无符号右移操作符由 3 个大于号（&gt;&gt;&gt;）表示。<br>对负数来说，无符号右移是以 0 来填充空位，其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oldValue = <span class="number">-64</span>; <span class="comment">//  等于二进制的 11111111111111111111111111000000</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>; <span class="comment">// 等于十进制的 134217726</span></div></pre></td></tr></table></figure>
<h2 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h2><h3 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h3><p>逻辑非操作符由一个叹号（！）表示，可以应用于 ECMAScript 中的任何值。</p>
<ul>
<li>如果操作数是一个对象，返回 false ；</li>
<li>如果操作数是一个空字符串，返回 true ；</li>
<li>如果操作数是一个非空字符串，返回 false ；</li>
<li>如果操作数是数值 0，返回 true ；</li>
<li>如果操作数是任意非 0 数值（包括 Infinity ），返回 false ；</li>
<li>如果操作数是 null ，返回 true ；</li>
<li>如果操作数是 NaN ，返回 true ；</li>
<li>如果操作数是 undefined ，返回 true 。</li>
</ul>
<p>同时使用两个逻辑非操作符，实际上就会模拟 Boolean() 转型函数的行为。</p>
<h3 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h3><p>逻辑与操作符由两个和号（ &amp;&amp; ）表示。</p>
<ol>
<li>如果第一个操作数是对象，则返回第二个操作数；</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；</li>
<li>如果两个操作数都是对象，则返回第二个操作数；</li>
<li>如果有一个操作数是 null ，则返回 null ；</li>
<li>如果有一个操作数是 NaN ，则返回 NaN ；</li>
<li>如果有一个操作数是 undefined ，则返回 undefined 。</li>
</ol>
<p><strong>短路操作符</strong>：如果第一个操作数的求值结果为true ，就不会对第二个操作数求值了。</p>
<h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h3><p>逻辑或操作符由两个竖线符号（ || ）表示。</p>
<ol>
<li>同 逻辑与 第一条。</li>
</ol>
<ul>
<li>如果第一个操作数的求值结果为 false ，则返回第二个操作数；</li>
<li>如果两个操作数都是对象，则返回第一个操作数；</li>
<li>如果两个操作数都是 null ，则返回 null ；</li>
<li>如果两个操作数都是 NaN ，则返回 NaN ；</li>
<li>如果两个操作数都是 undefined ，则返回 undefined 。</li>
</ul>
<p>同样是<strong>短路操作符</strong>。</p>
<h4 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h4><p>利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。ECMAScript 程序的赋值语句经常会使用这种模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = preferredObject || backupObject;</div></pre></td></tr></table></figure>
<h2 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h2><p>乘法、除法和求模。<br>如果参与乘性计算的某个操作数不是数值，后台会先使用 Number() 转型函数将其转换为数值。</p>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><ol>
<li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是数。如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或 -Infinity ；</li>
<li>如果有一个操作数是 NaN ，则结果是 NaN ；</li>
<li>如果是 Infinity 与 0 相乘，则结果是 NaN ；</li>
<li>如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或 -Infinity ，取决于有符号操作数的符号；</li>
<li>如果是 Infinity 与 Infinity 相乘，则结果是 Infinity ；</li>
<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。</li>
</ol>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><ul>
<li>同 乘法 第一条；</li>
<li>同 乘法 第二条；</li>
<li>同 乘法 第五条；</li>
<li>如果是零被零除，则结果是 NaN ；</li>
<li>如果是非零的有限数被零除，则结果是 Infinity 或 -Infinity ，取决于有符号操作数的符号；</li>
<li>如果是 Infinity 被任何非零数值除，则结果是 Infinity 或 -Infinity ，取决于有符号操作数的符号；</li>
<li>同 乘法 第六条。</li>
</ul>
<h3 id="求模"><a href="#求模" class="headerlink" title="求模"></a>求模</h3><ol>
<li>如果操作数都是数值，执行常规的除法计算，返回除得的余数；</li>
<li>如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN ；</li>
<li>如果被除数是有限大的数值而除数是零，则结果是 NaN ；</li>
<li>如果是 Infinity 被 Infinity 除，则结果是 NaN ；</li>
<li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；</li>
<li>如果被除数是零，则结果是零； 0%？</li>
<li>同 乘法 第六条。</li>
</ol>
<h2 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><ul>
<li>如果有一个操作数是 NaN ，则结果是 NaN ；</li>
<li>如果是 Infinity 加 Infinity ，则结果是 Infinity ；</li>
<li>如果是 -Infinity 加 -Infinity ，则结果是 -Infinity ；</li>
<li>如果是 Infinity 加 -Infinity ，则结果是 NaN ；</li>
<li>如果是+0 加+0，则结果是+0；</li>
<li>如果是-0 加-0，则结果是-0；</li>
<li>如果是+0 加-0，则结果是+0。</li>
</ul>
<p>如果有一个操作数是字符串，则：</p>
<ul>
<li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。</li>
</ul>
<p>忽视加法操作中的数据类型是 ECMAScript 编程中最常见的一个错误。</p>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><ul>
<li>同 加法 第一条；</li>
<li>如果是 Infinity 减 Infinity ，则结果是 NaN ；</li>
<li>如果是 -Infinity 减 -Infinity ，则结果是 NaN ；</li>
<li>如果是 Infinity 减 -Infinity ，则结果是 Infinity ；</li>
<li>如果是 -Infinity 减 Infinity ，则结果是 -Infinity ；</li>
<li>如果是+0 减+0，则结果是+0；</li>
<li>如果是+0 减-0，则结果是-0；</li>
<li>如果是-0 减-0，则结果是+0；</li>
<li>如果有一个操作数是字符串、布尔值、 null 或 undefined ，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN ，则减法的结果就是 NaN ；</li>
<li>如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN ，则减法的结果就是 NaN 。如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。</li>
</ul>
<h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><ul>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li>
<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li>
<li>如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf() 方法，则调用 toString() 方法，并用得到的结果根据前面的规则执行比较。</li>
<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li>
</ul>
<p>有趣的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"a"</span> &lt; <span class="number">3</span>; <span class="comment">// false，因为"a"被转换成了 NaN</span></div></pre></td></tr></table></figure>
<p>由于字母 “a” 不能转换成合理的数值，因此就被转换成了 NaN 。根据规则，任何操作数与 NaN 进行关系比较，结果都是 false 。</p>
<h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h2><p>由于相等和不相等操作符存在类型转换问题，<strong>而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。</strong></p>
<h3 id="相等和不相等——先转换再比较"><a href="#相等和不相等——先转换再比较" class="headerlink" title="相等和不相等——先转换再比较"></a>相等和不相等——先转换再比较</h3><p>相等操作符由两个等于号（ == ）表示，不相等操作符由叹号后跟等于号（ != ）表示。<br>这两个操作符都会先转换操作数（通常称为强制转型），然后再比较它们的相等性。</p>
<ul>
<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值—— false 转换为 0，而true 转换为 1；</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；</li>
</ul>
<p>这两个操作符在进行比较时则要遵循下列规则。</p>
<ul>
<li>null 和 undefined 是相等的。</li>
<li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li>
<li>如果有一个操作数是 NaN ，则相等操作符返回 false ，而不相等操作符返回 true 。重要提示：即使两个操作数都是 NaN ，相等操作符也返回 false ；因为按照规则， NaN 不等于 NaN 。</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true ；否则，返回 false 。</li>
</ul>
<h3 id="全等和不全等——仅比较而不转换"><a href="#全等和不全等——仅比较而不转换" class="headerlink" title="全等和不全等——仅比较而不转换"></a>全等和不全等——仅比较而不转换</h3><p>全等操作符由 3 个等于号（ === ）表示，不全等操作符由一个叹号后跟两个等于号（ !== ）表示。</p>
<h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><p>条件操作符应该算是 ECMAScript 中最灵活的一种操作符了，而且它遵循与 Java 中的条件操作符相同的语法形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">variable = boolean_expression ? true_value : false_value;</div></pre></td></tr></table></figure>
<p>本质上，这行代码的含义就是基于对 <code>boolean_expression</code> 求值的结果，决定给变量 <code>variable</code>赋什么值。如果求值结果为 <code>true</code> ，则给变量 <code>variable</code> 赋 <code>true_value</code> 值；如果求值结果为<code>false</code> ，则给变量 <code>variable</code> 赋 <code>false_value</code> 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> max = (num1 &gt; num2) ? num1 : num2;</div></pre></td></tr></table></figure>
<p>在这个例子中， max 中将会保存一个最大的值。这个表达式的意思是：如果 num1 大于 num2 （关系表达式返回 true ），则将 num1 的值赋给 max ；如果 num1 小于或等于 num2 （关系表达式返回 false ），则将 num2 的值赋给 max 。</p>
<h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><p>简单的赋值操作符由等于号（ = ）表示。</p>
<ul>
<li>乘/赋值（ *= ）；</li>
<li>除/赋值（ /= ）；</li>
<li>模/赋值（ %= ）；</li>
<li>加/赋值（ += ）；</li>
<li>减/赋值（ -= ）；</li>
<li>左移/赋值（ &lt;&lt;= ）；</li>
<li>有符号右移/赋值（ &gt;&gt;= ）；</li>
<li>无符号右移/赋值（ &gt;&gt;&gt;= ）。</li>
</ul>
<p>设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。</p>
<h2 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h2><p>使用逗号操作符可以在一条语句中执行多个操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1=<span class="number">1</span>, num2=<span class="number">2</span>, num3=<span class="number">3</span>;</div></pre></td></tr></table></figure>
<p>逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">// num 的值为 0</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第三章-1]]></title>
      <url>https://codingme.xyz/2016/09/11/javascript-note-3-1/</url>
      <content type="html"><![CDATA[<h1 id="ECMAScript-的标识符"><a href="#ECMAScript-的标识符" class="headerlink" title="ECMAScript 的标识符"></a>ECMAScript 的标识符</h1><ul>
<li>区分大小写</li>
<li>采用驼峰大小写格式。为了与 ECMAScript 内置的函数和对象命名格式保持一致。<br>  如： doSomethingImportant</li>
</ul>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ul>
<li>单行： <code>//这里是注释</code></li>
<li>多行：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">这里是注释</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="ECMAScript-的严格模式-strict-mode"><a href="#ECMAScript-的严格模式-strict-mode" class="headerlink" title="ECMAScript 的严格模式 (strict mode)"></a>ECMAScript 的严格模式 (strict mode)</h1><ul>
<li>严格模式的启用：<br>顶部添加如下代码：”use strict”;<br>看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为不破坏 ECMAScript 3 语法而特意选定的语法。</li>
<li><p>也可以指定函数在严格模式下执行：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="comment">//函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>严格模式下，JavaScript 的执行结果会有很大不同。<br>  支持严格模式的浏览器包括 IE10+、Firefox 4+、Safari 5.1+、Opera 12+和 Chrome。</p>
</li>
</ul>
<a id="more"></a>
<h1 id="ECMAScript-的语句"><a href="#ECMAScript-的语句" class="headerlink" title="ECMAScript 的语句"></a>ECMAScript 的语句</h1><ul>
<li>任何时候都不要省略语句结尾的分号。加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。</li>
<li>最佳实践是始终在控制语句中使用代码块。</li>
</ul>
<h1 id="ECMAScript-的关键字和保留字"><a href="#ECMAScript-的关键字和保留字" class="headerlink" title="ECMAScript 的关键字和保留字"></a>ECMAScript 的关键字和保留字</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><pre><code>break       do      instanceof  typeof
case        else    new         var
catch       finally return      void
continue    for     switch      while
debugger*   function this       with
default     if      throw
delete      in      try
</code></pre><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>第三版的全部保留字：</p>
<pre><code>abstract    enum        int         short
boolean     export      interface   static
byte        extends     long        super
char        final       native      synchronized
class       float       package     throws
const       goto        private     transient
debugger    implements  protected   volatile
double      import      public
</code></pre><p>第 5 版在非严格模式下：</p>
<pre><code>class   enum      extends   super
const   export    import
</code></pre><p>在严格模式下还有：</p>
<pre><code>implements  package     public
interface   private     static
let         protected   yield
</code></pre><p>为了最大程度地保证兼容性，建议读者将第 3 版定义的保留字外加 let 和 yield 作为编程时的参考。<br>一般来说，最好都不要使用关键字和保留字作为标识符和属性名，以便与将来的 ECMAScript 版本兼容。<br>举例：<br>IE7 问世时 ECMAScript5 还没出来。IE8支持一点，直到IE9支持更多、IE10完美支持。<br>所以为了兼容IE，要这么参考。</p>
<h1 id="ECMAScript-的变量"><a href="#ECMAScript-的变量" class="headerlink" title="ECMAScript 的变量"></a>ECMAScript 的变量</h1><ol>
<li>不建议修改变量所保存值的<strong>类型</strong>。</li>
<li>用 var 操作符定义的变量将成为定义该变量的作用域中的<strong>局部变量</strong>。（即作用域方面的问题）</li>
<li>虽然省略 var 操作符可以定义全局变量，但这也不是我们推荐的做法。<br> 因为在局部作用域中定义的全局变量很难维护，<br> 而且如果有意地忽略了 var 操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。<br> 给<strong>未经声明</strong>的变量赋值在严格模式下会导致抛出 ReferenceError 错误。</li>
<li><p>可以使用一条语句定义多个变量，只要把每个变量用逗号分隔开就行。虽然代码里的换行和变量缩进不是必需的，但这样做可以提高<strong>可读性</strong>。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"hi"</span>,</div><div class="line">    found = <span class="literal">false</span>,</div><div class="line">    age = <span class="number">29</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>在严格模式下，不能定义名为 eval 或 arguments 的变量，否则会导致语法错误。</p>
</li>
</ol>
<h1 id="ECMAScript-的数据类型"><a href="#ECMAScript-的数据类型" class="headerlink" title="ECMAScript 的数据类型"></a>ECMAScript 的数据类型</h1><ol>
<li>五种简单数据类型：<ol>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ol>
</li>
<li>一种复杂数据类型—— Object ， Object 本质上是由一组无序的名值对组成的。</li>
</ol>
<h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><ol>
<li>可能返回的字符串：<br> “undefined” ——如果这个值未定义；<br> “boolean” ——如果这个值是布尔值；<br> “string” ——如果这个值是字符串；<br> “number” ——如果这个值是数值；<br> “object” ——如果这个值是对象或 null；<br> “function” ——如果这个值是函数。</li>
<li><code>typeof null</code>会返回 “object”，因为特殊值 null 被认为是一个空的对象引用。</li>
<li>从技术角度讲，函数在 ECMAScript中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 typeof 操作符来区分函数和其他对象是有必要的。</li>
</ol>
<h2 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h2><ol>
<li>显式的 undefined 值 由 ECMAScript 第三版引入，引入这个值的目的是用于比较，为了正式区分空对象指针（引用,null)与未经初始化的变量。<br> undefined的一个示例：<br> <code>var message;</code> 等同于 <code>var message = undefined;</code></li>
<li><p>对于尚未声明的变量，只能执行一项操作，即使用 typeof 操作符检测其数据类型，然而:</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message; <span class="comment">// 这个变量声明之后默认取得了 undefined 值</span></div><div class="line"><span class="comment">// 下面这个变量并没有声明</span></div><div class="line"><span class="comment">// var age</span></div><div class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// "undefined"</span></div><div class="line">alert(<span class="keyword">typeof</span> age); <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<p> 这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p>
</li>
<li>显式地初始化变量依然是明智的选择。于是 typeof 操作符返回 “undefined”时我们就能确定被检测的变量还没有被声明。（如果声明肯定初始化了不会是 undefined )</li>
</ol>
<h2 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h2><ol>
<li><p>Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null 。从逻辑角度来看， null 值表示一个<strong>空对象指针</strong>，而这也正是使用 typeof 操作符检测 null 值时会返回 “object” 的原因。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> car = <span class="literal">null</span>;</div><div class="line">alert(<span class="keyword">typeof</span> car); <span class="comment">// "object"</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样就可以直接检查知道变量是否已经保存了一个对象的引用。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>)&#123;</div><div class="line"><span class="comment">// 对 car 对象执行某些操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实际上， undefined 值是派生自 null 值的,因此相等性测试【相等操作符（ == ）】：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p> 两者用途完全不同。无论在什么情况下都没有必要把一个变量的值显式地设置为 undefined，对 null则不同。只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined 。</p>
</li>
</ol>
<h2 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><ol>
<li><p>虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"Hello world!"</span>;</div><div class="line"><span class="keyword">var</span> messageAsBoolean = <span class="built_in">Boolean</span>(message);</div></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">数据类型     转换为true的值                 转换为false的值</div><div class="line">Boolean     true                          false</div><div class="line">String      任何非空字符串                  "" （空字符串）</div><div class="line">Number      任何非零数字值（包括无穷大）     0和 NaN</div><div class="line">Object      任何对象                       null</div><div class="line">Undefined   n/a                           undefined</div><div class="line">*/</div></pre></td></tr></table></figure>
<p> 这些转换规则对理解流控制语句（如 if 语句）自动执行相应的 Boolean 转换非常重要</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"Hello world!"</span>;</div><div class="line"><span class="keyword">if</span> (message)&#123;</div><div class="line">alert(<span class="string">"Value is true"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h2><p>ECMScript 没有为整数和浮点数值分别定义不同的数据类型， Number 类型可用于表示所有数值。</p>
<ol>
<li>十进制整数:<br> <code>var intNum = 55; // 整数</code></li>
<li>八进制：<br> <code>var octalNum1 = 070; // 八进制的 56</code></li>
<li>十六进制:<br> <code>var hexNum1 = 0xA; // 十六进制的 10</code></li>
<li>浮点数值：<br> <code>var floatNum1 = 1.1;</code><br> 虽然小数点前面可以没有整数，但我们不推荐这种写法。<br> 保存浮点数值需要的内存空间是保存整数值的两倍，所以 ECMAScript会不失时机地将浮点数值转换为整数值。<br> 如果小数点后面没有跟任何数字，或者本身表示的就是一个整数，那么这个数值就可以作为整数值来保存。<br> 对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。<br> <code>var floatNum = 3.125e7; // 等于 31250000</code><br> 在默认情况下，ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值。</li>
<li>数值范围<ul>
<li><code>Number.MIN_VALUE</code> ：5e-324</li>
<li><code>Number.MAX_VALUE</code> ：1.7976931348623157e+308</li>
<li>一旦超出就会被转换成特殊的Infinity值。</li>
<li>如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，因为 Infinity 不是能够参与计算的数值。</li>
<li>判断是不是有穷的，可以用 <code>isFinite()</code> 函数。</li>
<li>访问 <code>Number.NEGATIVE_INFINITY</code> 和 <code>Number.POSITIVE_INFINITY</code> 也可以得到负和正 Infinity 的值。可以想见，这两个属性中分别保存着 -Infinity 和Infinity 。</li>
</ul>
</li>
<li>NaN<ul>
<li>用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。</li>
<li>在 ECMAScript中，任何数值除以 0会返回 NaN ，因此不会影响其他代码的执行。</li>
<li>特点1：任何涉及 NaN 的操作（例如 NaN /10）都会返回 NaN ，这个特点在多步计算中有可能导致问题。</li>
<li>特点2：NaN 与任何值都不相等，包括 NaN 本身。针对 NaN 的这两个特点，ECMAScript 定义了 isNaN() 函数。</li>
<li>isNaN() 也适用于对象。会首先调用对象的 valueOf() 方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 toString() 方法，再测试返回值。</li>
</ul>
</li>
<li><p>Number() 函数</p>
<ul>
<li>如果是对象，则<strong>调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN ，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符串值。</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">"Hello world!"</span>); <span class="comment">//NaN</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">""</span>); <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">"000011"</span>); <span class="comment">//11</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">//1</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>parseInt()</p>
<ul>
<li><p>由于 Number() 函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是parseInt() 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>); <span class="comment">// 1234</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">""</span>); <span class="comment">// NaN</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>); <span class="comment">// 10（十六进制数）</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>); <span class="comment">// 22</span></div><div class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>); <span class="comment">// 56（八进制数）</span></div><div class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>); <span class="comment">// 70（十进制数）</span></div><div class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">"0xf"</span>); <span class="comment">// 15（十六进制数）</span></div></pre></td></tr></table></figure>
</li>
<li><p>版本的分歧。在 ECMAScript 3 JavaScript 引擎中， “070” 被当成八进制字面量，因此转换后的值是十进制的 56。而在 ECMAScript 5 JavaScript 引擎中， parseInt() 已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成 “70” ，结果就得到十进制的 70。在 ECMAScript 5 中，即使是在非严格模式下也会如此。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ECMAScript 3 认为是 56（八进制），ECMAScript 5 认为是 70（十进制）</span></div><div class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">"070"</span>);</div></pre></td></tr></table></figure>
<p>所以要使用第二个参数指定进制基数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>, <span class="number">16</span>); <span class="comment">//175</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>); <span class="comment">//NaN</span></div></pre></td></tr></table></figure>
</li>
<li><p>建议无论在什么情况下都明确指定基数。</p>
</li>
</ul>
</li>
<li>parseFloat()<ul>
<li>字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。</li>
<li>parseFloat() 与 parseInt() 的第二个区别在于它始终都会忽略前导的零。十六进制格式的字符串则始终会被转换成 0 。</li>
<li>parseFloat() 只解析十进制值。如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零）， parseFloat() 会返回整数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234 （整数）</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>); <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>); <span class="comment">//22.5</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>); <span class="comment">//22.34</span></div><div class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>); <span class="comment">//908.5</span></div><div class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>); <span class="comment">//31250000</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="parseInt和0-1-0-2的陷阱-所以要用parseFloat"><a href="#parseInt和0-1-0-2的陷阱-所以要用parseFloat" class="headerlink" title="parseInt和0.1+0.2的陷阱(所以要用parseFloat)"></a><code>parseInt</code>和<code>0.1+0.2</code>的陷阱(所以要用<code>parseFloat</code>)</h3><p><code>parse(0.0000001)==1</code>，而<code>parseInt(0.01) == 0</code></p>
<ul>
<li><strong>原因</strong>:<ol>
<li><code>parseInt</code> 会先调用 <code>toString</code> 方法。</li>
<li>对于小于 <code>1e-6</code> 的数值来说，<code>toString</code> 时会自动转换为科学计数法。</li>
<li>0.0000001会被转换成<code>&quot;1e-7&quot;</code></li>
<li>于是<code>parseInt(0.0000001)</code>就会变成<code>parseInt(&quot;1e-7&quot;)</code></li>
<li>因为<code>parseInt</code>不认识字符串形式的科学计数法，所以直接匹配字符串数字，<code>&quot;1e-7&quot;</code>就匹配到第一个数字1。</li>
</ol>
</li>
<li><strong>另一示例</strong>:  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="number">1</span>/<span class="number">1000001</span>) <span class="comment">//即parseInt("9.99999000001e-7")</span></div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。<br>例如，0.1 加 0.2的结果不是 0.3，而是 0.30000000000000004。<br>这是使用基于IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家。<br>但是别的语言一般有内置的标准库来解决这个问题，比如BigDecimal。<br>因此，永远不要测试某个特定的浮点数值。<br>解决方法1：使用JavaScript内置的函数toPrecision或toFixed来保留一定的精度。<br>解决方法2：<code>Math.round((0.1+0.2)*100)/100;//0.3</code><br>解决方法3：使用BigDecimal。其他语言有标准类库，js没有内置的BigDecimal的库，要找一些第三方的来完成。</p>
<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><ol>
<li>拼接变量：首先创建一个能容纳 10 个字符的新字符串，然后在这个字符串中填充 “Java” 和 “Script” ，最后一步是销毁原来的字符串 “Java” 和字符串 “Script” ，因为这两个字符串已经没用了。这也是在某些旧版本的浏览器（例如版本低于 1.0 的 Firefox、IE6 等）中拼接字符串时速度很慢的原因所在。</li>
<li>数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 toString() 方法，该方法返回字符串的一个副本）都有 toString() 方法。但 null 和 undefined 值没有这个方法。</li>
<li>toString() 可以输出以二进制、八进制、十六进制乃至其他任意有效进制格式表示的字符串值。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toString()); <span class="comment">// "10"</span></div><div class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">// "1010"</span></div><div class="line">alert(num.toString(<span class="number">8</span>)); <span class="comment">// "12"</span></div><div class="line">alert(num.toString(<span class="number">10</span>)); <span class="comment">// "10"</span></div><div class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">// "a"</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><ol>
<li><p>ECMAScript 中的对象其实就是一组数据和功能的集合。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 有效，但不推荐省略圆括号</span></div></pre></td></tr></table></figure>
</li>
<li><p>在 ECMAScript 中，（就像 Java 中的 java.lang.Object 对象一样） Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。所有对象都具有这些基本的属性和方法。</p>
<ul>
<li><strong>constructor</strong> ：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object() 。</li>
<li><strong>hasOwnProperty(propertyName)</strong> ：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例如： o.hasOwnProperty(“name”) ）。</li>
<li><strong>isPrototypeOf(object)</strong> ：用于检查传入的对象是否是传入对象的原型。</li>
<li><strong>propertyIsEnumerable(propertyName)</strong> ：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定。</li>
<li><strong>toLocaleString()</strong> ：返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li><strong>toString()</strong> ：返回对象的字符串表示。</li>
<li><strong>valueOf()</strong> ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。</li>
</ul>
</li>
<li>ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。BOM 和 DOM 中的对象，都属于宿主对象，ECMA-262 不负责定义宿主对象，因此宿主对象可能会也可能不会继承 Object 。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第二章]]></title>
      <url>https://codingme.xyz/2016/09/10/javascript-note-2/</url>
      <content type="html"><![CDATA[<h1 id="script-元素的-defer"><a href="#script-元素的-defer" class="headerlink" title="script 元素的 defer"></a>script 元素的 defer</h1><p><strong>defer</strong> 延迟脚本。<br>效果：在页面解析时候下载脚本，可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。（HTML 4.01时定义）</p>
<ul>
<li>在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。</li>
<li>把延迟脚本放在页面底部仍然是最佳选择。</li>
<li>defer属性在浏览器之间表现并不一致。defer 属性只被 IE 4 和 Firefox 3.5 更高版本的浏览器所支持，所以它不是一个理想的跨浏览器解决方案。在其他浏览器中，defer 属性会被直接忽略，因此<code>&lt;script&gt;</code>标签会以默认的方式处理，也就是说会造成阻塞。</li>
<li>为了避免跨浏览器的差异，可以使用 “lazy loading”的方法，即直到用到该脚本时才加载。</li>
<li>在 XHTML 文档中，要把 defer 属性设置为 defer=”defer” 。async同理。</li>
</ul>
<h1 id="script-元素的-async"><a href="#script-元素的-async" class="headerlink" title="script 元素的 async"></a>script 元素的 async</h1><p><strong>async</strong> 异步脚本。<br>效果：下载脚本同时不影响页面解析，当下载完毕后就执行，执行完接着页面解析。只对外部脚本文件有效。<br>Google Analytics 就是适合使用 async 的脚本；<br>还有下载其他资源。<br>目的：不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。</p>
<ul>
<li>标记为 async 的脚本并不保证按照指定它们的先后顺序执行。因此，确保互不依赖非常重要。</li>
<li>建议异步脚本不要在加载期间修改 DOM。</li>
<li>异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</li>
</ul>
<a id="more"></a>
<h1 id="MIME-类型"><a href="#MIME-类型" class="headerlink" title="MIME 类型"></a>MIME 类型</h1><ul>
<li>即 type 。表示编写代码使用的脚本语言的内容类型。</li>
<li>如果是 Apache Web 服务器，可以通过 .htaccess 文件设置 MIME 类型。类似：<br>  .htaccess 文件中添加MIME类型：<br>  AddType video/ogg .ogv<br>  AddType video/mp4 .mp4<br>  AddType video/webm .webm<br>  AddType audio/ogg .ogg<br>  AddType audio/mp3 .mp3</li>
</ul>
<h1 id="script-元素的-src-属性"><a href="#script-元素的-src-属性" class="headerlink" title="script 元素的 src 属性"></a>script 元素的 src 属性</h1><ul>
<li>如果使用了 src 属性的值是一个指向外部 JavaScript 文件的链接，那么内部嵌入的代码会被忽略。</li>
<li>正常的 &lt;script&gt; 元素在解析外部 JavaScript 文件（包括下载该文件）时，页面的处理会暂时停止。所以使用async和defer可以在下载该文件时不妨碍页面的处理。</li>
<li>外部 JavaScript 文件带有.js扩展名。但这个扩展名不是必需的这样一来，使用 JSP、PHP 或其他服务器端语言动态生成 JavaScript 代码也就成为了可能。但是，服务器通常还是需要看扩展名决定为响应应用哪种 MIME 类型。如果不使用.js 扩展名，请确保服务器能返回正确的 MIME 类型。</li>
<li>src 属性还可以包含来自外部域的 JavaScript 文件。这点备受争议。如果想包含来自不同域的代码，则要么你是那个域的所有者，要么那个域的所有者值得信赖。否则会有安全隐患。</li>
</ul>
<h1 id="script-元素的注意事项"><a href="#script-元素的注意事项" class="headerlink" title="script 元素的注意事项"></a>script 元素的注意事项</h1><ul>
<li>脚本执行和页面的渲染是共用一个线程。</li>
<li>在解释器对 &lt;script&gt; 元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。</li>
<li>使用 <code>&lt;script&gt;</code> 嵌入 JavaScript 代码时，记住不要在代码中的任何地方出现 “<code>&lt;/script&gt;</code>“ 字符串。</li>
<li>一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript 代码。<br>  优点有：<br>  可维护性；<br>  可缓存；<br>  适应未来。</li>
</ul>
<h1 id="script-元素与-XHTML"><a href="#script-元素与-XHTML" class="headerlink" title="script 元素与 XHTML"></a>script 元素与 XHTML</h1><p>比较语句 a &lt; b 中的小于号（&lt;）在 XHTML 中将被当作开始一个新标签来解析。但是作为标签来讲，小于号后面不能跟空格，因此就会导致语法错误。</p>
<ul>
<li>解决方法1：使用字符实体来代替小于号（&lt;），比如 &lt; 。</li>
<li>解决方法2：使用一个 CData 片段来包含 JavaScript 代码。示例：  <figure class="highlight xhtml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="xml"></span></div><div class="line">&lt;![CDATA[   //不兼容XHTML的话将此行注释掉。</div><div class="line">function compare(a, b) &#123;</div><div class="line">if (a &lt; b) &#123;</div><div class="line">alert("A is less than B");</div><div class="line">&#125; else if (a &gt; b) &#123;</div><div class="line">alert("A is greater than B");</div><div class="line">&#125; else &#123;</div><div class="line">alert("A is equal to B");</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">]]&gt;    //不兼容XHTML的话将此行注释掉。</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>将页面的 MIME 类型指定为 “application/xhtml+xml” 的情况下会触发 XHTML 模式。并不是所有浏览器都支持以这种方式提供 XHTML 文档。</p>
<h1 id="文档模式与文档类型-doctype"><a href="#文档模式与文档类型-doctype" class="headerlink" title="文档模式与文档类型(doctype)"></a>文档模式与文档类型(doctype)</h1><ul>
<li>IE 5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。</li>
<li>最初两种文档模式：混杂模式（quirks mode)和标准模式（standards mode）。混杂模式也称作怪异模式。</li>
<li>混杂模式会让 IE 的行为与 IE5 相同,而标准模式则让 IE 的行为更接近标准行为。</li>
<li>这两种模式主要影响 CSS内容的呈现，但在某些情况下也会影响到 JavaScript 的解释执行。</li>
<li>之后，IE 又提出一种所谓的准标准模式（almost standards mode）。这种模式下的浏览器特性有很多都是符合标准的，但也不尽然。不标准的地方主要体现在处理图片间隙的时候（在表格中使用图片时问题最明显）。</li>
<li>准标准模式与标准模式非常接近，它们的差异几乎可以忽略不计。因此，当有人提到“标准模式”时，有可能是指这两种模式中的任何一种。</li>
<li>如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。</li>
<li>采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。</li>
</ul>
<h2 id="标准模式（包含HTML的严格模式-版本）"><a href="#标准模式（包含HTML的严格模式-版本）" class="headerlink" title="标准模式（包含HTML的严格模式/版本）"></a>标准模式（包含HTML的严格模式/版本）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- HTML 4.01 严格型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"</span></div><div class="line">"http://www.w3.org/TR/html4/strict.dtd"&gt;</div><div class="line"><span class="comment">&lt;!-- XHTML 1.0 严格型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC</span></div><div class="line">"-//W3C//DTD XHTML 1.0 Strict//EN"</div><div class="line">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</div><div class="line"><span class="comment">&lt;!-- HTML 5 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div></pre></td></tr></table></figure>
<h2 id="准标准模式-有框架集版本、过渡版本）"><a href="#准标准模式-有框架集版本、过渡版本）" class="headerlink" title="准标准模式(有框架集版本、过渡版本）"></a>准标准模式(有框架集版本、过渡版本）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- HTML 4.01 过渡型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC</span></div><div class="line">"-//W3C//DTD HTML 4.01 Transitional//EN"</div><div class="line">"http://www.w3.org/TR/html4/loose.dtd"&gt;</div><div class="line"><span class="comment">&lt;!-- HTML 4.01 框架集型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC</span></div><div class="line">"-//W3C//DTD HTML 4.01 Frameset//EN"</div><div class="line">"http://www.w3.org/TR/html4/frameset.dtd"&gt;</div><div class="line"><span class="comment">&lt;!-- XHTML 1.0 过渡型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC</span></div><div class="line">"-//W3C//DTD XHTML 1.0 Transitional//EN"</div><div class="line">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</div><div class="line"><span class="comment">&lt;!-- XHTML 1.0 框架集型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC</span></div><div class="line">"-//W3C//DTD XHTML 1.0 Frameset//EN"</div><div class="line">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt;</div></pre></td></tr></table></figure>
<h1 id="noscript-元素"><a href="#noscript-元素" class="headerlink" title="noscript 元素"></a>noscript 元素</h1><p>浏览器不支持 JavaScript 时如何让页面平稳地退化。于是 noscript 诞生。<br>这个元素可以包含能够出现在文档 <code>&lt;body&gt;</code> 中的任何 HTML 元素—— <code>&lt;script&gt;</code> 元素除外。<br>包含在 <code>&lt;noscript&gt;</code> 元素中的内容只有在下列情况下才会显示出来：</p>
<ul>
<li>浏览器不支持脚本；</li>
<li>浏览器支持脚本，但脚本被禁用。</li>
</ul>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">"defer"</span> <span class="attr">src</span>=<span class="string">"example1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">"defer"</span> <span class="attr">src</span>=<span class="string">"example2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 本页面需要浏览器支持（启用）JavaScript 。</div><div class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》读书笔记-第一章]]></title>
      <url>https://codingme.xyz/2016/09/09/javascript-note-1/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript-的诞生："><a href="#JavaScript-的诞生：" class="headerlink" title="JavaScript 的诞生："></a>JavaScript 的诞生：</h1><p>以前必须把表单数据发送到服务器端才能确定用户是否没有填写某个必填域。<br>Netscape Navigator 希望通过 JavaScript 来解决这个问题。<br>于是 JavaScript 诞生，当时主要目的是处理以前由服务器端语言负责的一些输入验证操作。<br>它从一个简单的输入验证器发展成为一门强大的编程语言。</p>
<h1 id="JavaScript、ECMAScript-历史："><a href="#JavaScript、ECMAScript-历史：" class="headerlink" title="JavaScript、ECMAScript 历史："></a>JavaScript、ECMAScript 历史：</h1><ol>
<li>Netscape navigator 2诞生, JavaScript 诞生。</li>
<li>IE 的 JScript。</li>
<li>标准化，ECMA-262，即 ECMAScript 诞生。</li>
<li>ECMAScript 与 Web 浏览器没有依赖关系,Web 浏览器只是 ECMAScript 实现可能的宿主环境之一。</li>
<li>ECMA-262 定义的只是这门语言的基础。</li>
<li>JavaScript 包含 <strong>ECMAScript</strong> 、 <strong>DOM</strong> 、 <strong>BOM</strong> 三个部分。</li>
</ol>
<a id="more"></a>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><ul>
<li>针对 XML 但经过扩展用于 HTML 的应用程序编程接口（API,Application Programming Interface）</li>
<li>DOM 目的：允许您使用 JavaScript 动态创建 HTML 的几乎全部文档内容。</li>
<li>为什么要用 DOM ?<br>  IE 4 和 网景浏览器 4 分别支持不同形式的 DHTML 。怕出现技术割据互不兼容，于是 W3C 开始着手规划 DOM 。<br>  DOM 并不只是针对 JavaScript 的，很多别的语言也都实现了 DOM。不过，在 Web 浏览器中，基于 ECMAScript 实现的 DOM 的确已经成为 JavaScript 这门语言的一个重要组成部分。</li>
</ul>
<h2 id="DOM-1-级"><a href="#DOM-1-级" class="headerlink" title="DOM 1 级"></a>DOM 1 级</h2><p>目标主要是映射文档的结构。(DOM1 级 于 1998 年 10 月成为 W3C 的推荐标准。)</p>
<ul>
<li><strong>DOM 核心（DOM Core）</strong>，规定如何映射基于 XML 的文档结构；</li>
<li><strong>DOM HTML</strong> ，在前者基础上扩展，添加了针对 HTML 的对象和方法。</li>
</ul>
<h2 id="DOM-2-级"><a href="#DOM-2-级" class="headerlink" title="DOM 2 级"></a>DOM 2 级</h2><p>原来 DOM 的基础上又扩充了许多细分模块。而且通过对象接口增加了对 CSS 的支持。</p>
<ul>
<li><strong>DOM 视图（DOM Views）</strong>，定义了跟踪不同文档视图的接口；</li>
<li><strong>DOM 事件（DOM Events）</strong>：定义了事件和事件处理的接口；</li>
<li><strong>DOM 样式（DOM Style）</strong>：定义了基于 CSS 为元素应用样式的接口；</li>
<li><strong>DOM 遍历和范围（DOM Traversal and Range）</strong>：定义了遍历和操作文档树的接口。</li>
</ul>
<h2 id="DOM-3-级"><a href="#DOM-3-级" class="headerlink" title="DOM 3 级"></a>DOM 3 级</h2><ul>
<li><strong>DOM 加载和保存（DOM Load and Save）</strong>：引入了以统一方式加载和保存文档的方法；</li>
<li><strong>DOM 验证（DOM Validation）</strong>：新增了验证文档的方法；</li>
<li>对 DOM 核心进行了扩展，开始<strong>支持 XML 1.0 规范</strong>，涉及 XML Infoset、XPath 和 XML Base。</li>
</ul>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><ul>
<li>在 HTML5 之前， BOM 的问题在于他作为 JavaScript 的一部分却没有相关标准。</li>
<li>根本上讲，BOM 只处理浏览器窗口和框架；</li>
<li>但人们习惯上也把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。 比如：<br>  弹出新浏览器窗口的功能；<br>  移动、缩放和关闭浏览器窗口的功能；<br>  提供浏览器详细信息的 navigator 对象；<br>  提供浏览器所加载页面的详细信息的 location 对象；<br>  提供用户显示器分辨率详细信息的 screen 对象；<br>  对 cookies 的支持；<br>  像 XMLHttpRequest 和 IE的 ActiveXObject 这样的自定义对象。</li>
</ul>
<h1 id="JavaScript-版本"><a href="#JavaScript-版本" class="headerlink" title="JavaScript 版本"></a>JavaScript 版本</h1><p>大多数浏览器在提及对 JavaScript 的支持情况时，一般都以 ECMAScript 兼容性和对 DOM的支持情况为准。</p>
<h1 id="HTML-、CSS-版本联动"><a href="#HTML-、CSS-版本联动" class="headerlink" title="HTML 、CSS 版本联动"></a>HTML 、CSS 版本联动</h1><ul>
<li>当早期的浏览器 Netscape 4 和 Explorer 4 对 css 进行解析时，并未遵守 W3C 标准，这时的解析方式就被我们称之为 quirks mode (怪异模式)。</li>
<li>怪异模式的主要目的就是向后兼容（向下兼容），兼容旧版浏览器。在怪异模式下，排版会模拟 Navigator 4 与 Internet Explorer 5 的非标准行为。</li>
<li>怪异模式与标准模式的具体的最大不同在于盒模型的解释上。<br>  怪异模式的盒模型宽度：元素的实际宽度 width ，不包含 margin 、border 、 padding 。<br>  标准模式（包含HTML严格模式）的盒模型宽度： margin + padding + border + 元素的实际宽度 width 。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《HTML5与CSS3基础教程》读书笔记5]]></title>
      <url>https://codingme.xyz/2016/09/06/html-css-diary-5/</url>
      <content type="html"><![CDATA[<h1 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h1><ol>
<li><code>type=&quot;radio&quot;</code> ，例子：性别的单选按钮。</li>
<li>两个按钮的 name 属性都是 gender ，相同 name 才能实现同一时间只有其中一个能被选中。</li>
<li>value 属性设置值，因为对于单选按钮访问者无法输入值。</li>
<li>输入 checked 或者 <code>checked=&quot;checked&quot;</code> 让该单选按钮在页面打开时默认处于激活状态</li>
</ol>
<h1 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h1><ol>
<li><code>type=&quot;checkbox&quot;</code> ,例子：选择订阅推送。</li>
<li>name 属性相同，<code>name=&quot; boxset &quot;</code>。（如果使用 PHP 处理表单，使用 name=” boxset[] “)</li>
<li>value 属性设置值，因为对于复选按钮访问者无法输入值。</li>
<li>checked 方面跟单选按钮一样。</li>
</ol>
<h1 id="textarea-元素，文本区域"><a href="#textarea-元素，文本区域" class="headerlink" title="textarea 元素，文本区域"></a>textarea 元素，文本区域</h1><ol>
<li>rows 和 cols 属性分别控制文本区域的高度和宽度，除非使用 CSS 覆盖其中之一或者全部。</li>
<li>textarea 没有 value 属性，所以如果想要预设文本要直接在 textarea 标签之间添加文本。</li>
</ol>
<a id="more"></a>
<h1 id="下拉选择框"><a href="#下拉选择框" class="headerlink" title="下拉选择框"></a>下拉选择框</h1><ul>
<li><p>用 select 和 option 元素</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"state"</span>&gt;</span>State:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"state"</span> <span class="attr">name</span>=<span class="string">"state"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"AL"</span>&gt;</span>Alabama<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"AK"</span>&gt;</span>Alaska<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">...</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>size=”n”， n 代表选择框高度。如果不设置就必须选择一个选择项。设置后菜单显示为一个有滚动条的列表，默认没有选中任何一项。</p>
</li>
<li>option 元素的属性： selected 或者 <code>selected=&quot;selected&quot;</code> ，指定该选项默认被选中。</li>
<li>option 元素也是有 label 属性可替代中间的文本，不过 Firefox 不支持这一属性，所以最好不用。</li>
<li>如果需要对选择项进行分组，使用 optgroup 元素，带有 label 属性。</li>
</ul>
<h1 id="上传文件的设置"><a href="#上传文件的设置" class="headerlink" title="上传文件的设置"></a>上传文件的设置</h1><ol>
<li>对于 input 要设置 <code>type=&quot;file&quot;</code>,对于 form 要设置<code>&lt;form method=&quot;post&quot; action=&quot;show-data.php&quot;enctype=&quot;multipart/form-data&quot;&gt;</code></li>
<li>multiple 属性可以允许上传多个文件(IE10+ 支持，移动端忽略)</li>
<li>对于 type=”file” 的 input 元素，浏览器会自动创建 Browse（浏览）按钮。Chrome 和 Safari 不会创建框，它们只显示按钮。</li>
</ol>
<h1 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h1><ol>
<li>例子：<code>&lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;6&quot; /&gt;</code><br> 访问者不会看到这个输入框，但他们提交表单的时候，名 “step” 和值 “6” 会随着表单中从访问者输入获取的数据一起传送给服务器。</li>
<li><code>&lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;&lt;?= $email ?&gt;&quot; /&gt;</code><br> 创建隐藏字段时，可以使用脚本中的变量将字段的值设置为访问者原来输入的值（这个示例使用了 PHP 语法）</li>
<li>隐藏字段用法：<br> 用来处理那些你不想在表单页面里编辑和显示 ，但是又必须跟随表单填写者填写的其他信息，例如当前时间。<br> <code>&lt;input type=&quot;hidden&quot; name=&quot;time&quot; value=&quot;&lt;%=NowTime%&gt;&quot;&gt;</code></li>
</ol>
<h1 id="disabled-和-readonly"><a href="#disabled-和-readonly" class="headerlink" title="disabled 和 readonly"></a>disabled 和 readonly</h1><p>readonly 可以获得焦点，访问者可以选择和复制里面的文本，但不能修改，只能用于文本框和文本区域。</p>
<h1 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h1><ol>
<li>除了典型的 <code>type=&quot;submit&quot;</code> 外，还可以用 <code>type=&quot;image&quot;</code> 使用图像形式的提交按钮。</li>
<li>创建结合文本和图像的提交按钮可以用 button 元素。（依然使用 <code>type=&quot;submit&quot;</code> 。其中除了文字还包含 <code>&lt;img&gt;</code>)<br> (使用 button 元素要注意考虑 IE8 之前的兼容问题)</li>
<li>如果有多个提交按钮，可以为每个按钮设置 name 属性和 value 属性。<br> 否则 name 属性最好省略。<br> 如果需要多个提交按钮就应避免使用 button 。</li>
</ol>
<h1 id="表单的重置"><a href="#表单的重置" class="headerlink" title="表单的重置"></a>表单的重置</h1><ol>
<li><code>&lt;input type=&quot;reset&quot; /&gt;</code> 或 <code>&lt;button type=&quot;reset&quot;&gt;Reset&lt;/button&gt;</code></li>
<li><code>&lt;input type=&quot;button&quot; value=&quot;这个用JavaScript清除&quot;onclick=&quot;document.getElementById(&#39;form1&#39;).reset()&quot;/&gt;</code></li>
</ol>
<h1 id="禁用验证功能"><a href="#禁用验证功能" class="headerlink" title="禁用验证功能"></a>禁用验证功能</h1><p>HTML5 对 <code>type=&quot;email&quot;</code> 和 <code>type=&quot;URL&quot;</code> 的 input 添加了自动验证功能。对提交按钮使用 formnovalidate 属性可以关闭该功能，如 <code>&lt;input type=&quot;submit&quot; formnovalidate /&gt;</code> 。</p>
<h1 id="禁用表单元素"><a href="#禁用表单元素" class="headerlink" title="禁用表单元素"></a>禁用表单元素</h1><p>例子：当选择了 Others 的时候，textarea 才可以访问修改输入文本。<br>方式：</p>
<ol>
<li>将 textarea 设为 disabled ；</li>
<li>在最后 <code>&lt;/body&gt;</code> 之前添加 script 引入了一个 JavaScript 文件。该文件包含了一段脚本，其作用是当用户选择 Other（其他）单选按钮时，让 textarea 变为可用的，选择其余两个单选按钮中的任意一个，则会禁用 textarea。</li>
</ol>
<h1 id="活用伪类"><a href="#活用伪类" class="headerlink" title="活用伪类"></a>活用伪类</h1><ol>
<li>利用和相邻同胞结合符+,实现选择框勾中后文字变色、选择输入框时输入框背景颜色改变等。</li>
<li>给 form 元素一个类，对于该类所有 input 子元素有 <code>:invalid</code> 伪类的颜色设置为红色。</li>
</ol>
<h1 id="多媒体元素属性"><a href="#多媒体元素属性" class="headerlink" title="多媒体元素属性"></a>多媒体元素属性</h1><ol>
<li>使用控件 controls 属性。</li>
<li>预加载 preload 默认 auto，可设 metadata 和 none。</li>
</ol>
<h1 id="旧浏览器兼容-html5-多媒体"><a href="#旧浏览器兼容-html5-多媒体" class="headerlink" title="旧浏览器兼容 html5 多媒体"></a>旧浏览器兼容 html5 多媒体</h1><ol>
<li>mediaelement.js（mediaelementjs.com/）</li>
<li>Video.js（www.videojs.com）、</li>
<li>JW Player （www.longtailvideo.com/jw-player/）</li>
<li>Flowplayer（flowplayer.org）</li>
</ol>
<p>JW Player 和 Flowplayer 的免费版本会在媒体播放器上显示它们的标识。</p>
<h1 id="表格的属性"><a href="#表格的属性" class="headerlink" title="表格的属性"></a>表格的属性</h1><ol>
<li>对于标题单元格 th ，使用 scope 属性 （col/row/colgroup/rowgroup)</li>
<li>如果有 caption 元素则必定是 table 中第一个元素。</li>
<li>thead 和 tfoot 每个 table 只能各有一个。</li>
<li>如果有了 thead 和 tfoot 则必定要有 tbody 。</li>
<li>table 嵌套在 figure 中时可以省略掉 caption 直接用 figcaption 。</li>
<li>当使单元格跨越多行多列时使用 colspan 和 rowspan 属性。</li>
<li>如果<strong>正下列正好是标题单元格的内容</strong>的话，可以用 <code>scope=&quot;rowgroup&quot;</code> 属性。<br> 例子： th 为 Time ,正下列为各个时间。</li>
</ol>
<h1 id="表格的相关-CSS-设置"><a href="#表格的相关-CSS-设置" class="headerlink" title="表格的相关 CSS 设置"></a>表格的相关 CSS 设置</h1><ol>
<li><code>border-collapse:collapse;</code> 能<strong>合并重复的单元格边框</strong>。<br> （默认值为 <code>border-collapse:separate;</code> ）</li>
<li>不同的浏览器显示的样式稍有差异，尤其是 <code>Internet Explorer</code>。</li>
</ol>
<h1 id="JavaScript-的部分注意事项"><a href="#JavaScript-的部分注意事项" class="headerlink" title="JavaScript 的部分注意事项"></a>JavaScript 的部分注意事项</h1><ol>
<li><code>&lt;script&gt;</code> 标签在大多数情况下最好在页面的<strong>最末尾</strong>加载，即<code>&lt;/body&gt;</code>前面</li>
<li>保持组织文件良好，通常将 JavaScript 文件放在一个<strong>子文件夹</strong>中。</li>
<li>通常，<strong>压缩后的脚本</strong>以 <strong>.min.js</strong> 作为扩展名</li>
</ol>
<h1 id="JavaScript-的阻塞行为"><a href="#JavaScript-的阻塞行为" class="headerlink" title="JavaScript 的阻塞行为"></a>JavaScript 的阻塞行为</h1><ol>
<li>默认情况下，浏览器会按照脚本在 HTML 中出现的顺序对它们进行加载。</li>
<li>在处理脚本的过程中，浏览器既不会下载该 script 元素后面出现的内容（哪怕是文本），也不会呈现这些内容。这称为<strong>阻塞行为</strong>。</li>
<li>消除 JavaScript 阻塞最简单的方法就是将所有的 script 元素放置在 HTML 结束之前，即 <code>&lt;/body&gt;</code> 结束标签的前面。</li>
<li>如果确实需要在 head 中加载脚本，也要将它们放置在所有加载 CSS 文件的 link 元素之后（这也是出于性能的考虑）。</li>
<li>另一种简单的加快脚本加载速率的方法就是将 JavaScript 放在同一个文件中（或尽可能少的一些文件中）并压缩代码。</li>
</ol>
<h1 id="压缩脚本工具"><a href="#压缩脚本工具" class="headerlink" title="压缩脚本工具"></a>压缩脚本工具</h1><ul>
<li><strong>Google Closure Compiler</strong><br>  <a href="http://code.google.com/closure/compiler/" target="_blank" rel="external">http://code.google.com/closure/compiler/</a>（供下载的版本及文档）<br>  <a href="http://closure-compiler.appspot.com/" target="_blank" rel="external">http://closure-compiler.appspot.com/</a>（在线版本）</li>
<li><strong>UglifyJS</strong>（使用第二个链接）<br>  <a href="https://github.com/mishoo/UglifyJS2/" target="_blank" rel="external">https://github.com/mishoo/UglifyJS2/</a>（供下载的版本及文档）<br>  <a href="http://lisperator.net/uglifyjs/" target="_blank" rel="external">http://lisperator.net/uglifyjs/</a>（在线版本，选择“Open demo”)</li>
<li><strong>YUI Compressor</strong>（使用第二个链接）<br>  <a href="http://developer.yahoo.com/yui/compressor/" target="_blank" rel="external">http://developer.yahoo.com/yui/compressor/</a>（供下载的版本及文档）<br>  <a href="http://refresh-sf.com/yui/" target="_blank" rel="external">http://refresh-sf.com/yui/</a>（非官方的在线版本）</li>
</ul>
<h1 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h1><ol>
<li>HTML 的代码验证：<ul>
<li><a href="http://validator.w3.org/" target="_blank" rel="external">http://validator.w3.org/</a></li>
<li><a href="http://html5.validator.nu/" target="_blank" rel="external">http://html5.validator.nu/</a><br>感觉部分验证过于注重“正统”..</li>
</ul>
</li>
<li>CSS 的代码验证：<br> <a href="http://jigsaw.w3.org/css-validator/" target="_blank" rel="external">http://jigsaw.w3.org/css-validator/</a><br> 依然是过于注重“正统”的感觉….</li>
<li>Lint<br> 有 HTML Lint ,也有各种各样的 Lint 。<br> 有在线的，也有本地的；<br> 有单独的，也有插件式的。</li>
</ol>
<h1 id="浏览器开发工具"><a href="#浏览器开发工具" class="headerlink" title="浏览器开发工具"></a>浏览器开发工具</h1><ol>
<li>Chrome DevTools<br> <a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="external">https://developers.google.com/web/tools/chrome-devtools/</a></li>
<li>Firebug<br> <a href="http://getfirebug.com/" target="_blank" rel="external">http://getfirebug.com/</a></li>
<li>Web Developer<br> <a href="http://chrispederick.com/work/web-developer/" target="_blank" rel="external">http://chrispederick.com/work/web-developer/</a></li>
</ol>
<p>此外还有 Internet Explorer：F12 Developer Tools 、Opera：Dragonfly 、Safari：Web Inspector 等。</p>
<h1 id="Web-分析"><a href="#Web-分析" class="headerlink" title="Web 分析"></a>Web 分析</h1><ul>
<li>谷歌分析： <a href="https://www.google.com/analytics/" target="_blank" rel="external">https://www.google.com/analytics/</a></li>
<li>百度统计： <a href="http://tongji.baidu.com/" target="_blank" rel="external">http://tongji.baidu.com/</a></li>
<li>腾讯分析: <a href="http://ta.qq.com/" target="_blank" rel="external">http://ta.qq.com/</a></li>
<li>CNZZ &amp;友盟统计：<br>  <a href="https://web.umeng.com/main.php?c=user&amp;a=index/" target="_blank" rel="external">https://web.umeng.com/main.php?c=user&amp;a=index/</a><br>  <a href="http://www.cnzz.com/o_index.php/" target="_blank" rel="external">http://www.cnzz.com/o_index.php/</a></li>
<li>不蒜子统计： <a href="http://service.ibruce.info/" target="_blank" rel="external">http://service.ibruce.info/</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《HTML5与CSS3基础教程》读书笔记4]]></title>
      <url>https://codingme.xyz/2016/09/01/html-css-diary-4/</url>
      <content type="html"><![CDATA[<h1 id="sprite"><a href="#sprite" class="headerlink" title="sprite"></a>sprite</h1><ul>
<li>目的：<br>  将多个图像拼合成单个背景图像（sprite），再通过 CSS 控制具体显示图像的哪一部分，从而减少多个图像的 HTTP 请求问题。常用于UI上的多个小图标、重复图标等。</li>
<li>使用方法：<br>  <code>background-image</code> 获得图像，<code>background-position</code> 获得所取的具体位置(目前只知道x范围和y范围，但想必还可以更加深入的切取）</li>
<li>工具：<br>  可以多个图片合成一张 sprite 的 CSS Sprite Generator:<a href="http://spritegen.website-performance.org/" target="_blank" rel="external">http://spritegen.website-performance.org/</a></li>
<li>关于 Retina 显示屏：<br>  使用长宽双倍大小像素的图片，一样的容器长宽，使其缩小。</li>
</ul>
<h1 id="列表的缩进对齐"><a href="#列表的缩进对齐" class="headerlink" title="列表的缩进对齐"></a>列表的缩进对齐</h1><p>默认的列表要左缩进对齐的话，用<code>padding-left:1.125em</code>，但是针对 IE7 及以下版本，还要使用<code>margin-left:0;</code></p>
<h1 id="ol-、ul-的选择"><a href="#ol-、ul-的选择" class="headerlink" title="ol 、ul 的选择"></a>ol 、ul 的选择</h1><p>会因为顺序改变而改变的列表，使用有序列表，比如<strong>分页标记</strong>、<strong>面包屑导航</strong>；其他大多数情况下都可以用无序列表。</p>
<h1 id="标记的修改"><a href="#标记的修改" class="headerlink" title="标记的修改"></a>标记的修改</h1><ul>
<li>对于标记的修改，使用 <code>list-style-type:none;</code> 或者 <code>type=&quot;none&quot;;</code></li>
<li><code>background: url( image.ext ) repeat-type horizontal vertical;</code> [ horizontal、vertical 是背景图像相对于元素的位置，默认为0]</li>
<li><code>list-style-image</code> 不同浏览器显示效果不一致，更难控制位置（所以很少用）</li>
</ul>
<h1 id="列表的属性-start-、value"><a href="#列表的属性-start-、value" class="headerlink" title="列表的属性 start 、value"></a>列表的属性 start 、value</h1><p><code>&lt;ol&gt;</code> 中 <code>start=&quot;n&quot;</code> 表示列表初始值， <code>&lt;li&gt;</code> 的 <code>value=&quot;n&quot;</code> 表示该项目的值。value 属性的值会覆盖 start 的值。</p>
<h1 id="列表标记的位置"><a href="#列表标记的位置" class="headerlink" title="列表标记的位置"></a>列表标记的位置</h1><p><code>list-style-position</code> 默认为 <code>outside</code> ，可以设置为 <code>inside</code> 成为段落的一部分（像首个大写的字母）而不是独立在段落外。</p>
<a id="more"></a>
<h1 id="列表中文本拥挤问题"><a href="#列表中文本拥挤问题" class="headerlink" title="列表中文本拥挤问题"></a>列表中文本拥挤问题</h1><p>利用好 <code>line-height</code> 增大文本行间距。</p>
<h1 id="list-style-的继承"><a href="#list-style-的继承" class="headerlink" title="list-style-* 的继承"></a>list-style-* 的继承</h1><p>list-style-type 、list-style-position 和 list-style-image ， list-style 属性都是继承的。这也是我们可以应用到父元素 ol 或 ul 上的原因。</p>
<h1 id="元素的隐藏"><a href="#元素的隐藏" class="headerlink" title="元素的隐藏"></a>元素的隐藏</h1><p>使用 <code>left:</code><br>    <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.nav</span> <span class="selector-class">.subnav</span> &#123;</div><div class="line">    <span class="attribute">left</span>: -<span class="number">999em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.nav</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.subnav</span> &#123;</div><div class="line"><span class="attribute">left</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题:除了 left 能否用其他方法？<br>（关键是要避免误交互，所以我想元素本身还在那里的 opacity 和 visibility 应该不行）<br>能否用 display:none 、 position:absolute 、Clip-path ？</p>
<h1 id="dt-元素、-dd-元素"><a href="#dt-元素、-dd-元素" class="headerlink" title="dt 元素、 dd 元素"></a>dt 元素、 dd 元素</h1><p><code>&lt;dt&gt;</code>: Definition Term.<br><code>&lt;dd&gt;</code>: Description.<br>dd 元素必定是接在 dt 元素之后。<br>dd 元素不必用 p 元素来标记文本（除非里面有多个段落）</p>
<h1 id="HTML5-form-表单的旧浏览器兼容"><a href="#HTML5-form-表单的旧浏览器兼容" class="headerlink" title="HTML5 form 表单的旧浏览器兼容"></a>HTML5 form 表单的旧浏览器兼容</h1><p><a href="https://github.com/ryanseddon/H5F/" target="_blank" rel="external">https://github.com/ryanseddon/H5F/</a></p>
<h1 id="input-type-选择的兼容性"><a href="#input-type-选择的兼容性" class="headerlink" title="input type 选择的兼容性"></a>input type 选择的兼容性</h1><p><a href="https://www.wufoo.com/html5/" target="_blank" rel="external">https://www.wufoo.com/html5/</a></p>
<h1 id="method-”get”-与-“post”-的区别"><a href="#method-”get”-与-“post”-的区别" class="headerlink" title="method=”get” 与 “post” 的区别"></a>method=”get” 与 “post” 的区别</h1><ol>
<li>如果希望表单提交后从服务器得到信息使用 method=”get”。表单提交后，表单中的数据会显示在浏览器的地址栏里。get 一般用于<strong>数据查询</strong>。<br> 例子：各大搜索引擎。</li>
<li>使用 method=”post” 提交表单后，表单中的数据不会显示在浏览器的地址栏里，这样更为安全。同时，比起 get ，使用 post 可以向服务器发送更多的数据。通常，post 用于向服务器存入数据，而非获取数据。如果需要在数据库中<strong>保存、添加和删除数据</strong>，就应选择 post 。</li>
<li>通常，如果不确定使用哪一种，就使用 post ，这样数据不会暴露在 URL 中。</li>
<li>GET 相对 POST 的优点：<ol>
<li>GET 请求是可被缓存的，可被收藏为书签，不应在处理敏感数据时使用，只应当用于取回数据。但是 POST 不可以。</li>
<li>GET 速度一般比 POST 快。</li>
</ol>
</li>
</ol>
<h1 id="表单安全性"><a href="#表单安全性" class="headerlink" title="表单安全性"></a>表单安全性</h1><p><a href="http://www.htmlcssvqs.com/8ed/form-security/" target="_blank" rel="external">http://www.htmlcssvqs.com/8ed/form-security/</a>（跟 PHP 相关性更高点）</p>
<h1 id="表单标题描述"><a href="#表单标题描述" class="headerlink" title="表单标题描述"></a>表单标题描述</h1><ol>
<li>使用 h1 、 h2 标题</li>
<li>使用 legend 元素(如果使用必须是 fieldset 的第一个元素）</li>
<li>fieldset :用于将一套表单元素组合在一起.</li>
</ol>
<h1 id="legend元素"><a href="#legend元素" class="headerlink" title="legend元素"></a>legend元素</h1><ol>
<li>虽然 legend 元素可以提高表单的可访问性。</li>
<li>但是，这种行为在不同的屏幕阅读器和浏览器上并不完全一样，不同的模式下也不一样。</li>
<li>所以，考虑到以上这些问题，使用 h1 ～ h6 标题代替 legend 来识别一些（并非所有） fieldset ，就是一个明智的选择。</li>
<li>无论如何，对于单选按钮，最好总是使用 fieldset 和 legend 。</li>
</ol>
<h1 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h1><ul>
<li>必须为每个文本框设置 name 属性，只有在希望为文本框添加默认值的情况下才需要设置 value 属性。</li>
<li>文本框可选属性：<ol>
<li><code>placeholder=&quot;hinttext&quot;</code>，指导用户输入。</li>
<li><code>required=&quot;required&quot;</code>，仅在这个字段有值的情况下才能提交表单</li>
<li><code>autofocus或者autofocus=&quot;autofocus&quot;</code>，如果是第一个拥有这个属性的控件，input 会在页面加载时默认获得焦点。</li>
<li><code>size=&quot;n&quot;</code> 定义文本框大小，n是需要设置的文本框宽度，以字符为单位（也可以用CSS单独设置）默认值20。</li>
<li><code>maxlength=&quot;n&quot;</code>，n 是允许输入的最大字符数。</li>
<li><code>autocomplete=&quot;off/on&quot;</code>,保存用户所输入的内容并根据先前的表单输入给出一些包含同样字母的建议文本。可以作用与父元素 form 让所有子元素继承。</li>
</ol>
</li>
</ul>
<h1 id="分隔表单元素"><a href="#分隔表单元素" class="headerlink" title="分隔表单元素"></a>分隔表单元素</h1><p>分隔表单元素的方法在例子中大多数情况下使用 p 元素，嵌套 p 情况下使用 div 。并且都使用了 class=”row” 作为定义样式的钩子。</p>
<h1 id="label-元素"><a href="#label-元素" class="headerlink" title="label 元素"></a>label 元素</h1><p>标签（label）是描述表单字段用途的文本。</p>
<ul>
<li>for 属性：<br>  <code>for=&quot;idlabel&quot;</code>，利用 for 显示关联表单字段 (aka input)。<br>  例子：点击复选框的文本也可以勾选上。实现点击文本标签来修改状态。</li>
</ul>
<p>强烈推荐使用，对提升表单的可访问性和可用性有很重要的作用。</p>
<h1 id="id-、-for-和-name-属性的命名习惯"><a href="#id-、-for-和-name-属性的命名习惯" class="headerlink" title="id 、 for 和 name 属性的命名习惯"></a>id 、 for 和 name 属性的命名习惯</h1><ul>
<li>让for 、id 和 name 属性值都一样是一种并非必需但很常见的做法。单选按钮和复选框是例外。</li>
<li>对于包含多个单词的值， for 和 id 中使用连字符（-）分隔各个单词，name 中使用下划线（_）。<br>  例子：<code>for=&quot;first-name&quot;</code> 、 id=”first-name” 和 name=”first_name”</li>
<li>无论使用哪种方法，一定要保证 for 和 id 的值是一样的。</li>
</ul>
<h1 id="pattern-属性"><a href="#pattern-属性" class="headerlink" title="pattern 属性"></a>pattern 属性</h1><p>pattern 属性用于定制的验证规则。它使用正则表达式对用户在框中输入的内容进行限制。<br><a href="http://html5pattern.com/" target="_blank" rel="external">http://html5pattern.com/</a>——<strong>常用正则表达式</strong>。</p>
<h1 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h1><ol>
<li><strong>multiple</strong> 属性：用逗号分开，例如电子邮件框用逗号分开输入多个邮件地址。</li>
<li>WebKit 浏览器支持两个非官方 HTML5 属性： autosave 和 results 。</li>
<li>为 form 添加了 ARIA 地标角色 <strong>role=”search”</strong> 。这会让屏幕阅读器指出网页上有搜索区域，从而提高页面的可访问性。如果表单有多个控件而非只有搜索，就将与搜索相关的控件放在一个 fieldset 或div 中并为其添加 role=”search” ，而不是将 role=”search” 添加到 form 元素本身。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[target="_blank" 漏洞]]></title>
      <url>https://codingme.xyz/2016/08/30/target-blank-vulnerable/</url>
      <content type="html"><![CDATA[<h1 id="劫持手段"><a href="#劫持手段" class="headerlink" title="劫持手段"></a>劫持手段</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">/* pseudo url */</div><div class="line">window.opener.location = 'https://钓鱼网站.假/</div><div class="line">qq客服中奖.电脑一台/输入账号密码.领奖';</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>举例说明：</p>
<ol>
<li>如果<strong>页面一</strong>上有<code>target=&quot;_blank&quot;</code>没有script，新建窗口跳转到<strong>页面二</strong>，而<strong>页面二</strong>上有这段script的话：<ul>
<li>原本在后台作为后台标签页的<strong>页面一</strong>，会被重定向为<code>https://钓鱼网站.假/qq客服中奖.电脑一台/输入账号密码.领奖&#39;</code>的页面；</li>
</ul>
</li>
<li>如果<strong>页面一</strong>上有<code>target=&quot;_blank&quot;</code>而且有script，使用了<code>target=&quot;_blank&quot;</code>新建窗口跳转到其他没有script的页面的话：<ul>
<li><strong>页面一</strong>并不会有改变。</li>
</ul>
</li>
</ol>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><code>target=&quot;_blank&quot;</code>打开新页面实际上是要经由<code>window.opener</code>对象。<br>每次打开一个新窗口都要经由<code>window.open();</code></p>
<h1 id="劫持效果"><a href="#劫持效果" class="headerlink" title="劫持效果"></a>劫持效果</h1><p>结果：<br>`target=”_blank”的漏洞会影响新建窗口之前的页面一，使其重定向为script设置好的钓鱼网站。</p>
<p>实际例子demo：<br><a href="http://tvvocold.coding.me/target_blank_vulnerability/test.html/" target="_blank" rel="external">http://tvvocold.coding.me/target_blank_vulnerability/test.html/</a></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ul>
<li><p>对于使用了<code>target=&quot;_blank&quot;</code>的元素，使用rel属性：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*因为FireFox不支持noopener，所以添加了noreferrer*/</span></div><div class="line">rel=<span class="string">"noopener noreferrer"</span></div></pre></td></tr></table></figure>
</li>
<li><p>解决opener属性：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newWnd = <span class="built_in">window</span>.open();</div><div class="line">newWnd.opener = <span class="literal">null</span>;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《HTML5与CSS3基础教程》读书笔记3]]></title>
      <url>https://codingme.xyz/2016/08/29/html-css-diary-3/</url>
      <content type="html"><![CDATA[<h1 id="边距-简记法"><a href="#边距-简记法" class="headerlink" title="边距 简记法"></a>边距 简记法</h1><p><code>padding: 5px;</code>——使用一个值，这个值就会应用于全部四个边。<br><code>padding: 5px 9px;</code>——使用两个值，则前一个值会应用于上下两边，后一个值会应用于左右两边。<br><code>padding: 5px 9px 11px;</code>——使用三个值，则第一个值会应用于上边，第二个值会应用于左右两边，第三个值会应用于下边<br><code>padding: 5px 9px 11px 0;</code>——使用四个值，它们会按照时钟顺序，依次应用于上、右、下、左四个边.<br>应该也适用与 margin 。</p>
<h1 id="Bootstrap-3的-box-sizing"><a href="#Bootstrap-3的-box-sizing" class="headerlink" title="Bootstrap 3的 box-sizing"></a>Bootstrap 3的 box-sizing</h1><p>学习到 <code>box-sizing:border-box</code> 时候发现原来 <strong>Bootstrap 3</strong> 已经把所有的盒模型都设置成 border-box 了……将 box-sizing 属性设置为 border-box ，就可以很方便地对拥有水平方向内边距（使用 em 或其他的单位）的元素定义宽度，而不必进行复杂的数学计算来找出百分数的值。这对响应式页面来说很方便。所以 Bootstrap 3 才用了 border-box 吧。</p>
<h1 id="em-与-margin、padding"><a href="#em-与-margin、padding" class="headerlink" title="em 与 margin、padding"></a>em 与 margin、padding</h1><p>当 em 值用于内边距和外边距时，它的值是<strong>相对于元素的字体大小</strong>的，而不是相对于父元素的字体大小。</p>
<a id="more"></a>
<h1 id="clearfix-解决浮动后遗症"><a href="#clearfix-解决浮动后遗症" class="headerlink" title="clearfix 解决浮动后遗症"></a>clearfix 解决浮动后遗症</h1><ul>
<li>使用 float 浮动后，父元素高度为0，这样一来想给内容加背景色什么的很麻烦。解决方法：<br>  让容器自身具有清除浮动的能力。<br>  用所谓的 <strong>clearfix 方法</strong>（最可靠？）<br>  在 CSS 中引入规则，然后为浮动元素的父元素添加 clearfix 类，从而可以支撑起父元素，并能够添加一些预期样式。<br>  大量网站使用 clearfix 类或类似方法清除浮动。  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.clearfix:before,</div><div class="line">.clearfix:after &#123;</div><div class="line">content: " ";</div><div class="line">display: table;</div><div class="line">&#125;</div><div class="line">.clearfix:after &#123;</div><div class="line">clear: both;</div><div class="line">&#125;</div><div class="line">.clearfix &#123;</div><div class="line">*zoom: 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="另一种方法：-overflow-方法"><a href="#另一种方法：-overflow-方法" class="headerlink" title="另一种方法： overflow 方法"></a>另一种方法： overflow 方法</h1><p>通常，可以对浮动元素的父元素使用 overflow 属性以替代 clearfix 方法。例如，在示例页面中可以使用以下代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line"><span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在某些情况下， overflow: hidden; 会将内容<strong>截断</strong>，对此要多加注意。有时使用 overflow: auto; 也有效，但这样做可能会出现一个<strong>滚动条</strong>，这显然是我们不希望看到的。</li>
<li>可 以 将 clearfix 或 overflow 应用到浮动元素的任何一个非父元素的祖先元素。这样做不会让父元素变高，但祖先元素的高度会包含浮动元素。</li>
</ul>
<h1 id="position-relative"><a href="#position-relative" class="headerlink" title="position: relative"></a>position: relative</h1><ul>
<li><code>position: relative;</code>对元素进行<strong>相对定位</strong>,偏移自然流中元素。</li>
<li>使用相对定位、绝对定位或固定定位时，对于相互重叠的元素，可以用 <strong>z-index</strong> 属性指定它们的叠放次序。</li>
<li>对包含图标列表的父元素设置 <code>position: relative</code> ，从而让这些图标可以相对父元素（而不是 body 元素）进行绝对定位。</li>
</ul>
<h1 id="align-的基准线值"><a href="#align-的基准线值" class="headerlink" title="align 的基准线值"></a>align 的基准线值</h1><p>输入 <code>vertical-align:</code>  输入 <code>baseline</code> ，使元素的基准线对齐父元素的基准线；或者 <code>sub、super、text-top、text-bottom、top、bottom</code>。</p>
<h1 id="viewport-解决宽度问题"><a href="#viewport-解决宽度问题" class="headerlink" title="viewport 解决宽度问题"></a>viewport 解决宽度问题</h1><ul>
<li>解决浏览器视觉区域宽与屏幕宽度不同的一种快速解决方案：页面的 head 部分添加视觉区域 meta 元素 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</code></li>
<li><code>initial-scale=1</code> 的的意思：将页面的默认缩放级别设成 100%，换成纵向模式也一样。如果不设置 <code>initial-scale=1</code> ，在 iPhone 中，手机从纵向模式改为横向模式时，网页会被放大，从而让布局与纵向模式的一致。</li>
</ul>
<h1 id="font-简记法"><a href="#font-简记法" class="headerlink" title="font 简记法"></a>font 简记法</h1><ul>
<li><code>font:100%/1.2 ...</code> 行高1.2跟在字体大小100%和一个斜杠后面。</li>
<li><code>font: .875em/1.3 &quot;Palatino Linotype&quot;,Palatino, serif;</code></li>
</ul>
<h1 id="media-与响应式页面"><a href="#media-与响应式页面" class="headerlink" title="@media 与响应式页面"></a>@media 与响应式页面</h1><ul>
<li>响应式页面利用媒体查询器和百分比宽度  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*  30em（大于等于480px）</span></div><div class="line">----------------------------------- */</div><div class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">30em</span>) &#123;</div><div class="line">...  报头样式  ...</div><div class="line"><span class="selector-class">.post-photo</span> &#123;</div><div class="line"><span class="attribute">float</span>: left;</div><div class="line"><span class="attribute">margin-bottom</span>: <span class="number">2px</span>;</div><div class="line"><span class="attribute">margin-right</span>: <span class="number">22px</span>;</div><div class="line"><span class="attribute">max-width</span>: <span class="number">61.667%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.post-footer</span> &#123;</div><div class="line"><span class="attribute">clear</span>: left;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="响应式设计的旧版兼容"><a href="#响应式设计的旧版兼容" class="headerlink" title="响应式设计的旧版兼容"></a>响应式设计的旧版兼容</h1><ul>
<li><p>响应式设计要兼容旧版 IE 的话：</p>
<ul>
<li>移动优先方法，因为媒体查询器对 IE8 及以下的版本不支持。所以有3种解决方法：<ul>
<li>什么都不做。让网站显示基本的版本</li>
<li>为它们单独创建一个样式表，让它们显示网站最宽的版本。一种做法是复制一份常规的样式表，将其命名为 old-ie.css 之类的文件名。将媒体查询语句去掉，但保留其中的样式规则。在 HTML 中添加条件注释，从而让不同的浏览器都能找到正确的样式表：<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--</span></div><div class="line">第一个条件注释包含的是为 IE8 及更旧版本以外</div><div class="line">的所有浏览器准备的样式表。</div><div class="line">第二个包含的则是仅为 IE9 以下的IE 准备的样式表</div><div class="line">--&gt;</div><div class="line"><span class="comment">&lt;!--[if gt IE 8]&gt;&lt;!--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></div><div class="line"><span class="attr">href</span>=<span class="string">"css/styles.css"</span> /&gt;</div><div class="line"><span class="comment">&lt;!--&lt;![endif]--&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></div><div class="line">&lt;script src="js/respond.min.js"&gt;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如果希望页面有响应式的效果，就在页面中引入 respond.min.js。它让 min-width 和 max-width 媒体查询对旧版 IE 也有效。<a href="https://github.com/scottjehl/Respond/" target="_blank" rel="external">https://github.com/scottjehl/Respond/</a></p>
</li>
<li>第二种方法更可靠，它让 IE8 用户也能看到网站的完整布局。</li>
<li>如果使用 Sass、LESS 或 Stylus 这类 CSS 预处理器，就可以自动创建为旧版 IE 准备的样式表。地址：<a href="https://akearchibald.github.io/sass-ie/" target="_blank" rel="external">https://akearchibald.github.io/sass-ie/</a></li>
</ul>
<h1 id="Web-字体"><a href="#Web-字体" class="headerlink" title="Web 字体"></a>Web 字体</h1><ol>
<li>使用 Web 字体可能在它们显示到页面上之前，都需要下载到用户的计算机上。这会减慢网站加载的速度，尤其是对移动用户来说。所以审慎地选择 Web 字体。</li>
<li>每一个样式和粗细版本都会引入一个新的字体文件，从而增加浏览器要下载的文件大小，这会影响性能。出于这个原因，很多设计师仅对标题使用 Web 字体。</li>
<li>字体的常见分类：<ul>
<li>衬线字体（San）:衬线体的字体可以有效的转移视线，提高阅读速度，尤其在印刷品中效果非常明显。</li>
<li>无衬线体(Sans-serif):非衬线字体有着简单的风格，在网上或者银幕上表现效果都很好，能让画面感觉变得更清晰。</li>
<li>等宽字体（monospace）</li>
<li>梦幻字体（fantasy）</li>
<li>手写字体（cursive）</li>
</ul>
</li>
</ol>
<h1 id="IE-的-CSS-polyfill"><a href="#IE-的-CSS-polyfill" class="headerlink" title="IE 的 CSS polyfill"></a>IE 的 CSS polyfill</h1><ul>
<li>关于 IE，Jason Johnston 的 CSS3 PIE（<a href="http://css3pie.com/" target="_blank" rel="external">http://css3pie.com/</a> ）是一种最为常见的 <strong>polyfill</strong>。它为  Internet Explorer 6 ～ 9 提供了本章讨论的大部分 CSS 效果的支持。</li>
<li>CSS3 属性前缀可以用 Autoprefixer。</li>
</ul>
<h1 id="border-radius-的可能-bug"><a href="#border-radius-的可能-bug" class="headerlink" title="border-radius 的可能 bug"></a>border-radius 的可能 bug</h1><p>有时元素的背景（这里讲的不是子元素的背景）会透过其圆角。为了避免这种情况，可以在元素的 border-radius 声明后面增加一条样式规则： <code>background-clip: padding-box;</code>。</p>
<h1 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h1><p>允许使用两个可选的属性—— inset 关键字属性和 spread 属性（前者用于内阴影，后者用于扩张/收缩阴影）。</p>
<p>希望兼容浏览器，需要加 css 前缀（autoprefixer）:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-webkit-box-shadow</span>: <span class="selector-tag">x-offset</span> <span class="selector-tag">y-offset</span> <span class="selector-tag">blur-radius</span></div><div class="line"> <span class="selector-tag">inset</span> <span class="selector-tag">spread</span> <span class="selector-tag">color</span>(<span class="selector-tag">inset</span>内阴影);</div><div class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">x-offset</span> <span class="selector-tag">y-offset</span> <span class="selector-tag">blur-radius</span></div><div class="line"> <span class="selector-tag">spread</span> <span class="selector-tag">color</span> (<span class="selector-tag">inset</span>);</div><div class="line"><span class="selector-tag">box-shadow</span>:参数组1，参数组2(多重阴影);</div></pre></td></tr></table></figure>
<h1 id="HTML-多重背景"><a href="#HTML-多重背景" class="headerlink" title="HTML 多重背景"></a>HTML 多重背景</h1><p><code>background-image</code>、<code>background-position</code>、<code>background-repeat</code>等，用逗号分隔多个参数组；也可以用<code>background</code>简写。<br>其中<code>background-position:x-offset y-offset;</code><br>（实用性在哪…增加多个图片背景不是会增加HTTP请求么..）</p>
<h1 id="渐变背景"><a href="#渐变背景" class="headerlink" title="渐变背景"></a>渐变背景</h1><ul>
<li>先有<code>background</code>颜色（用于防止不支持的浏览器）</li>
<li>用<code>background-image</code>和<code>background</code>效果相同。</li>
<li><p>线性渐变：</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*关键字指定线性渐变的方向*/</span></div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">bottom</span> <span class="selector-tag">right</span>, <span class="selector-tag">aqua</span>, <span class="selector-tag">navy</span>);</div><div class="line"></div><div class="line"><span class="comment">/*指定角度*/</span></div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(290<span class="selector-tag">deg</span>, <span class="selector-tag">aqua</span>, <span class="selector-tag">navy</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>径向渐变:</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">使用渐变尺寸（长/宽），或者 closest-side 、</div><div class="line">farthest-side 、 closest-corner 或farthest-corner</div><div class="line">*/</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(100<span class="selector-tag">px</span> 50<span class="selector-tag">px</span>,<span class="selector-tag">yellow</span>, <span class="selector-tag">red</span>);</div><div class="line"></div><div class="line"><span class="comment">/*at决定渐变中心（关键字、x/y）：*/</span></div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">closest-side</span></div><div class="line"> <span class="selector-tag">at</span> 70<span class="selector-tag">px</span> 60<span class="selector-tag">px</span>, <span class="selector-tag">yellow</span>, <span class="selector-tag">lime</span>, <span class="selector-tag">red</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>考虑浏览器兼容情况加上 CSS 前缀。</p>
</li>
</ul>
<h1 id="opacity-的透明程度"><a href="#opacity-的透明程度" class="headerlink" title="opacity 的透明程度"></a>opacity 的透明程度</h1><ul>
<li>示例：<code>&lt;body&gt;</code>背景褐色;<code>&lt;div&gt;</code>背景黑色，里面有个<code>&lt;img&gt;</code>;对<code>&lt;div&gt;</code>使用opacity属性0.5，变半透明，整个<code>&lt;div&gt;</code>包括黑色背景都呈现褐色。如果对<code>&lt;img&gt;</code>使用，应该是图片半透明呈现黑色。</li>
<li>对于旧版IE:使用滤镜。  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line"><span class="attribute">-ms-filter</span>: progid:DXImageTransform.</div><div class="line"> Microsoft.<span class="built_in">Alpha</span>(opacity=50);</div><div class="line"><span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=50);</div><div class="line"><span class="attribute">opacity</span>: .<span class="number">5</span>;</div><div class="line"><span class="attribute">zoom</span>: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="CSS-生成内容"><a href="#CSS-生成内容" class="headerlink" title="CSS 生成内容"></a>CSS 生成内容</h1><ul>
<li>功能：<br>  使用生成内容可以添加符号、创建用于添加样式的空内容元素等。<br>  生成内容并不是为页面添加段落或标题。这些内容还是应该交给HTML。</li>
<li>示例：<br>  CSS 实现三角形:<a href="http://web.jobbole.com/87367/" target="_blank" rel="external">http://web.jobbole.com/87367/</a>。<br>  生成 CSS 三角形：<a href="http://www.cssarrowplease.com/" target="_blank" rel="external">http://www.cssarrowplease.com/</a>。</li>
<li>学习到的：<ol>
<li>伪元素 <code>:before</code> 和 <code>:after</code> ,都拥有 <code>position:absolute</code> 时候，<code>z-index</code> 值后者比前者高，或者说后者会覆盖前者。</li>
<li>伪类 <code>:focus</code> 要实现正常工作，对其元素使用 <code>tabindex=&quot;0&quot;</code> (例子中用的 <code>&lt;img&gt;</code>)<br><code>:focus</code> 伪类默认对链接和表单元素起作用。对于这些元素，不必添加 <code>tabindex=&quot;0&quot;</code> 。</li>
<li>tabindex 属性决定 tab 键在控件中的移动顺序。 tab 移动顺序根据 tabindex 值从大到小。</li>
</ol>
</li>
</ul>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>除了无序列表 ul 、有序列表 ol 外，还有个描述列表 dl 之前被称作定义列表。( dt 、 dd 为 dl 中的术语和描述）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《HTML5与CSS3基础教程》读书笔记2]]></title>
      <url>https://codingme.xyz/2016/08/29/html-css-diary-2/</url>
      <content type="html"><![CDATA[<h1 id="html的其他属性"><a href="#html的其他属性" class="headerlink" title="html的其他属性"></a>html的其他属性</h1><p>除非在 html 元素中添加 dir 属性并将属性值设为 rtl ，否则内容的基准方向都默认为从左至右。</p>
<h1 id="span-和-div"><a href="#span-和-div" class="headerlink" title="span 和 div"></a>span 和 div</h1><p>span 只适合<strong>包围字词或短语内容</strong>，而 div 适合<strong>包含块级内容</strong>。由于 span 没有任何语义，因此应将它作为最后的选择，仅在没有其他合适的元素时才使用它。</p>
<h1 id="bdo"><a href="#bdo" class="headerlink" title="bdo"></a>bdo</h1><p>bdo （ bidirectional override ，双向重载）:用于显式地格式化其内容的文本方向。<br>要使用 bdo ，必须包含 dir 属性并将属性值设为 ltr （由左至右）或 rtl （由右至左），指定你希望呈现的方向。(如果你的 HTML 页面中混合了从左至右书写的字符和从右至左书写的字符，就可能要用到 bdi 和 bdo 元素。)例子： <code>&lt;plang=&quot;he&quot;&gt;&lt;bdo dir=&quot;rtl&quot;&gt;...&lt;/bdo&gt;&lt;/p&gt;</code></p>
<h1 id="bdi-元素"><a href="#bdi-元素" class="headerlink" title="bdi 元素"></a>bdi 元素</h1><p>bdi 指的是 bidi 隔离（Bi-directional Isolation），用于标识独立于周围文本的用做双向文本格式化的一块文本。<br>bdi 元素是 HTML5 中新加的元素，用于内容的方向未知的情况。不必包含 dir 属性，因为默认已设为自动判断。例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>User <span class="tag">&lt;<span class="name">bdi</span>&gt;</span>jcranmer<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span>:</div><div class="line"> 12 posts.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>User <span class="tag">&lt;<span class="name">bdi</span>&gt;</span>hober<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span>:</div><div class="line"> 5 posts.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>User <span class="tag">&lt;<span class="name">bdi</span>&gt;</span>نا إي<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span>:</div><div class="line"> 3 posts.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="meter-元素"><a href="#meter-元素" class="headerlink" title="meter 元素"></a>meter 元素</h1><p>可以用 meter 元素表示<strong>分数的值或已知范围的测量结果</strong>。简单地说，它代表的是<strong>投票结果</strong>。HTML5 建议（并非强制）浏览器在呈现 meter 时，在旁边显示一个类似温度计的图形——一个表示测量值的横条，测量值的颜色与最大值的颜色有所区别（相等除外）。作为当前少数几个支持 meter 的浏览器，Firefox 正是这样显示的。对于不支持 meter 的浏览器，可以通过 CSS 对 meter 添加一些额外的样式，或用 JavaScript 进行改进。</p>
<ul>
<li><p>meter 元素代码示例：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Project completion status: <span class="tag">&lt;<span class="name">meter</span></span></div><div class="line"><span class="attr">value</span>=<span class="string">"0.80"</span>&gt;80% completed<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Car brake pad wear: <span class="tag">&lt;<span class="name">meter</span> <span class="attr">low</span>=</span></div><div class="line"><span class="string">"0.25"</span> <span class="attr">high</span>=<span class="string">"0.75"</span> <span class="attr">optimum</span>=<span class="string">"0"</span></div><div class="line"><span class="attr">value</span>=<span class="string">"0.21"</span>&gt;21% worn<span class="tag">&lt;/<span class="name">meter</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Miles walked during half-marathon:</div><div class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"13.1"</span> <span class="attr">value</span>=<span class="string">"5.5"</span></span></div><div class="line"><span class="attr">title</span>=<span class="string">"Miles"</span>&gt;4.5<span class="tag">&lt;/<span class="name">meter</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>已经有人试过针对支持 meter 的浏览器和不支持的浏览器统一编写 meter 的 CSS。在网上搜索“style HTML5 meter with CSS”（用CSS 为 HTML5 的 meter 添加样式），就可以找到一些解决方案（注意其中的一些用到了 JavaScript ）。meter 并不用于标记没有范围的普通测量值，如高度、宽度、距离、周长等。</p>
</li>
<li>一定不要将 meter 和 progress 元素混在一起使用。</li>
</ul>
<h1 id="progress-元素"><a href="#progress-元素" class="headerlink" title="progress 元素"></a>progress 元素</h1><p>progress 元素也是 HTML5 的新元素。前面说过，它指示<strong>某项任务的完成进度</strong>。它和 meter 元素一样，支持的会显示一个进度条，不支持的会显示文本。</p>
<ul>
<li>progress 代码示例：  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Current progress: <span class="tag">&lt;<span class="name">progress</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span>0% saved</div><div class="line"><span class="tag">&lt;/<span class="name">progress</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="rel-属性"><a href="#rel-属性" class="headerlink" title="rel 属性"></a>rel 属性</h1><ul>
<li><p>rel 属性是可选的，即便没有它，链接也能照常工作。但对于指向另一网站的链接，推荐包含这个值。它描述包含链接的页面和链接指向的页面之间的关系。它也是另一种提升 HTML 语义化程度的方式。搜索引擎也会利用这些信息。此外，还可以对带有 <code>rel=&quot;external&quot;</code> 的链接添加不同的样式，从而告知访问者这是一个指向外部网站的链接。对任何链接到站外页面的 a 元素（即外部链接）添加 <code>rel=&quot;external&quot;</code> 是非常好的习惯。</p>
</li>
<li><p>不管怎样，应避免使用“点击此处”作为标签。例如，应使用“了解我们的销售情况”，而不是“点击此处了解我们的销售情况”。</p>
</li>
<li><p>维 基 百 科 上 有 一 份 rel 值 的 列 表：<a href="http://microformats.org/wiki/existing-rel-values/" target="_blank" rel="external">http://microformats.org/wiki/existing-rel-values/</a>，该列表还在持续更新中。</p>
</li>
</ul>
<h1 id="target-属性"><a href="#target-属性" class="headerlink" title="target 属性"></a>target 属性</h1><p>target 属性不要在大多数情况下使用。首先，应该让用户决定是否在不同的窗口或标签页打开链接，而不是让 HTML 开发人员决定。</p>
<h1 id="CSS-层叠规则"><a href="#CSS-层叠规则" class="headerlink" title="CSS 层叠规则"></a>CSS 层叠规则</h1><p>CSS 用层叠的原则来考虑<strong>特殊性</strong>（specificity）、<strong>顺序</strong>（order）和<strong>重要性</strong>(importance），从而判断相互冲突的规则中哪个规则应该起作用。</p>
<h1 id="CSS3-新增颜色属性"><a href="#CSS3-新增颜色属性" class="headerlink" title="CSS3 新增颜色属性"></a>CSS3 新增颜色属性</h1><p>CSS3 中新增的颜色属性 HSL 相比 RGB 的优点是：<br>举例，从红变绿的话，HSL 更加的可预计，而且不需要更改原本的亮度。<br>HSL:<strong>色相</strong>(hue)/<strong>饱和度</strong>(saturation)/<strong>亮度</strong>(lightness)<br>例子:<br>红色为 hsl(0,100%,50%);<br>黄色为 hsl(60,100%,50%);<br>绿色为 hsl(120,100%,50%);<br>青色为 hsl(180,100%,50%);</p>
<h1 id="外部样式表与-import"><a href="#外部样式表与-import" class="headerlink" title="外部样式表与 @import"></a>外部样式表与 @import</h1><p>外部样式表要么是通过链接引用的，要么是导入的（通过 <code>@import</code> ），不过不推荐导入。 @import 指令会影响页面的下载速度和呈现速度，在 Internet Explorer 中影响更为明显。Web 性能专家 Steve Souders对此问题进行了讨论，参见<a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/" target="_blank" rel="external">http://www.stevesouders.com/blog/2009/04/09/dont-use-import/</a> 。建议不要使用 <code>@import</code> ，这主要是出于性能上的考虑。如果用了 <code>@import</code> ，当引入的样式后面有与之冲突的样式，则后出现的样式会覆盖这些引入的样式，与预期一致。</p>
<ul>
<li>外部样式表的另一个好处是，一旦浏览器在某个页面加载了它，在随后浏览引用它的页面时，通常无需再向 Web 服务器请求该文件。浏览器会将它保存到缓存里，也就是保存到用户的计算机里，并使用这个版本的文件。这样做可以加快对页面的加载。不过，不必担心。如果随后对样式表作了修改，再将它传到 Web 服务器，浏览器就会下载更新后的文件，而不是使用缓存的文件。</li>
</ul>
<h1 id="link-、-style-元素的开始标签"><a href="#link-、-style-元素的开始标签" class="headerlink" title="link 、 style 元素的开始标签"></a>link 、 style 元素的开始标签</h1><ul>
<li>HTML 早期版本要求在 link 元素定义中包含 <code>type=&quot;text/css&quot;</code> ，但 HTML5 不要求这样做。</li>
<li>HTML5 之前的版本要求在 style 开始标签中包含属性 <code>type=&quot;text/css&quot;</code> ，不过 HTML5 没有要求。</li>
<li>在 link 或 style 元素的开始标签中添加 <code>media=&quot;output&quot;</code>，其中 output 可以是 print 、screen 或 all （尽管还有其他一些选项，但这些是最常见的） 也可以在样式表中使用<code>@media</code>规则。这种方法不需要在 link 元素中指定媒体类型。</li>
<li>通过对 link 元素添加 media 属性，可以将样式表限于特定输出。使用浏览器查看页面时，style.css 会起作用（由于使用了 <code>media=&quot;screen&quot;</code>）；打印页面时，print.css 会起作用（由于使用了 <code>media=&quot;print&quot;</code> ）。</li>
</ul>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>可以在选择器中使用<strong>方括号</strong>添加关于目标元素的属性或值的信息：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://www.wikipedia.org"]</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>尽量不要使用<strong>ID选择器</strong>。</li>
<li>除非必须特别针对目标元素，最好不要在 id 或 class 选择器中添加元素名称。（像是<code>h1.news { color: red; }</code> ）</li>
<li>如果有样式冲突， .architect.bio 的规则的优先级比.architect或.bio的更高。</li>
<li>id选择器会引入下面两个问题:<ul>
<li>与它们关联的样式不能在其他元素上复用</li>
<li>它们的特殊性比 class 选择器要强得多。这意味着如果要覆盖使用 id选择器定义的样式，就要编写特殊性更强的CSS规则。</li>
</ul>
</li>
<li><p>.architect 和 p 之间的空格表示这个选择器会寻找任何作为 architect 类元素后代（无论是第几代）的 p 元素。</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.architect</span> <span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*得到相同效果的其他方式</span></div><div class="line">-------------------------------------- */</div><div class="line"><span class="comment">/* 是任意article祖先的所有p元素，</span></div><div class="line">这是三个中特殊性最低的一个 */</div><div class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 属于architect类article元素的祖先的任意p元</span></div><div class="line">素，是三个中特殊性最高的一个 */</div><div class="line"><span class="selector-tag">article</span><span class="selector-class">.architect</span> <span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这个选择器仅选择 architect 类元素的子元素（而非子子元素、子子子元素等）的 p 元素。包含于任何其他元素的 p 元素均不会被选中</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.architect</span> &gt; <span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通常最好保持较低的特殊性，让样式更易于复用。</p>
</li>
</ul>
<h1 id="，CSS-相邻同胞结合符"><a href="#，CSS-相邻同胞结合符" class="headerlink" title="+，CSS 相邻同胞结合符"></a>+，CSS 相邻同胞结合符</h1><p>CSS 相邻同胞结合符（adjacent sibling combinator）:只有直接跟在同胞 p 元素后面的 p 元素显示为红色。如果后面还有第三个、第四个以及更多的段落，它们也将显示为红色。例如，如果要对<strong>除第一个段落以外的所有段落进行缩进</strong>，相邻同胞结合符就很有用。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">architect</span> <span class="selector-tag">p</span>+<span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="，普通同胞结合符"><a href="#，普通同胞结合符" class="headerlink" title="~，普通同胞结合符"></a>~，普通同胞结合符</h1><p>我们也可能会用到普通同胞结合符，通过它可以选择那些并非直接出现在另一同胞元素后面的同胞元素。它与相邻同胞结合符的唯一区别是使用～（波浪号）代替 + 分隔同胞元素。例如， <code>h1 ～ h2 { color: red; }</code>会让<strong>任何属于同一父元素的同胞 h1 后面的 h2元素显示为红色（它们可以直接相邻，也可以不直接相邻）</strong>。</p>
<h1 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h1><p>选择第一个或最后一个子元素用 <code>:first-child</code> 和 <code>:last-child</code> 伪类。这些伪类选择的是作为第一个子元素或最后一个子元素的元素（在这个例子中就是 li ）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>仅仅使用 <code>:first-child { color: red; }</code> ，可以为任何作为另一个元素的第一个子元素的元素应用样式。</li>
<li>我们可以分别使用 <code>:first-letter</code> 和 <code>:first-line</code> 伪元素只选择元素的第一个字母或第一行。</li>
<li>第一个字母前面的标点符号（如引号）会被当做第一个字母的一部分，一同被格式化。现代浏览器都支持这一特性，但 IE8 之前的版本并不是这样做的，它将标点符号本身当做第一个字母。</li>
<li>在 CSS3 中， <code>:first-line</code> 的语法为 <code>::first-line</code> ， <code>:first-letter</code> 的语法为 <code>::first-letter</code> 。注意，它们用两个冒号代替了单个冒号。这样修改的目的是将<strong>伪元素</strong>（有四个，包 括 <code>::first-line</code> 、 <code>::first-letter</code> 、 <code>::before</code> 和 <code>::after</code> ） 与 <strong>伪类</strong>（ 如 <code>:first-child</code> 、<code>:link</code> 、 <code>:hover</code> 等）区分开。</li>
<li><strong>伪元素</strong>（pseudo-element）是 HTML 中并不存在的元素。例如，定义第一个字母或第一行文字时，并未在 HTML 中作相应的标记。它们是另一个元素（在本例中为 p 元素）的部分内容。</li>
<li><strong>伪类</strong>（pseudo-class）应用于一组 HTML 元素，而你无需在 HTML 代码中用类标记它们。例如，使用 <code>:first-child</code> 可以选择某元素的第一个子元素，你就不用写成<code>class=&quot;first-child&quot;</code></li>
<li>未来， <code>::first-line</code> 和 <code>::first-letter</code> 这样的双冒号语法是推荐的方式，现代浏览器也支持它们。原始的单冒号语法则被废弃了，但浏览器出于向后兼容的目的，仍然支持它们。不过，IE9 之前的 Internet Explorer 版本均不支持双冒号。因此，你可以选择继续使用单冒号语法，除非你为 IE8 及以下版本设置了单独的 CSS。</li>
<li>按状态选择链接元素<ul>
<li>输入 link 以设置从未被激活或指向，当前也没有被激活或指向的链接的外观</li>
<li>输入 visited 以设置访问者已激活过的链接的外观</li>
<li>输入 focus ，前提是链接是通过键盘选择并已准备好激活的(例如通过Tab键）</li>
<li>输入 hover 以设置光标指向链接时链接的外观</li>
<li>输入 active 以设置激活过的链接的外观（更准确应该是激活时，点击是active,松开后是visited)</li>
<li>要对链接指定样式，不一定要指定伪类，例如，使用 <code>a{color: red;}</code>会让链接的所有状态显示为同一种样式。不过，最好使用伪类区分不同状态的样式，这样做可以方便访问者。<ul>
<li>由于链接可能同时处于多种状态，且晚出现的规则会覆盖前面出现的规则，所以，一定要按照下面的顺序定义规则： <strong>link</strong> 、 <strong>visited</strong> 、<strong>focus</strong> 、 <strong>hover</strong> 、 <strong>active</strong> （ 缩 写 为 LVFHA）。一种助记口诀为“Lord Vader’s Former Handle Anakin”（达斯·维达的原名叫安纳金）</li>
<li>触屏设备（如智能手机和平板电脑）的浏览器没有桌面浏览器所具有的“鼠标悬停”（即 hover）状态。不过，在 iPhone 和 iPad 上，访问者激活链接时，确实会显示通过 :hover 指定的样式。其他设备的行为则不一而定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h1><ul>
<li><p>按属性选择元素</p>
<ul>
<li>方括号包围目标属性和目标属性值。这个例子中没有属性值，它选择的是所有具有 class属性的段落<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-attr">[class]</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>属性选择器</strong>参考表</p>
<ul>
<li>[attribute] 匹配指定属性，不论具体值是什么</li>
<li>[attribute=”value”] 完全匹配指定属性值</li>
<li>[attribute~=”value”] 属性值是以空格分隔的多个单词，其中有一个完全匹配指定值</li>
<li>[attribute|=”value”] 属性值以 value- 打头或匹配value</li>
<li>[attribute^=”value”] 属性值以 value 开头， value 为完整的单词或单词的一部分</li>
<li>[attribute$=”value”] 属性值以 value 结尾， value 为完整的单词或单词的一部分</li>
<li>[attribute*=”value”] 属性值为指定值的子字符串,属性值至少包含这里的 value 一次的元素将被选中。<ul>
<li>当前所有主流浏览器均支持按元素包含的属性（和属性值）选择元素。对于 CSS3 中新增的属性选择器，IE7 和 IE8 有一些异常。</li>
</ul>
</li>
</ul>
</li>
<li><p>指定元素组</p>
<ul>
<li>不同的选择器不一定非得单独成行，但很多编码人员都遵循这种惯例，易于阅读！<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span>,</div><div class="line"><span class="selector-tag">h2</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在这里有个疑问，尝试自问自答。<br>  问：用元素组选择器跟用同个 class 效果是差不多的，比如上面的 h1 , h2 ,可以都拥有相同 class 属性。那么怎么判断该用哪个呢？<br>  一句话总结：<strong>爱用哪个用哪个</strong>。<br>  与其考虑用哪个选择器的话，不如想想维护性，这点更重要。<br>  (选择器影响效率也是微乎其微..在选择器上优化得到的性能提升还没有合并一个 http 请求来得实在。)<br>  关于选择器效率有一点：选择器的匹配机制是从选择器的右边到左边进行读取的。<br>  选择器效率从高到低的排序列表:<br>  id选择器（#id）<br>  类选择器（.className）<br>  标签选择器（div,h1,p）<br>  相邻选择器（h1+p）<br>  子选择器（ul &gt; li）<br>  后代选择器（li a）<br>  通配符选择器（*）<br>  属性选择器（a[rel=”external”]）<br>  伪类选择器（a:hover,li:nth-child）</p>
</li>
</ul>
<h1 id="IE6-伪类和选择器兼容"><a href="#IE6-伪类和选择器兼容" class="headerlink" title="IE6 伪类和选择器兼容"></a>IE6 伪类和选择器兼容</h1><p>Selectivizr（<a href="http://selectivizr.com/" target="_blank" rel="external">http://selectivizr.com/</a> ）：这是“一个在 Internet Explorer 6 ～ 8 中模拟 CSS3 伪类和属性选择器的 JavaScript 工具”</p>
<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><ul>
<li>sans-serif、 cursive 、 fantasy 、 monospace 分别表示无衬线字体、手写字体、装饰字体和等宽字体。</li>
<li><a href="https://css-tricks.com/why-ems/" target="_blank" rel="external">https://css-tricks.com/why-ems/</a></li>
</ul>
<h1 id="文本大小写"><a href="#文本大小写" class="headerlink" title="文本大小写"></a>文本大小写</h1><ul>
<li>既然可以改变 HTML 里的文本，为什么还要用 text-transform 这类的 CSS 属性来修改文本显示呢？这是因为，有时，内容是你无法控制的。例如，内容可能存储在数据库里，或者来自另一个网站的新闻源。在这些情况下，只能通过 CSS 控制文本的大小写。搜索引擎通常是按它在 HTML 里输入的样子索引文本的，在搜索结果里显示标准的大小写会更容易阅读。</li>
<li>使用小型大写字母的方法:输入 <code>font-variant: small-caps</code>。与简单地缩小字号的大写字母相比，小型大写字母显得更为轻巧。</li>
<li><code>white-space: pre;</code> 输入 pre ，以让浏览器显示原文本中所有的空格和回车。或者输入 owrap ，确保所有空格不断行，也就是文本全部显示在一行；或者输入 normal ，按正常方式处理空格。</li>
</ul>
<h1 id="CSS-重置"><a href="#CSS-重置" class="headerlink" title="CSS 重置"></a>CSS 重置</h1><p>使用 CSS Reset 和 normalize.css 的原因：每个浏览器都有内置的默认样式表。 HTML 会遵照该样式表显示，除非你自己编写的 CSS 覆盖了它们。整体上，不同浏览器提供的默认样式表是相似的，但也存在一定的差异。为此，开发人员在应用他们自己的 CSS 之前，常常需要抹平这些差异。</p>
<h1 id="ul-与-inline-block"><a href="#ul-与-inline-block" class="headerlink" title="ul 与 inline-block"></a>ul 与 inline-block</h1><p>关于 inline-block 和 ul：让 ul 水平排列，如果对 li 用 inline-block 的话貌似会让 list-style-* 出现问题。</p>
<h1 id="兼容性-CSS-前缀"><a href="#兼容性-CSS-前缀" class="headerlink" title="兼容性 CSS 前缀"></a>兼容性 CSS 前缀</h1><p>带有-webkit- 和 -moz- 这些奇怪前缀的属性可以让这些规则在旧的 Android 和 iOS 设备上起作用，同时在Firefox 上也能正常工作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《HTML5与CSS3基础教程》读书笔记]]></title>
      <url>https://codingme.xyz/2016/08/07/html-css-diary/</url>
      <content type="html"><![CDATA[<h1 id="Web-设计-在线网址"><a href="#Web-设计-在线网址" class="headerlink" title="Web 设计 在线网址"></a>Web 设计 在线网址</h1><p><a href="http://designingfortheweb.co.uk/" target="_blank" rel="external">http://designingfortheweb.co.uk/</a><br>—— Mark Boulton</p>
<h1 id="article-元素"><a href="#article-元素" class="headerlink" title="article 元素"></a>article 元素</h1><p>article 元素表示文档、页面、应用或网站中<em>一个独立的容器</em>，原则上是可独立分配或可再用的，就像聚合内容中的各部分。它可以是一篇论坛帖子、一篇杂志或报纸文章、一篇博客条目、一则用户提交的评论、一个交互式的小部件或小工具，或者任何其他<strong>独立的内容项</strong>。</p>
<h1 id="section-元素"><a href="#section-元素" class="headerlink" title="section 元素"></a>section 元素</h1><p>section 元素代表文档或应用的<em>一个一般的区块</em>。如果只是出于添加样式的原因要对内容添加一个容器，应使用 div 而不是 section。在考虑何时使用 section 的时候，记住定义中“<strong>具有相似主题的一组内容</strong>”这一条是很有帮助的。这也是 section 区别于 div 的另一个原因。</p>
<h1 id="div-元素"><a href="#div-元素" class="headerlink" title="div 元素"></a>div 元素</h1><p>有关 div 的一些历史以及何时在 HTML5 中使用它:<br>在 HTML5 之前， div 是包围大块内容（如页眉、页脚、主要内容、插图、附注栏等）从而可用 CSS 为之添加样式的不二选择。之前 div 没有任何语义含义，现在也一样。 这就是 HTML5 引入 header 、 footer 、 main 、 article 、 section 、 aside 和 nav 的原因。这些类型的构造块在网页中普遍存在，因此它们可以成为具有独立含义的元素。在 HTML5 中，div 并没有消失，只是使用它的场合变少了。不过，可以肯定的是， div 应该作为最后一个备用容器，因为它没有任何语义价值。大多数时候，使用 header 、 footer 、 main （仅使用一次）、 article 、 section 、 aside 甚至 nav代替 div 会更合适。但是，如果语义上不合适，也不必为了刻意避免使用 div 而使用上述元素。有用得上 div 的地方，只是需要限制其使用。</p>
<a id="more"></a>
<h1 id="role-属性和-ARIA-地标角色"><a href="#role-属性和-ARIA-地标角色" class="headerlink" title="role 属性和 ARIA 地标角色"></a>role 属性和 ARIA 地标角色</h1><p>关于 role 属性和 ARIA 地标角色：<br>可用性专家 Steve Faulkner 对地标角色有详细的讲解，见 <a href="http://blog.paciellogroup.com/2013/02/using-wai-aria-landmarks-2013/" target="_blank" rel="external">http://blog.paciellogroup.com/2013/02/using-wai-aria-landmarks-2013/</a> 。他还引用了另一位专家 Léonie Watson 录制的演示屏幕阅读器用户访问页面行为的视频，推荐观看！<br>地标角色只是 ARIA 规范 <a href="http://www.w3.org/TR/wai-aria/" target="_blank" rel="external">http://www.w3.org/TR/wai-aria/</a> 众多特性中的一个。如果对相关的实施指南感兴趣，可以访问 <a href="http://www.w3.org/WAI/PF/aria-practices/" target="_blank" rel="external">http://www.w3.org/WAI/PF/aria-practices/</a>。<br>可以在 CSS 选择器中使用 ARIA 角色属性，从而对使用它们的元素添加样式。</p>
<h1 id="CSS-方面目的不推荐使用-id"><a href="#CSS-方面目的不推荐使用-id" class="headerlink" title="CSS 方面目的不推荐使用 id"></a>CSS 方面目的不推荐使用 id</h1><p>但一般不推荐出于添加样式的目的使用 id。推荐使用类为元素添加样式。在 class 和 id 名称中，通常使用短横线分隔多个单词，例如 <code>class=&quot;footer-page&quot;</code> 。</p>
<h1 id="em-元素、cite-元素"><a href="#em-元素、cite-元素" class="headerlink" title="em 元素、cite 元素"></a>em 元素、cite 元素</h1><p>em 元素用于<strong>标识强调的文本</strong>，cite 元素用于<strong>标识对艺术作品、电影、图书等内容的引用</strong>。</p>
<h1 id="b、i、em、strong"><a href="#b、i、em、strong" class="headerlink" title="b、i、em、strong"></a>b、i、em、strong</h1><ul>
<li>strong 元素表示<strong>内容的重要性</strong>，而 em 则表示<strong>内容的着重点</strong>。</li>
<li>不要使用 b 元素代替 strong ，也不要使用 i 元素代替 em 。尽管它们在浏览器中显示的样式是一样的，但它们的含义却很不一样。</li>
<li>旧版本HTML那时 strong 所表示文本的强调程度比 em 表示的文本要高。不过，在 HTML5 中， em 是<strong>表示强调的唯一元素</strong>，而 strong 表示的则是<strong>重要程度</strong>。</li>
<li>先一句话总结：HTML5 强调， <strong>b 和 i 应该是其他元素（如 strong 、 em 、 cite 等）都不适用时的最后选择</strong>。</li>
</ul>
<p>HTML5 将 b 重新定义为：<br>b 元素表示出于实用目的提醒读者注意的一块文字，不传达任何额外的重要性，也不表示其他的语态和语气，用于如<strong>文档摘要里的关键词</strong>、<strong>评论中的产品名</strong>、<strong>基于文本的交互式软件中指示操作的文字</strong>、<strong>文章导语</strong>等。<br>HTML5 将 i 重新定义为：<br>i 元素表示一块不同于其他文字的文字，具有不同的语态或语气，或其他不同于常规之处，用于如<strong>分类名称</strong>、<strong>技术术语</strong>、<strong>外语里的惯用语</strong>、<strong>翻译的散文</strong>、<strong>西方文字中的船舶名称</strong>等。</p>
<h1 id="small-元素"><a href="#small-元素" class="headerlink" title="small 元素"></a>small 元素</h1><p>small 表示细则一类的旁注（side comment），通常包括<strong>免责声明</strong>、<strong>注意事项</strong>、<strong>法律限制</strong>、<strong>版权信息</strong>等。有时我们还可以用它来<strong>表示署名</strong>，或者<strong>满足许可要求</strong>。用 small 标记页面的版权信息是一种常见的做法。不过，small <strong>只适用于短语</strong>，因此不要用它标记长的法律声明，如“使用条款”和“隐私政策”页面。</p>
<h1 id="em-和-cite-不能滥用"><a href="#em-和-cite-不能滥用" class="headerlink" title="em 和 cite 不能滥用"></a>em 和 cite 不能滥用</h1><p>内容显示的样子与为其使用的标记没有关系。因此，不应该为了让文字变为斜体就使用 em 或 cite ，添加样式是 CSS 的事情。</p>
<h1 id="del-、ins-和-s"><a href="#del-、ins-和-s" class="headerlink" title="del 、ins 和 s"></a>del 、ins 和 s</h1><p>标记不再准确或不再相关的文本用 &lt;s&gt; 。仅在有语义价值的时候使用 del 、ins 和 s 。如果只是出于装饰的原因要给文字添加下划线或删除线，可以用 CSS 实现这些效果。HTML5 指出：“ s 元素不适用于指示文档的编辑，要标记文档中一块已移除的文本，应使用 del 元素。”有时，这之间的差异是很微妙的，只能由你决定哪种选择更符合内容的语义。</p>
<h1 id="u-元素"><a href="#u-元素" class="headerlink" title="u 元素"></a>u 元素</h1><p>同 b 、 i 、 s 和 small 一样，HTML5 重新定义了 u 元素，使之不再是无语义的、用于表现的元素。以前， u 元素用来为文本添加下划线。现在， u 元素用于<strong>非文本注解</strong>。HTML5 对它的定义为：u 元素为一块文字添加明显的非文本注解，比如<strong>在中文中将文本标为专有名词（即中文的专名号,专名号用于表示人名、地名、朝代名等专名。）</strong>，或者<strong>标明文本拼写有误</strong>。</p>
<h1 id="figure-元素、aside-元素"><a href="#figure-元素、aside-元素" class="headerlink" title="figure 元素、aside 元素"></a>figure 元素、aside 元素</h1><p>figure：用于识别在主文档流内被引用，但在不影响文档流的情况下可以移至他处的内容。<br>对于与内容有关的<strong>图像</strong>（如图表、图形或带有说明文字的插图），使用 figure。<br>不要简单地将 figure 作为在文本中嵌入独立内容实例的方法。这种情况下，通常更适合用 aside 元素。<br>aside 元素：用于标识页面中的一个区域，其内容与周围的内容无关。</p>
<h1 id="time-元素、datetime-属性"><a href="#time-元素、datetime-属性" class="headerlink" title="time 元素、datetime 属性"></a>time 元素、datetime 属性</h1><p>time 元素<strong>标记时间、日期或时间段</strong>。datetime 属性不会单独产生任何效果，但它可以用于在 Web 应用（如日历应用）之间同步日期和时间。这就是必须使用标准的机器可读格式的原因，这样，程序之间就可以使用相同的“语言”来共享信息。<br>示例代码:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"1952-06-12T 11:05:00"</span>&gt;</span></div><div class="line">June 12, 1952 at 11:05 a.m.</div><div class="line"> <span class="tag">&lt;/<span class="name">time</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="abbr-元素"><a href="#abbr-元素" class="headerlink" title="abbr 元素"></a>abbr 元素</h1><p><code>&lt;abbr title=&quot;National Football League&quot;&gt;NFL&lt;/abbr&gt;</code><br>不必对每个<strong>缩写词</strong>都使用 abbr ，只在需要帮助访问者了解该词含义的时候使用。<br>作为对用户的视觉提示，Firefox 和Opera 等浏览器会对带 title 的 abbr 文字使用虚线下划线。<br>想在其他浏览器中对带 title 的 abbr 文字使用虚线下划线，可以在样式表中加上这条语句：<br><code>abbr[title] { border-bottom: 1px dotted#000; }</code><br>无论 abbr 是否添加了下划线样式，浏览器都会将 title 属性内容以提示框的形式显示出来。如果看不到 abbr 有虚线下划线，试着为其父元素的 CSS 添加 line-height 属性。</p>
<h1 id="dfn-元素"><a href="#dfn-元素" class="headerlink" title="dfn 元素"></a>dfn 元素</h1><p>dfn:Definition<br>在 HTML 中<strong>定义术语</strong>时，可以使用 dfn元素对其作语义上的区分。dfn 元素及其定义必须挨在一起，否则便是错误的用法。还可以在描述列表（ dl 元素）中使用 dfn 。例子： <code>&lt;dfn&gt;pleonasm&lt;/dfn&gt;means &quot;a redundant word or expression&quot;</code></p>
<h1 id="kbd、-samp-和-var"><a href="#kbd、-samp-和-var" class="headerlink" title="kbd、 samp 和 var"></a>kbd、 samp 和 var</h1><ol>
<li>kbd :标记用户输入指示。 <code>&lt;li&gt;Hit &lt;kbd&gt;RETURN&lt;/kbd&gt; or &lt;kbd&gt;ENTER&lt;/kbd&gt;&lt;/li&gt;</code></li>
<li>samp ：指示程序或系统的示例输出。 <code>&lt;samp&gt;Thanks for your order!&lt;/samp&gt;</code></li>
<li>var :表示变量或占位符的值。 <code>&lt;var&gt;E&lt;/var&gt; =&lt;var&gt;m&lt;/var&gt;&lt;var&gt;c&lt;/var&gt; &lt;sup&gt;2&lt;/sup&gt;</code></li>
</ol>
<h1 id="pre-元素"><a href="#pre-元素" class="headerlink" title="pre 元素"></a>pre 元素</h1><p>不要将 pre 作为逃避以合适的语义标记内容和用 CSS 控制样式的快捷方式。例如，如果你想发布一篇在字处理软件中写好的文章，不要为了保留原来的格式，简单地将它复制、粘贴到 pre 里。相反，应该使用 p（以及其他相关的文本元素）标记内容，编写 CSS 控制页面的布局。</p>
<h1 id="创建换行"><a href="#创建换行" class="headerlink" title="创建换行"></a>创建换行</h1><ul>
<li>要确保使用 br 是最后的选择，因为该元素将表现样式带入了 HTML，而不是让所有的呈现样式都交由 CSS 控制。例如，不要使用 br 模拟段落之间的距离。相反，应该用 p标记两个段落并通过 CSS 的 margin 属性规定两段之间的距离。实际上，对于诗歌、街道地址等应该紧挨着出现的短行，都适合用 br 元素。</li>
<li>要尽量避免使用 br ，除非没有更好的选择，因为这样做会在 HTML 中混合表现，而不是让 CSS 控制它。(让HTML负责内容，CSS负责样式/显示）</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQL的小注意事项]]></title>
      <url>https://codingme.xyz/2015/12/22/sql-tips/</url>
      <content type="html"><![CDATA[<h1 id="DISTINCT-和-GROUP-BY"><a href="#DISTINCT-和-GROUP-BY" class="headerlink" title="DISTINCT 和 GROUP BY"></a>DISTINCT 和 GROUP BY</h1><ul>
<li>使用GROUP BY子句时，SELECT子句中不能出现聚合键之外的列名；</li>
<li>GROUP BY子句结果的显示是无序的；</li>
<li>DISTINCT 和GROUP BY 子句都能删除后续列中的重复数据，除此之外，它们还都会把NULL作为一个独立的结果返回，对多列使用时也会得到完全相同的结果。其实不仅处理结果相同，执行速度也基本上差不多，到底该用哪一个呢？</li>
</ul>
<p>但其实这个问题本身就是本末倒置的，我们应该考虑的是该SELECT语句是否满足需求。选择的标准其实很简单：<br><strong>在“想要删除选择结果中的重复记录”时使用DISTINCT；在“想要计算聚合结果”时使用GROUP BY。</strong><br>不使用COUNT等聚合函数，而只使用GROUP BY子句的SELECT语句，会让人觉得非常奇怪。难免让人产生“到底为什么要对表进行分组呢？这样做有必要吗？”等疑问。</p>
<h1 id="HAVING-和-WHERE"><a href="#HAVING-和-WHERE" class="headerlink" title="HAVING 和 WHERE"></a>HAVING 和 WHERE</h1><ul>
<li>WHERE用例：“商品种类为衣服”、“销售单价在1000元以上”；<br>HAVING用例：“数据行数为2行”、“平均值为500”；【count、avg】</li>
<li>WHERE子句不能使用聚合函数。（只有SELECT子句和HAVING子句（以及ORDER BY子句）中能够使用聚合函数）。</li>
<li>WHERE子句只能指定记录（行）的条件，不能用来指定组的条件（例如，“数据行数为2行”或者“平均值为500”等）。<br>因此，对集合指定条件就需要使用HAVING子句。</li>
<li>HAVING子句能够使用:常数、聚合函数、聚合键。</li>
<li>有些条件既可以写在HAVING子句当中，又可以写在WHERE子句当中。这些条件就是 聚合键所对应的条件。</li>
</ul>
<a id="more"></a>
<ul>
<li><p>聚合键所对应的条件还是应该书写在WHERE子句中。<br>理由：</p>
<ol>
<li><p>WHERE子句和HAVING子句的作用不同。<br>　　WHERE子句 = 指定行所对应的条件<br>　　HAVING子句 = 指定组所对应的条件</p>
</li>
<li><p>与性能即执行速度有关系<br>　　通过WHERE子句指定条件时，由于排序之前就对数据进行了过滤，所以能够减少排序的数据量。但HAVING子句是在排序之后才对数据进行分组的，因此与在WHERE子句中指定条件比起来，需要排序的数据量就会多得多。<br>　　WHERE子句更具速度优势的另一个理由是，可以对WHERE子句指定条件所对应的列创建索引，这样也可以大幅提高处理速度。</p>
</li>
</ol>
</li>
</ul>
<h1 id="书写顺序与执行顺序"><a href="#书写顺序与执行顺序" class="headerlink" title="书写顺序与执行顺序"></a>书写顺序与执行顺序</h1><p>　　书写顺序：<br><strong>SELECT</strong> -&gt; <strong>FROM</strong> -&gt; <strong>WHERE</strong> -&gt; <strong>GROUP BY</strong> -&gt; <strong>HAVING</strong> -&gt; <strong>ORDER BY</strong><br>　　执行顺序：<br><strong>FROM</strong> -&gt; <strong>WHERE</strong> -&gt; <strong>GROUP BY</strong> -&gt; <strong>HAVING</strong> -&gt; <strong>SELECT</strong> -&gt; <strong>(DISTINCT)</strong> -&gt;<strong>ORDER BY</strong></p>
<h1 id="关于NULL"><a href="#关于NULL" class="headerlink" title="关于NULL"></a>关于NULL</h1><ol>
<li>所有包含NULL的计算，结果肯定是NULL.</li>
<li>比较运算符无法用于NULL，只能使用专门用来判断是否为NULL的运算符 <strong>IS NULL</strong></li>
<li>对NULL进行逻辑运算时，结果是SQL特有的第三种值——不确定（Unknown）.所以尽量不使用NULL,在创建表时，要给某些列设定NOT NULL约束的原因就在此.</li>
</ol>
<h1 id="SQL语句及其种类"><a href="#SQL语句及其种类" class="headerlink" title="SQL语句及其种类"></a>SQL语句及其种类</h1><ol>
<li>DDL(Data Definition Language，数据定义语言）<ul>
<li>CREATE</li>
<li>DROP</li>
<li>ALTER</li>
</ul>
</li>
<li>DML（Data Manipulation Language，数据操作语言）<ul>
<li>SELECT</li>
<li>INSERT</li>
<li>UPDATE</li>
<li>DELETE</li>
</ul>
</li>
<li>DCL（Data Control Language，数据控制语言）<ul>
<li>COMMIT</li>
<li>ROLLBACK</li>
<li>GRANT</li>
<li>REVOKE</li>
</ul>
</li>
</ol>
<h1 id="关于事务Transaction"><a href="#关于事务Transaction" class="headerlink" title="关于事务Transaction"></a>关于事务Transaction</h1><ol>
<li>事务处理何时开始？<br> 事务并没有标准的开始指令存在，而是根据DBMS的不同而不同。<br> 想Oracle这样不使用指令而悄悄开始事务的情况下，应该如何区分各个事务呢？<br> 通常有两种情况：<br> <strong>一、每条SQL语句就是一个事务（自动提交模式）。</strong><br> <strong>二、直到用户执行COMMIT或者ROLLBACK为止算作一个事务。</strong></li>
<li>自动模式情况下要特别注意DELETE语句，否则一旦误删回滚也无济于事。</li>
<li>ACID特性<ul>
<li><strong>原子性（Atomicity）</strong><br>  事务结束时，其中包含的DML语句更新处理，要么全部执行，要么全不执行的特性。</li>
<li><strong>一致性（Consistency）</strong><br>  事务中包含的处理，要满足数据库提前设置的约束。又称为完整性。（一旦其中一句语句违反约束，就会出错无法执行，整个事务的SQL语句都会被取消不执行。【原子性的体现】）<br>  (例子: INSERT INTO 表 SELECT * FROM 表。执行会因为主键重复失败）</li>
<li><strong>隔离性（Isolation）</strong><br>  保证不同事务之间互不干扰的特性。该特性保证了事务之间不会互相嵌套。在某个事务中进行的更改，在该事务结束之前，对其他事务而言是不可见的。</li>
<li><strong>持久性（Durability）</strong><br>  事务（无论是提交还是回滚）一旦结束，DBMS会保证该时点的数据状态得以保存的特性。即使由于系统故障导致数据丢失，数据库也一定能通过某些手段进行恢复。<br>  保证持久性的方法根据实现的不同而不同，最常见的是将事务的执行记录保存到硬盘等存储介质中（该执行记录称为日志）。当发生故障时，可以通过日志恢复到故障发生前的状态。</li>
</ul>
</li>
</ol>
<h1 id="关于视图"><a href="#关于视图" class="headerlink" title="关于视图"></a>关于视图</h1><ol>
<li>对多数DBMS来说，多重视图会降低SQL的性能。因此应该避免在视图的基础上创建视图。</li>
<li>视图的限制：<ul>
<li>定义视图时不能使用ORDER BY子句。<br>  因为视图和表一样，数据行都是没有顺序的。</li>
<li>如果定义视图的SELECT语句能够满足某些条件，那么这个视图就可以被更新，比较具有代表性的一些条件：<br>  <strong>一、</strong>SELECT子句中未使用DISTINCT<br>  <strong>二、</strong>FROM子句中只有一张表<br>  <strong>三、</strong>未使用GROUP BY子句<br>  原因：视图和表需要同事进行更新，因此通过聚合得到的视图无法进行更新。<br>  <strong>四、</strong>未使用HAVING子句</li>
</ul>
</li>
</ol>
<h1 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h1><ol>
<li>在细分的组内进行比较时，需要使用关联子查询。</li>
<li>结合条件一定要写在子查询中。<br> 例如： <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> ‘按分类的平均单价’</div><div class="line"><span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> 商品<span class="keyword">ID</span>, 商品名, 商品分类, 商品单价,</div><div class="line">(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(商品单价)</div><div class="line"><span class="keyword">FROM</span> 商品表 <span class="keyword">AS</span> S2</div><div class="line"><span class="keyword">WHERE</span> S1.商品分类=S2.商品分类</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 商品分类)</div><div class="line"><span class="keyword">AS</span> 商品分类_单价</div><div class="line"><span class="keyword">FROM</span> 商品表 <span class="keyword">AS</span> S1;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="EXISTS-与-IN"><a href="#EXISTS-与-IN" class="headerlink" title="EXISTS 与 IN"></a>EXISTS 与 IN</h1><p>EXISTS的特性：<br>通常指定关联子查询作为EXIST的参数;<br>作为EXISTS参数的子查询经常会使用SELECT *。</p>
<ol>
<li>一言以蔽之：<br> EXISTS与IN的使用效率的问题，通常情况下采用EXISTS要比IN效率高，因为IN不走索引，但要看实际情况具体使用：<br> <strong>IN适合于外表大而内表小的情况；</strong><br> <strong>EXISTS适合于外表小而内表大的情况。</strong></li>
<li>IN 是把外表和内表作hash 连接，而EXISTS是对外表作loop循环，每次loop循环再对内表进行查询。</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用EXISTS，子查询表小的用IN：<br> 例如：表A（小表），表B（大表）</li>
<li>NOT IN和NOT EXISTS<br> 如果查询语句使用了NOT IN，那么内外表都进行全表扫描，没有用到索引；<br>而NOT EXISTS的子查询依然能用到表上的索引。<br>所以无论哪个表大，用NOT EXISTS都比NOT IN要快。</li>
</ol>
<p>一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> A 【小】</div><div class="line"><span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B【大】)</div><div class="line"><span class="comment">--效率低，用到了A表上cc列的索引；</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> A 【小】</div><div class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B 【大】 <span class="keyword">WHERE</span> cc=A.cc)</div><div class="line"><span class="comment">--效率高，用到了B表上cc列的索引。</span></div></pre></td></tr></table></figure>
<p>二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> B 【大】</div><div class="line"><span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> A【小】)</div><div class="line"><span class="comment">--效率高，用到了B表上cc列的索引；</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> B 【大】</div><div class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> A【小】 <span class="keyword">where</span> cc=B.cc)</div><div class="line"><span class="comment">--效率低，用到了A表上cc列的索引。</span></div></pre></td></tr></table></figure>
<h1 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h1><p>应用于2张以上表的SQL语句</p>
<ul>
<li><p>UNION<br>  ——并集<br>注意事项：<br>作为运算对象的记录的列数必须相同；<br>作为运算对象的记录的列的数据类型必须相同；<br>可以使用任何SELECT语句，但ORDER BY语句只能在最后使用一次；<br>保留重复行使用ALL选项；</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line">  <span class="keyword">FROM</span> Shohin</div><div class="line"><span class="keyword">UNION</span></div><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line"> <span class="keyword">FROM</span> Shohin2</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> shohin_id;</div></pre></td></tr></table></figure>
</li>
<li><p>INTERSECT<br>  ——交集</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line">  <span class="keyword">FROM</span> Shohin</div><div class="line"><span class="keyword">INTERSECT</span></div><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line"> <span class="keyword">FROM</span> Shohin2</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> shohin_id;</div></pre></td></tr></table></figure>
</li>
<li><p>EXCEPT<br>  ——差集</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line">  <span class="keyword">FROM</span> Shohin</div><div class="line"><span class="keyword">EXCEPT</span></div><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line">  <span class="keyword">FROM</span> Shohin2</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> shohin_id;</div><div class="line"><span class="comment">--Shohin 减去 Shohin2.</span></div></pre></td></tr></table></figure>
</li>
<li><p>JOIN<br>  ——联结<br>一、INNER JOIN<br>内联结。<br>使用时SELECT子句中的列需要按照 &lt;表的别名&gt;.&lt;列名&gt; 的格式进行书写；<br>必须使用ON子句，书写在FROM和WHERE之间；</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TS.tenpo_id, TS.tenpo_mei,</div><div class="line">TS.shohin_id, S.shohin_mei, S.hanbai_tanka</div><div class="line"><span class="keyword">FROM</span></div><div class="line">TenpoShohin <span class="keyword">AS</span> TS</div><div class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></div><div class="line">Shohin <span class="keyword">AS</span> S</div><div class="line"><span class="keyword">ON</span> TS.shohin_id = S.shohin_id;</div></pre></td></tr></table></figure>
<p>  二、OUTER JOIN<br>  外联结。<br>  选出单张表中全部的信息，而不像内联结只选出同时存在于两张表中的数据；<br>  通过LEFT和RIGHT指定主表;</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TS.tenpo_id, TS.tenpo_mei,</div><div class="line">S.shohin_id, S.shohin_mei, S.hanbai_tanka</div><div class="line"><span class="keyword">FROM</span></div><div class="line">Shohin <span class="keyword">AS</span> S</div><div class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></div><div class="line">TenpoShohin <span class="keyword">AS</span> TS</div><div class="line"><span class="keyword">ON</span> TS.shohin_id = S.shohin_id;</div></pre></td></tr></table></figure>
<p>  三、多张表的联结</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--三张以上表的内联结</span></div><div class="line"><span class="keyword">SELECT</span> TS.tenpo_id, TS.tenpo_mei,</div><div class="line">TS.shohin_id, S.shohin_mei,</div><div class="line">S.hanbai_tanka, ZS.zaiko_suryo</div><div class="line"><span class="keyword">FROM</span> TenpoShohin <span class="keyword">AS</span> TS</div><div class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Shohin <span class="keyword">AS</span> S</div><div class="line"><span class="keyword">ON</span> TS.shohin_id = S.shohin_id</div><div class="line">   <span class="keyword">INNER</span> <span class="keyword">JOIN</span> ZaikoShohin <span class="keyword">AS</span> ZS</div><div class="line">      <span class="keyword">ON</span> TS.shohin_id = ZS.shohin_id</div><div class="line"><span class="keyword">WHERE</span> ZS.souko_id = <span class="string">'S001'</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>四、CROSS JOIN<br>——交叉联结。<br>表的笛卡尔集。<br>AXB={(a,b)|a属于A，b属于B}<br>内联结可以说是交叉联结的一部分，但是外联结不能说是“交叉联结结果之外的部分”，应该说是：<br>外联结 = 主表内所有数据（包括内联结和内联结之中不存在的主表信息【空白处用NULL补上】）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TS.tenpo_id, TS.tenpo_mei,</div><div class="line">TS.shohin_id, S.shohin_mei</div><div class="line"><span class="keyword">FROM</span> TenpoShohin <span class="keyword">AS</span> TS</div><div class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span></div><div class="line">Shohin <span class="keyword">AS</span> S;</div></pre></td></tr></table></figure>
<h1 id="过时语法"><a href="#过时语法" class="headerlink" title="过时语法"></a>过时语法</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TS.tenpo_id, TS.tenpo_mei,</div><div class="line">TS.shohin_id, S.shohin_mei, S.hanbai_tanka</div><div class="line">  <span class="keyword">FROM</span> TenpoShohin TS, Shohin S</div><div class="line"> <span class="keyword">WHERE</span> TS.shohin_id = S.shohin_id</div><div class="line">   <span class="keyword">AND</span> TS.tenpo_id = <span class="string">'000A'</span>;</div></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>无法马上判断出到底是内联结还是外联结又或者是其他类型的联结</li>
<li>由于联结条件都写在WHERE子句中，无法在短时间内分辨出哪部分是联结条件，哪部分是用来选取记录的限制条件</li>
<li>我们不知道这样的语法到底还能使用多久</li>
</ul>
<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><ol>
<li>COALESCE函数<br> 将NULL值变为其他值</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">COALESCE</span>（<span class="keyword">name</span>, <span class="string">'unknown'</span>) <span class="keyword">AS</span> <span class="keyword">name</span></div><div class="line"><span class="comment">--于是name中的NULL值就变成unknown了</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[递归的四条基本法则]]></title>
      <url>https://codingme.xyz/2015/12/06/recursion/</url>
      <content type="html"><![CDATA[<h1 id="基准情形"><a href="#基准情形" class="headerlink" title="基准情形"></a>基准情形</h1><p>必须总要有某些基准情形，它无须递归就能解出。</p>
<h1 id="不断推进"><a href="#不断推进" class="headerlink" title="不断推进"></a>不断推进</h1><p>对于那些需要递归求解的情形，每一次递归调用都必须要使状况朝向一种基准情形推进。</p>
<h1 id="设计法则。"><a href="#设计法则。" class="headerlink" title="设计法则。"></a>设计法则。</h1><p>假设所有的递归调用都能运行。</p>
<h1 id="合成效益法则。"><a href="#合成效益法则。" class="headerlink" title="合成效益法则。"></a>合成效益法则。</h1><p>在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。</p>
]]></content>
    </entry>
    
  
  
</search>
