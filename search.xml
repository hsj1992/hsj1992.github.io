<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十四章]]></title>
      <url>http://codingme.xyz/2016/10/19/javascript-note-14/</url>
      <content type="html"><![CDATA[<h1 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h1><h2 id="表单的基础知识"><a href="#表单的基础知识" class="headerlink" title="表单的基础知识"></a>表单的基础知识</h2><p>HTML 对应： <code>&lt;form&gt;</code>元素<br>JavaScript 对应：<code>HTMLFormElement</code> 类型<br>HTMLFormElement 继承 HTMLElement<br>自己的独有的属性和方法：</p>
<ul>
<li>acceptCharset：服务器能够处理的字符集；等价于HTML 中的accept-charset 特性。</li>
<li>action：接受请求的URL；等价于HTML 中的action 特性。</li>
<li>elements：表单中所有控件的集合（HTMLCollection）。</li>
<li>enctype：请求的编码类型；等价于HTML 中的enctype 特性。</li>
<li>length：表单中控件的数量。</li>
<li>method：要发送的HTTP 请求类型，通常是”get”或”post”；等价于HTML 的method 特性。</li>
<li>name：表单的名称；等价于HTML 的name 特性。</li>
<li>reset()：将所有表单域重置为默认值。</li>
<li>submit()：提交表单。</li>
<li>target：用于发送请求和接收响应的窗口名称；等价于HTML 的target 特性。</li>
</ul>
<p>取得<code>&lt;form&gt;</code>元素引用的方式有好几种。<br>其中最常见的方式就是将它看成与其他元素一样，并为其添加id 特性，然后再像下面这样使用getElementById()方法找到它。<br>其次，通过document.forms 可以取得页面中所有的表单。在这个集合中，可以通过数值索引或name 值来取得特定的表单。<br>另外，在较早的浏览器或者那些支持向后兼容的浏览器中，也会把每个设置了name 特性的表单作为属性保存在document 对象中(不推荐使用这种方式)。<br>可以同时为表单指定id 和name 属性，但它们的值不一定相同。<br><a id="more"></a></p>
<h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><p>用户单击提交按钮或图像按钮时，就会提交表单。<br>使用<code>&lt;input&gt;</code>或<code>&lt;button&gt;</code>都可以定义提交按钮，只要将其type 特性的值设置为”submit”即可。<br>图像按钮则是通过将<code>&lt;input&gt;</code>的type 特性值设置为”image”来定义的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 通用提交按钮 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit Form"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 自定义提交按钮 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 图像按钮 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"graphic.gif"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>只要表单中存在上面列出的任何一种按钮，那么在相应表单控件拥有焦点的情况下，按回车键就可以提交该表单。（textarea 是一个例外)<br>如果表单里没有提交按钮，按回车键不会提交表单。</p>
<p>浏览器会在将请求发送给服务器之前触发submit 事件。这样，我们就有机会验证表单数据，并据以决定是否允许表单提交。<br>阻止这个事件的默认行为就可以取消表单提交。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</div><div class="line">EventUtil.addHandler(form, <span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="comment">//取得事件对象</span></div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    <span class="comment">//阻止默认事件</span></div><div class="line">    EventUtil.preventDefault(event);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在JavaScript 中，以编程方式调用submit()方法也可以提交表单。<br>这种方式无需表单包含提交按钮，任何时候都可以正常提交表单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</div><div class="line"><span class="comment">//提交表单</span></div><div class="line">form.submit();</div></pre></td></tr></table></figure>
<p>提交表单时可能出现的最大问题，就是重复提交表单。<br>在第一次提交表单后，如果长时间没有反应，用户可能会变得不耐烦。<br>这时候，他们也许会反复单击提交按钮。结果往往很麻烦，或者会造成错误。<br>解决这一问题的办法有两个：<br>在第一次提交表单后就禁用提交按钮，<br>或者利用onsubmit 事件处理程序取消后续的表单提交操作。</p>
<h3 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h3><p>用户单击重置按钮时，表单会被重置。<br>使用type 特性值为”reset”的<code>&lt;input&gt;</code>或<code>&lt;button&gt;</code>都可以创建重置按钮。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 通用重置按钮 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"Reset Form"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 自定义重置按钮 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"reset"</span>&gt;</span>Reset Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在重置表单时，所有表单字段都会恢复到页面刚加载完毕时的初始值。<br>如果某个字段的初始值为空，就会恢复为空；而带有默认值的字段，也会恢复为默认值。</p>
<p>用户单击重置按钮重置表单时，会触发reset 事件。利用这个机会，我们可以在必要时取消重置操作。<br>与提交表单一样，也可以通过JavaScript 来重置表单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</div><div class="line">EventUtil.addHandler(form, <span class="string">"reset"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="comment">//取得事件对象</span></div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    <span class="comment">//阻止表单重置</span></div><div class="line">    EventUtil.preventDefault(event);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"myForm"</span>);</div><div class="line"><span class="comment">//重置表单</span></div><div class="line">form.reset();</div></pre></td></tr></table></figure>
<p>与调用submit()方法不同，调用reset()方法会像单击重置按钮一样触发reset 事件。<br>事实上，重置表单的需求是很少见的。更常见的做法是提供一个取消按钮，让用户能够回到前一个页面，而不是不分青红皂白地重置表单中的所有值。</p>
<h3 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h3><p>表单元素elements 属性，它是表单中所有表单元素（字段）的集合,是一个有序列表，<br>其中包含着表单中的所有字段，例如<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;button&gt;</code>和<code>&lt;fieldset&gt;</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十三章-8]]></title>
      <url>http://codingme.xyz/2016/10/18/javascript-note-13-8/</url>
      <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><p>也可以使用JavaScript 在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样。<br>在测试Web 应用程序，模拟触发事件是一种极其有用的技术。DOM2 级规范为此规定了模拟特定事件的方式，<br>IE9、Opera、Firefox、Chrome 和Safari 都支持这种方式。IE 有它自己模拟事件的方式。</p>
<h3 id="DOM中的事件模拟"><a href="#DOM中的事件模拟" class="headerlink" title="DOM中的事件模拟"></a>DOM中的事件模拟</h3><p>可以在document 对象上使用createEvent()方法创建event 对象。<br>接收一个参数，即表示要创建的事件类型的字符串。<br>在DOM2 级中，所有这些字符串都使用英文复数形式，而在DOM3级中都变成了单数。</p>
<ul>
<li>UIEvents：一般化的UI 事件。鼠标事件和键盘事件都继承自UI 事件。DOM3 级中是UIEvent。</li>
<li>MouseEvents：一般化的鼠标事件。DOM3 级中是MouseEvent。</li>
<li>MutationEvents：一般化的DOM 变动事件。DOM3 级中是MutationEvent。</li>
<li>HTMLEvents：一般化的HTML 事件。没有对应的DOM3 级事件（HTML 事件被分散到其他类别中）。</li>
</ul>
<p>“DOM2 级事件”并没有专门规定键盘事件，后来的“DOM3 级事件”中才正式将其作为一种事件给出规定。<br>在其他浏览器中，在现有方法的基础上，可以通过几种方式来模拟键盘事件。</p>
<p>模拟事件的最后一步就是触发事件。这一步需要使用dispatchEvent()方法，所有支持事件的DOM 节点都支持这个方法。<br>调用dispatchEvent()方法时，需要传入一个参数，即表示要触发事件的event 对象。<br><a id="more"></a></p>
<h4 id="模拟鼠标事件"><a href="#模拟鼠标事件" class="headerlink" title="模拟鼠标事件"></a>模拟鼠标事件</h4><p>createEvent()传入字符串”MouseEvents”。返回的对象有一个名为initMouseEvent()方法，用于指定与该鼠标事件有关的信息。<br>这个方法接收15 个参数，分别与鼠标事件中每个典型的属性一一对应。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>type（字符串）</td>
<td>表示要触发的事件类型，例如”click”</td>
</tr>
<tr>
<td>bubbles（布尔值）</td>
<td>表示事件是否应该冒泡。为精确地模拟鼠标事件，应该把这个参数设置为true</td>
</tr>
<tr>
<td>cancelable（布尔值）</td>
<td>表示事件是否可以取消。为精确地模拟鼠标事件，应该把这个参数设置为true</td>
</tr>
<tr>
<td>view（AbstractView）</td>
<td>与事件关联的视图。这个参数几乎总是要设置为document.defaultView</td>
</tr>
<tr>
<td>detail（整数）</td>
<td>与事件有关的详细信息。这个值一般只有事件处理程序使用，但通常都设置为0</td>
</tr>
<tr>
<td>screenX（整数）</td>
<td>事件相对于屏幕的X 坐标</td>
</tr>
<tr>
<td>screenY（整数）</td>
<td>事件相对于屏幕的Y 坐标</td>
</tr>
<tr>
<td>clientX（整数）</td>
<td>事件相对于视口的X 坐标</td>
</tr>
<tr>
<td>clientY（整数）</td>
<td>事件想对于视口的Y 坐标</td>
</tr>
<tr>
<td>ctrlKey（布尔值）</td>
<td>表示是否按下了Ctrl 键。默认值为false</td>
</tr>
<tr>
<td>altKey（布尔值）</td>
<td>表示是否按下了Alt 键。默认值为false</td>
</tr>
<tr>
<td>shiftKey（布尔值）</td>
<td>表示是否按下了Shift 键。默认值为false</td>
</tr>
<tr>
<td>metaKey（布尔值）</td>
<td>表示是否按下了Meta 键。默认值为false</td>
</tr>
<tr>
<td>button（整数）</td>
<td>表示按下了哪一个鼠标键。默认值为0</td>
</tr>
<tr>
<td>relatedTarget（对象）</td>
<td>表示与事件相关的对象。这个参数只在模拟mouseover 或mouseout时使用</td>
</tr>
</tbody>
</table>
<p>initMouseEvent()方法的这些参数是与鼠标事件的event 对象所包含的属性一一对应的。<br>前4 个参数对正确地激发事件至关重要，因为浏览器要用到这些参数；而剩下的所有参数只有在事件处理程序中才会用到。<br>剩下的所有参数只有在事件处理程序中才会用到。<br>当把event 对象传给dispatchEvent()方法时，这个对象的target属性会自动设置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line"><span class="comment">//创建事件对象</span></div><div class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"MouseEvents"</span>);</div><div class="line"><span class="comment">//初始化事件对象</span></div><div class="line">event.initMouseEvent(<span class="string">"click"</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</div><div class="line"><span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</div><div class="line"><span class="comment">//触发事件</span></div><div class="line">btn.dispatchEvent(event);</div></pre></td></tr></table></figure>
<p>在兼容DOM的浏览器中，也可以通过相同的方式来模拟其他鼠标事件（例如dblclick）。</p>
<h4 id="模拟键盘事件"><a href="#模拟键盘事件" class="headerlink" title="模拟键盘事件"></a>模拟键盘事件</h4><p>DOM3 级规定，调用createEvent()并传入”KeyboardEvent”就可以创建一个键盘事件。<br>返回的事件对象会包含一个initKeyEvent()方法。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>type（字符串）</td>
<td>表示要触发的事件类型，如”keydown”</td>
</tr>
<tr>
<td>bubbles（布尔值）</td>
<td>表示事件是否应该冒泡。为精确模拟键盘事件，应该设置为true</td>
</tr>
<tr>
<td>cancelable（布尔值）</td>
<td>表示事件是否可以取消。为精确模拟键盘事件，应该设置为true</td>
</tr>
<tr>
<td>view （AbstractView ）</td>
<td>与事件关联的视图。这个参数几乎总是要设置为document.defaultView</td>
</tr>
<tr>
<td>key（布尔值）</td>
<td>表示按下的键的键码</td>
</tr>
<tr>
<td>location（整数）</td>
<td>表示按下了哪里的键。0 表示默认的主键盘，1 表示左，2 表示右，3 表示数字键盘，4 表示移动设备（即虚拟键盘），5 表示手柄</td>
</tr>
<tr>
<td>modifiers（字符串）</td>
<td>空格分隔的修改键列表，如”Shift”</td>
</tr>
<tr>
<td>repeat（整数）</td>
<td>在一行中按了这个键多少次</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myTextbox"</span>),</div><div class="line">event;</div><div class="line"><span class="comment">//以DOM3 级方式创建事件对象</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"KeyboardEvents"</span>, <span class="string">"3.0"</span>))&#123;</div><div class="line">event = <span class="built_in">document</span>.createEvent(<span class="string">"KeyboardEvent"</span>);</div><div class="line"><span class="comment">//初始化事件对象</span></div><div class="line">event.initKeyboardEvent(<span class="string">"keydown"</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">document</span>.defaultView, <span class="string">"a"</span>,<span class="number">0</span>, <span class="string">"Shift"</span>, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//触发事件</span></div><div class="line">textbox.dispatchEvent(event);</div></pre></td></tr></table></figure>
<p>这个例子模拟的是按住Shift 的同时又按下A 键。</p>
<p>在使用document.createEvent(“KeyboardEvent”)之前，应该先检测浏览器是否支持DOM3 级事件；<br>其他浏览器返回一个非标准的KeyboardEvent 对象。<br>在Firefox 中，调用createEvent()并传入”KeyEvents”就可以创建一个键盘事件。<br>返回的事件对象包含的initKeyEvent()方法接受10 个参数。<br>在其他浏览器中，则需要创建一个通用的事件，然后再向事件对象中添加键盘事件特有的信息。</p>
<p>必须要使用通用事件，而不能使用UI 事件的原因是因为UI 事件不允许向event对象中再添加新属性（Safari 除外）。<br>像这样模拟事件虽然会触发键盘事件，但却不会向文本框中写入文本，这是由于无法精确模拟键盘事件所造成的。</p>
<h4 id="模拟其他事件"><a href="#模拟其他事件" class="headerlink" title="模拟其他事件"></a>模拟其他事件</h4><p>有时候同样需要模拟变动事件和HTML 事件。<br>要模拟变动事件， 可以使用createEvent(“MutationEvents”) 创建一个包含initMutationEvent() 方法的变动事件对象。<br>接受的参数包括： type 、bubbles 、cancelable、relatedNode、preValue、newValue、attrName 和attrChange。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"MutationEvents"</span>);</div><div class="line">event.initMutationEvent(<span class="string">"DOMNodeInserted"</span>, <span class="literal">true</span>, <span class="literal">false</span>, someNode, <span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="number">0</span>);</div><div class="line">target.dispatchEvent(event);</div></pre></td></tr></table></figure>
<p>要模拟HTML 事件，同样需要先创建一个event 对象——通过createEvent(“HTMLEvents”)，然后再使用这个对象的initEvent()方法来初始化它即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">"HTMLEvents"</span>);</div><div class="line">event.initEvent(<span class="string">"focus"</span>, <span class="literal">true</span>, <span class="literal">false</span>);</div><div class="line">targ et.dispatchEvent(event);</div></pre></td></tr></table></figure>
<h4 id="自定义DOM-事件"><a href="#自定义DOM-事件" class="headerlink" title="自定义DOM 事件"></a>自定义DOM 事件</h4><p>DOM3 级还定义了“自定义事件”。<br>不是由DOM 原生触发的，目的是让开发人员创建自己的事件。<br>调用createEvent(“CustomEvent”)。<br>返回的对象有一个名为initCustomEvent()的方法,接受type、bubbles、cancelable、detail 四种属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>),</div><div class="line">event;</div><div class="line">EventUtil.addHandler(div, <span class="string">"myevent"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">alert(<span class="string">"DIV: "</span> + event.detail);</div><div class="line">&#125;);</div><div class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"myevent"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">alert(<span class="string">"DOCUMENT: "</span> + event.detail);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"CustomEvents"</span>, <span class="string">"3.0"</span>))&#123;</div><div class="line">event = <span class="built_in">document</span>.createEvent(<span class="string">"CustomEvent"</span>);</div><div class="line">event.initCustomEvent(<span class="string">"myevent"</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"Hello world!"</span>);</div><div class="line">div.dispatchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>initCustomEvent()方法指定这个事件应该冒泡，所以浏览器会负责将事件向上冒泡到document。<br>支持自定义DOM事件的浏览器有IE9+和Firefox 6+。</p>
<h3 id="IE中的事件模拟"><a href="#IE中的事件模拟" class="headerlink" title="IE中的事件模拟"></a>IE中的事件模拟</h3><p>先创建event 对象，然后为其指定相应的信息，然后再使用该对象来触发事件。<br>当然，IE 在实现每个步骤时都采用了不一样的方式。</p>
<p>调用document.createEventObject()方法,不接受参数，结果会返回一个通用的event 对象。<br>必须手工为这个对象添加所有必要的信息（没有方法来辅助完成这一步骤）。<br>最后一步就是在目标上调用fireEvent()方法，这个方法接受两个参数：事件处理程序的名称和event 对象。<br>在调用fireEvent()方法时，会自动为event 对象添加srcElement 和type 属性；其他属性则都是必须通过手工添加的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line"><span class="comment">//创建事件对象</span></div><div class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEventObject();</div><div class="line"><span class="comment">//初始化事件对象</span></div><div class="line">event.screenX = <span class="number">100</span>;</div><div class="line">event.screenY = <span class="number">0</span>;</div><div class="line">event.clientX = <span class="number">0</span>;</div><div class="line">event.clientY = <span class="number">0</span>;</div><div class="line">event.ctrlKey = <span class="literal">false</span>;</div><div class="line">event.altKey = <span class="literal">false</span>;</div><div class="line">event.shiftKey = <span class="literal">false</span>;</div><div class="line">event.button = <span class="number">0</span>;</div><div class="line"><span class="comment">//触发事件</span></div><div class="line">btn.fireEvent(<span class="string">"onclick"</span>, event);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myTextbox"</span>);</div><div class="line"><span class="comment">//创建事件对象</span></div><div class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEventObject();</div><div class="line"><span class="comment">//初始化事件对象</span></div><div class="line">event.altKey = <span class="literal">false</span>;</div><div class="line">event.ctrlKey = <span class="literal">false</span>;</div><div class="line">event.shiftKey = <span class="literal">false</span>;</div><div class="line">event.keyCode = <span class="number">65</span>;</div><div class="line"><span class="comment">//触发事件</span></div><div class="line">textbox.fireEvent(<span class="string">"onkeypress"</span>, event);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十三章-7]]></title>
      <url>http://codingme.xyz/2016/10/18/javascript-note-13-7/</url>
      <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h3><h4 id="orientationchange-事件"><a href="#orientationchange-事件" class="headerlink" title="orientationchange 事件"></a>orientationchange 事件</h4><p>苹果公司为 移动Safari 添加，以便开发人员能够确定用户何时将设备由横向查看模式切换为纵向查看模式。<br>移动Safari 的window.orientation 属性中可能包含3 个值：<br>0 表示肖像模式，90 表示向左旋转的横向模式（“主屏幕”按钮在右侧），-90 表示向右旋转的横向模式（“主屏幕”按钮在左侧）。<br>相关文档中还提到一个值，即180 表示iPhone 头朝下；但这种模式至今尚未得到支持。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">    div.innerHTML = <span class="string">"Current orientation is "</span> + <span class="built_in">window</span>.orientation;</div><div class="line">    EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"orientationchange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        div.innerHTML = <span class="string">"Current orientation is "</span> + <span class="built_in">window</span>.orientation;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>所有iOS 设备都支持orientationchange 事件和window.orientation 属性。<br>可以将orientationchange 看成window 事件，所以也可以通过指定<code>&lt;body&gt;</code>元素的onorientationchange 特性来指定事件处理程序。<br><a id="more"></a></p>
<h4 id="MozOrientation-事件"><a href="#MozOrientation-事件" class="headerlink" title="MozOrientation 事件"></a>MozOrientation 事件</h4><p>已过时,从6.0版本起已经移除。由DeviceOrientationEvent替代。(而仅有Firefox支持)</p>
<h4 id="deviceorientation-事件"><a href="#deviceorientation-事件" class="headerlink" title="deviceorientation 事件"></a>deviceorientation 事件</h4><p>只能在移动WebKit 浏览器中运行，因为它使用了专有的webkitTransform 属性（即CSS标准属性transform 的临时版）。<br>所以只有Chrome、Android 浏览器部分支持。</p>
<h4 id="devicemotion-事件"><a href="#devicemotion-事件" class="headerlink" title="devicemotion 事件"></a>devicemotion 事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"devicemotion"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>);</div><div class="line">    <span class="keyword">if</span> (event.rotationRate !== <span class="literal">null</span>)&#123;</div><div class="line">        output.innerHTML += <span class="string">"Alpha="</span> + event.rotationRate.alpha + <span class="string">", Beta="</span> +</div><div class="line">            event.rotationRate.beta + <span class="string">", Gamma="</span> +</div><div class="line">            event.rotationRate.gamma;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>acceleration：一个包含x、y 和z 属性的对象，在不考虑重力的情况下，告诉你在每个方向上的加速度。</li>
<li>accelerationIncludingGravity：一个包含x、y 和z 属性的对象，在考虑z 轴自然重力加速度的情况下，告诉你在每个方向上的加速度。</li>
<li>interval：以毫秒表示的时间值，必须在另一个devicemotion 事件触发前传入。这个值在每个事件中应该是一个常量。</li>
<li>rotationRate：一个包含表示方向的alpha、beta 和gamma 属性的对象。</li>
</ul>
<p>如果读取不到acceleration、accelerationIncludingGravity 和rotationRate 值，则它们的值为null。<br>因此，在使用这三个属性之前，应该先检测确定它们的值不是null。</p>
<p>浏览器支持情况与deviceorientation事件类似。</p>
<h3 id="触摸与手势事件"><a href="#触摸与手势事件" class="headerlink" title="触摸与手势事件"></a>触摸与手势事件</h3><h4 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h4><ul>
<li>touchstart：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。</li>
<li>touchmove：当手指在屏幕上滑动时连续地触发。在这个事件发生期间，调用preventDefault()可以阻止滚动。</li>
<li>touchend：当手指从屏幕上移开时触发。</li>
<li>touchcancel：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。</li>
</ul>
<p>这几个事件都会冒泡，也都可以取消。<br>提供属性：<br>bubbles、cancelable、view、clientX、clientY、screenX、screenY、detail、altKey、shiftKey、ctrlKey 和metaKey。<br>还包括：</p>
<ul>
<li>touches：表示当前跟踪的触摸操作的Touch 对象的数组。</li>
<li>targetTouchs：特定于事件目标的Touch 对象的数组。</li>
<li>changeTouches：表示自上次触摸以来发生了什么改变的Touch 对象的数组。</li>
</ul>
<p>每个Touch 对象包含下列属性。</p>
<ul>
<li>clientX：触摸目标在视口中的x 坐标。</li>
<li>clientY：触摸目标在视口中的y 坐标。</li>
<li>identifier：标识触摸的唯一ID。</li>
<li>pageX：触摸目标在页面中的x 坐标。</li>
<li>pageY：触摸目标在页面中的y 坐标。</li>
<li>screenX：触摸目标在屏幕中的x 坐标。</li>
<li>screenY：触摸目标在屏幕中的y 坐标。</li>
<li>target：触摸的DOM 节点目标。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTouchEvent</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="comment">//只跟踪一次触摸</span></div><div class="line">    <span class="keyword">if</span> (event.touches.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">var</span> output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>);</div><div class="line">        <span class="keyword">switch</span>(event.type)&#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"touchstart"</span>:</div><div class="line">                output.innerHTML = <span class="string">"Touch started ("</span> + event.touches[<span class="number">0</span>].clientX +</div><div class="line">                    <span class="string">","</span> + event.touches[<span class="number">0</span>].clientY + <span class="string">")"</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"touchend"</span>:</div><div class="line">                output.innerHTML += <span class="string">"&lt;br&gt;Touch ended ("</span> +</div><div class="line">                    event.changedTouches[<span class="number">0</span>].clientX + <span class="string">","</span> +</div><div class="line">                    event.changedTouches[<span class="number">0</span>].clientY + <span class="string">")"</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"touchmove"</span>:</div><div class="line">                event.preventDefault(); <span class="comment">//阻止滚动</span></div><div class="line">                output.innerHTML += <span class="string">"&lt;br&gt;Touch moved ("</span> +</div><div class="line">                    event.changedTouches[<span class="number">0</span>].clientX + <span class="string">","</span> +</div><div class="line">                    event.changedTouches[<span class="number">0</span>].clientY + <span class="string">")"</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"touchstart"</span>, handleTouchEvent);</div><div class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"touchend"</span>, handleTouchEvent);</div><div class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"touchmove"</span>, handleTouchEvent);</div></pre></td></tr></table></figure>
<p>跟踪屏幕上发生的一次触摸操作。为简单起见，只会在有一次活动触摸操作的情况下输出信息。<br>当touchstart 事件发生时，会将触摸的位置信息输出到<code>&lt;div&gt;</code>元素中。<br>当touchmove 事件发生时，会取消其默认行为，阻止滚动（触摸移动的默认行为是滚动页面），然后输出触摸操作的变化信息。<br>而touchend 事件则会输出有关触摸操作的最终信息。<br>在touchend 事件发生时，touches集合中就没有任何Touch 对象了，因为不存在活动的触摸操作；<br>此时，就必须转而使用changeTouchs集合。<br>这些事件会在文档的所有元素上面触发，因而可以分别操作页面的不同部分。<br>(1) touchstart<br>(2) mouseover<br>(3) mousemove（一次）<br>(4) mousedown<br>(5) mouseup<br>(6) click<br>(7) touchend</p>
<h4 id="手势事件"><a href="#手势事件" class="headerlink" title="手势事件"></a>手势事件</h4><p>iOS 2.0 中的Safari 还引入了一组手势事件。<br>(之后没其他浏览器支持，也没有继续更新)</p>
<h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><p>在创建GUI 的语言（如C#）中，为GUI 中的每个按钮添加一个onclick事件处理程序是司空见惯的事，而且这样做也不会导致什么问题。<br>可是在JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。<br>首先，每个函数都是对象，都会占用内存；<br>内存中的对象越多，性能就越差。<br>其次，必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>对“事件处理程序过多”问题的解决方案就是事件委托。利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<p>例如，click 事件会一直冒泡到document 层次。也就是说，我们可以为整个页面指定一个onclick 事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myLinks"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"goSomewhere"</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"sayHi"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>按照传统的做法，需要像下面这样为它们添加3 个事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> item1 = <span class="built_in">document</span>.getElementById(<span class="string">"goSomewhere"</span>);</div><div class="line"><span class="keyword">var</span> item2 = <span class="built_in">document</span>.getElementById(<span class="string">"doSomething"</span>);</div><div class="line"><span class="keyword">var</span> item3 = <span class="built_in">document</span>.getElementById(<span class="string">"sayHi"</span>);</div><div class="line">EventUtil.addHandler(item1, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    location.href = <span class="string">"http://www.wrox.com"</span>;</div><div class="line">&#125;);</div><div class="line">EventUtil.addHandler(item2, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">document</span>.title = <span class="string">"I changed the document's title"</span>;</div><div class="line">&#125;);</div><div class="line">EventUtil.addHandler(item3, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"hi"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以利用事件委托技术解决这个问题。<br>使用事件委托，只需在DOM 树中尽量最高的层次上添加一个事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"myLinks"</span>);</div><div class="line">EventUtil.addHandler(list, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</div><div class="line">    <span class="keyword">switch</span>(target.id)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"doSomething"</span>:</div><div class="line">            <span class="built_in">document</span>.title = <span class="string">"I changed the document's title"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"goSomewhere"</span>:</div><div class="line">            location.href = <span class="string">"http://www.wrox.com"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"sayHi"</span>:</div><div class="line">            alert(<span class="string">"hi"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用事件委托只为<code>&lt;ul&gt;</code>元素添加了一个onclick 事件处理程序。<br>由于所有列表项都是这个元素的子节点，而且它们的事件会冒泡，所以单击事件最终会被这个函数处理。<br>事件目标是被单击的列表项，故而可以通过检测id 属性来决定采取适当的操作。<br>与前面未使用事件委托的代码比一比，会发现这段代码的事前消耗更低，因为只取得了一个DOM 元素，只添加了一个事件处理程序。<br>虽然对用户来说最终的结果相同，但这种技术需要占用的内存更少。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术。</p>
<p>如果可行的话，也可以考虑为document 对象添加一个事件处理程序，用以处理页面上发生的某种特定类型的事件。<br>这样做与采取传统的做法相比具有如下优点。</p>
<ul>
<li>document 对象很快就可以访问，而且可以在页面生命周期的任何时间点上为它添加事件处理程序<br>  （无需等待DOMContentLoaded 或load 事件）。换句话说，只要可单击的元素呈现在页面上，就可以立即具备适当的功能。</li>
<li>在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的DOM 引用更少，所花的时间也更少。</li>
<li>整个页面占用的内存空间更少，能够提升整体性能。</li>
</ul>
<p>最适合采用事件委托技术的事件包括click、mousedown、mouseup、keydown、keyup 和keypress。<br>虽然mouseover 和mouseout 事件也冒泡，但要适当处理它们并不容易，而且经常需要计算元素的位置。<br>（因为当鼠标从一个元素移到其子节点时，或者当鼠标移出该元素时，都会触发mouseout 事件。）</p>
<h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><p>除了事件委托，在不需要的时候移除事件处理程序，也是解决问题的一种方案。</p>
<p>内存中留有那些过时不用的“空事件处理程序”（dangling event handler），也是造成Web 应用程序内存与性能问题的主要原因。<br>造成这问题的第一种情况就是从文档中移除带有事件处理程序的元素时。<br>这可能是通过纯粹的DOM操作，例如使用removeChild()和replaceChild()方法，但更多地是发生在使用innerHTML 替换页面中某一部分的时候。<br>如果带有事件处理程序的元素被innerHTML 删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">id</span>=<span class="string">"myBtn"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">            <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//先执行某些操作</span></div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = <span class="string">"Processing..."</span>; <span class="comment">//麻烦了！</span></div><div class="line">&#125;;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>有一个按钮被包含在<code>&lt;div&gt;</code>元素中。为避免双击，单击这个按钮时就将按钮移除并替换成一条消息；<br>这是网站设计中非常流行的一种做法。但问题在于，当按钮被从页面中移除时，它还带着一个事件处理程序。<br>在<code>&lt;div&gt;</code>元素上设置innerHTML 可以把按钮移走，但事件处理程序仍然与按钮保持着引用关系。</p>
<p>有的浏览器（尤其是IE）在这种情况下不会作出恰当地处理，它们很有可能会将对元素和对事件处理程序的引用都保存在内存中。<br>如果你知道某个元素即将被移除，那么最好手工移除事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//省略部分代码</span></div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//先执行某些操作</span></div><div class="line">    btn.onclick = <span class="literal">null</span>; <span class="comment">//移除事件处理程序</span></div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = <span class="string">"Processing..."</span>;</div><div class="line">    &#125;;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>在事件处理程序中删除按钮也能阻止事件冒泡。目标元素在文档中是事件冒泡的前提。<br>采用事件委托也有助于解决这个问题。</p>
<p>导致“空事件处理程序”的另一种情况，就是卸载页面的时候。<br>IE8 及更早版本在这种情况下依然是问题最多的浏览器，尽管其他浏览器或多或少也有类似的问题。<br>如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中。<br>每次加载完页面再卸载页面时（可能是在两个页面间来回切换，也可以是单击了“刷新”按钮），内存中滞留的对象数目就会增加，<br>因为事件处理程序占用的内存并没有被释放。</p>
<p>一般来说，最好的做法是在页面卸载之前，先通过onunload 事件处理程序移除所有事件处理程序。<br>事件委托技术再次表现出它的优势——需要跟踪的事件处理程序越少，移除它们就越容易。</p>
<p>对这种类似撤销的操作，我们可以把它想象成：只要是通过onload 事件处理程序添加的东西，最后都要通过onunload 事件处理程序将它们移除。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十三章-6]]></title>
      <url>http://codingme.xyz/2016/10/18/javascript-note-13-6/</url>
      <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="HTML5-事件"><a href="#HTML5-事件" class="headerlink" title="HTML5 事件"></a>HTML5 事件</h3><p>DOM 规范没有涵盖所有浏览器支持的所有事件。</p>
<h4 id="contextmenu-事件"><a href="#contextmenu-事件" class="headerlink" title="contextmenu 事件"></a>contextmenu 事件</h4><p>Windows 95 在PC 中引入了上下文菜单的概念，即通过单击鼠标右键可以调出上下文菜单。<br>如何屏蔽与该操作关联的默认上下文菜单。<br>为解决这个问题，就出现了contextmenu 这个事件，用以表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。<br>(所以这是屏蔽鼠标右键、更改鼠标右键显示内容所使用的事件？)<br>由于contextmenu 事件是冒泡的，因此可以为document 指定一个事件处理程序，用以处理页面中发生的所有此类事件。<br>这个事件的目标是发生用户操作的元素。</p>
<p>在所有浏览器中都可以取消这个事件：<br>在兼容DOM的浏览器中，使用event.preventDefalut()；<br>在IE 中，将event.returnValue 的值设置为false。</p>
<p>因为contextmenu 事件属于鼠标事件，所以其事件对象中包含与光标位置有关的所有属性。<br>通常使用contextmenu 事件来显示自定义的上下文菜单，而使用onclick 事件处理程序来隐藏该菜单。<br><a id="more"></a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>ContextMenu Event Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Right click or Ctrl+click me to get a custom context menu.</div><div class="line">            Click anywhere else to get the default context menu.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myMenu"</span> <span class="attr">style</span>=<span class="string">"position:absolute;visibility:hidden;background-color:silver"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.nczonline.net"</span>&gt;</span>Nicholas’ site<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.wrox.com"</span>&gt;</span>Wrox site<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.yahoo.com"</span>&gt;</span>Yahoo!<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里的<code>&lt;div&gt;</code>元素包含一个自定义的上下文菜单。其中，<code>&lt;ul&gt;</code>元素作为自定义上下文菜单，并且在初始时是隐藏的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">    EventUtil.addHandler(div, <span class="string">"contextmenu"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        event = EventUtil.getEvent(event);</div><div class="line">        EventUtil.preventDefault(event);</div><div class="line">        <span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">"myMenu"</span>);</div><div class="line">        menu.style.left = event.clientX + <span class="string">"px"</span>;</div><div class="line">        menu.style.top = event.clientY + <span class="string">"px"</span>;</div><div class="line">        menu.style.visibility = <span class="string">"visible"</span>;</div><div class="line">    &#125;);</div><div class="line">    EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"myMenu"</span>).style.visibility = <span class="string">"hidden"</span>;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为<code>&lt;div&gt;</code>元素添加了oncontextmenu 事件的处理程序。这个事件处理程序首先会取消默认行为，以保证不显示浏览器默认的上下文菜单。<br>然后，再根据event 对象clientX 和clientY 属性的值，来确定放置<code>&lt;ul&gt;</code>元素的位置。<br>最后一步就是通过将visibility 属性设置为”visible”来显示自定义上下文菜单。<br>为document 添加了一个onclick 事件处理程序，以便用户能够通过鼠标单击来隐藏菜单(单击也是隐藏系统上下文菜单的默认操作)。<br>支持contextmenu 事件的浏览器有IE、Firefox、Safari、Chrome 和Opera 11+。</p>
<h4 id="beforeunload-事件"><a href="#beforeunload-事件" class="headerlink" title="beforeunload 事件"></a>beforeunload 事件</h4><p>之所以有发生在window 对象上的beforeunload 事件，是为了让开发人员有可能在页面卸载前阻止这一操作。<br>这个事件会在浏览器卸载页面之前触发，可以通过它来取消卸载并继续使用原有页面。<br>但是，不能彻底取消这个事件，因为那就相当于让用户无法离开当前页面了。</p>
<p>这个事件的意图是将控制权交给用户。显示的消息会告知用户页面行将被卸载(正因为如此才会显示这个消息)，询问用户是否真的要关闭页面，还是希望继续留下来。(也就是可以设置关闭提示框：“您是否真的要离开该网页？”)</p>
<p>为了显示这个弹出对话框，必须将event.returnValue 的值设置为要显示给用户的字符串(对IE 及Fiefox 而言)，<br>同时作为函数的值返回(对Safari 和Chrome 而言)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"beforeunload"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    <span class="keyword">var</span> message = <span class="string">"I'm really going to miss you if you go."</span>;</div><div class="line">    event.returnValue = message;</div><div class="line">    <span class="keyword">return</span> message;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>IE 和Firefox、Safari 和Chrome 都支持beforeunload 事件，也都会弹出这个对话框询问用户是否真想离开。Opera 11 及之前的版本不支持beforeunload 事件。</p>
<h4 id="DOMContentLoaded-事件"><a href="#DOMContentLoaded-事件" class="headerlink" title="DOMContentLoaded 事件"></a>DOMContentLoaded 事件</h4><p>window 的load 事件会在页面中的一切都加载完毕时触发，但这个过程可能会因为要加载的外部资源过多而颇费周折。<br>而DOMContentLoaded 事件则在形成完整的DOM 树之后就会触发，<br>不理会图像、JavaScript 文件、CSS 文件或其他资源是否已经下载完毕。<br>DOMContentLoaded 支持在页面下载的早期添加事件处理程序，这也就意味着用户能够尽早地与页面进行交互。<br>要处理DOMContentLoaded 事件，可以为document 或window 添加相应的事件处理程序(尽管这个事件会冒泡到window，但它的目标实际上是document)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Content loaded"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>DOMContentLoaded 事件对象不会提供任何额外的信息(其target 属性是document)。<br>IE9+、Firefox、Chrome、Safari 3.1+和Opera 9+都支持DOMContentLoaded 事件，通常这个事件既可以添加事件处理程序，也可以执行其他DOM 操作。<br>这个事件始终都会在load 事件之前触发。<br>对于不支持DOMContentLoaded 的浏览器，我们建议在页面加载期间设置一个时间为0 毫秒的超时调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//在此添加事件处理程序</span></div><div class="line">&#125;, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>这段代码的实际意思就是：“在当前JavaScript 处理完成后立即运行这个函数。”<br>在页面下载和构建期间，只有一个JavaScript 处理过程，因此超时调用会在该过程结束时立即触发。<br>至于这个时间与DOMContentLoaded 被触发的时间能否同步，主要还是取决于用户使用的浏览器和页面中的其他代码。<br>为了确保这个方法有效，必须将其作为页面中的第一个超时调用；即便如此，也还是无法保证在所有环境中该超时调用一定会早于load 事件被触发。</p>
<h4 id="readystatechange-事件"><a href="#readystatechange-事件" class="headerlink" title="readystatechange 事件"></a>readystatechange 事件</h4><p>IE 为DOM文档中的某些部分提供了readystatechange 事件。<br>这个事件的目的是提供与文档或元素的加载状态有关的信息，但这个事件的行为有时候也很难预料。<br>readyState 属性:</p>
<ul>
<li>uninitialized(未初始化)：对象存在但尚未初始化。</li>
<li>loading(正在加载)：对象正在加载数据。</li>
<li>loaded(加载完毕)：对象加载数据完成。</li>
<li>interactive(交互)：可以操作对象了，但还没有完全加载。</li>
<li>complete(完成)：对象已经加载完毕。</li>
</ul>
<p>这些状态看起来很直观，但并非所有对象都会经历readyState 的这几个阶段。如果某个阶段不适用某个对象，则该对象完全可能跳过该阶段；并没有规定哪个阶段适用于哪个对象。<br>这意味着readystatechange 事件经常会少于4 次，而readyState 属性的值也不总是连续的。<br>对于document 而言，值为”interactive”的readyState 会在与DOMContentLoaded 大致相同的时刻触发readystatechange 事件。<br>此时，DOM树已经加载完毕，可以安全地操作它了，因此就会进入交互(interactive)阶段。但与此同时，图像及其他外部文件不一定可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"readystatechange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">"interactive"</span>)&#123;</div><div class="line">        alert(<span class="string">"Content loaded"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个事件的event 对象不会提供任何信息，也没有目标对象。<br>在与load 事件一起使用时，无法预测两个事件触发的先后顺序。<br>在包含较多或较大的外部资源的页面中，会在load 事件触发之前先进入交互阶段；<br>而在包含较少或较小的外部资源的页面中，则很难说readystatechange 事件会发生在load 事件前面。<br>让问题变得更复杂的是，交互阶段可能会早于也可能会晚于完成阶段出现，无法确保顺序。<br>因此，为了尽可能抢到先机，有必要同时检测交互和完成阶段。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"readystatechange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">"interactive"</span> || <span class="built_in">document</span>.readyState == <span class="string">"complete"</span>)&#123;</div><div class="line">        EventUtil.removeHandler(<span class="built_in">document</span>, <span class="string">"readystatechange"</span>, <span class="built_in">arguments</span>.callee);</div><div class="line">        alert(<span class="string">"Content loaded"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当readystatechange 事件触发时，会检测document.readyState 的值，看当前是否已经进入交互阶段或完成阶段。如果是，则移除相应的事件处理程序以免在其他阶段再执行。<br>由于事件处理程序使用的是匿名函数，因此这里使用了arguments.callee 来引用该函数。</p>
<p>然后，会显示一个警告框，说明内容已经加载完毕。这样编写代码可以达到与使用DOMContentLoaded十分相近的效果。<br>支持readystatechange 事件的浏览器有IE、Firfox 4+和Opera。</p>
<p>虽然使用readystatechange 可以十分近似地模拟DOMContentLoaded 事件，<br>但它们本质上还是不同的。在不同页面中，load 事件与readystatechange 事件并不能保证以相同的顺序触发。</p>
<p><code>&lt;script&gt;</code>(在IE 和Opera 中)和<code>&lt;link&gt;</code>(仅IE 中)元素也会触发readystatechange事件，可以用来确定外部的JavaScript 和CSS 文件是否已经加载完成。</p>
<p>与在其他浏览器中一样，除非把动态创建的元素添加到页面中， 否则浏览器不会开始下载外部资源。</p>
<p>基于元素触发的readystatechange 事件也存在同样的问题， 即readyState 属性无论等于”loaded” 还是”complete”都可以表示资源已经可用。有时候，readyState 会停在”loaded”阶段而永远不会“完成”；有时候，又会跳过”loaded”阶段而直接“完成”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    EventUtil.addHandler(script, <span class="string">"readystatechange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        event = EventUtil.getEvent(event);</div><div class="line">        <span class="keyword">var</span> target = EventUtil.getTarget(event);</div><div class="line">        <span class="keyword">if</span> (target.readyState == <span class="string">"loaded"</span> || target.readyState == <span class="string">"complete"</span>)&#123;</div><div class="line">            EventUtil.removeHandler(target, <span class="string">"readystatechange"</span>, <span class="built_in">arguments</span>. callee);</div><div class="line">            alert(<span class="string">"Script Loaded"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    script.src = <span class="string">"example.js"</span>;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为新创建的<code>&lt;script&gt;</code>节点指定了一个事件处理程序。<br>事件的目标是该节点本身，因此当触发readystatechange 事件时， 要检测目标的readyState 属性是不是等于”loaded” 或”complete”。<br>如果进入了其中任何一个阶段，则移除事件处理程序(以防止被执行两次)，并显示一个警告框。与此同时，就可以执行已经加载完毕的外部文件中的函数了。<br>同样的编码方式也适用于通过<code>&lt;link&gt;</code>元素加载CSS 文件的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</div><div class="line">    link.type = <span class="string">"text/css"</span>;</div><div class="line">    link.rel= <span class="string">"stylesheet"</span>;</div><div class="line">    EventUtil.addHandler(script, <span class="string">"readystatechange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        event = EventUtil.getEvent(event);</div><div class="line">        <span class="keyword">var</span> target = EventUtil.getTarget(event);</div><div class="line">        <span class="keyword">if</span> (target.readyState == <span class="string">"loaded"</span> || target.readyState == <span class="string">"complete"</span>)&#123;</div><div class="line">            EventUtil.removeHandler(target, <span class="string">"readystatechange"</span>, <span class="built_in">arguments</span>. callee);</div><div class="line">            alert(<span class="string">"CSS Loaded"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    link.href = <span class="string">"example.css"</span>;</div><div class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(link);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最重要的是要一并检测readyState 的两个状态，并在调用了一次事件处理程序后就将其移除。</p>
<h4 id="pageshow-和pagehide-事件"><a href="#pageshow-和pagehide-事件" class="headerlink" title="pageshow 和pagehide 事件"></a>pageshow 和pagehide 事件</h4><p>“往返缓存”(back-forward cache，或bfcache)，可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。<br>这个缓存中不仅保存着页面数据，还保存了DOM 和JavaScript 的状态；实际上是将整个页面都保存在了内存里。<br>指定了onunload 事件处理程序的页面会被自动排除在 bfcache 之外，即使事件处理程序是空的。</p>
<p>纠错：</p>
<blockquote><p>“我猜测是火狐在开发过程中发现，保存js和Dom状态这事有点像是热心办了坏事，还弄得开发者多加些逻辑，后来就索性，不再保存js和Dom状态，只是存资源(html内容，css，js…)，这样呢，开发者只要还继续用load/unload事件就能万事大吉。至于《Javascritp高级程序设计》的错误，书始终是前端界的好书，出书的时候这玩意还是正常的。”</p>
<footer><strong>草依山</strong><cite><a href="http://jser.me/2012/09/22/BFcache%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF.html" target="_blank" rel="external">BFcache是什么东西</a></cite></footer></blockquote>
<h4 id="hashchange-事件"><a href="#hashchange-事件" class="headerlink" title="hashchange 事件"></a>hashchange 事件</h4><p>HTML5 新增，以便在URL 的参数列表（及URL 中“#”号后面的所有字符串）发生变化时通知开发人员。<br>(在Ajax 应用中，开发人员经常要利用URL 参数列表来保存状态或导航信息。)</p>
<p>必须要把hashchange 事件处理程序添加给window 对象，然后URL 参数列表只要变化就会调用它。<br>此时的event 对象应该额外包含两个属性：oldURL 和newURL。<br>这两个属性分别保存着参数列表变化前后的完整URL。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"hashchange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Old URL: "</span> + event.oldURL + <span class="string">"\nNew URL: "</span> + event.newURL);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>支持hashchange 事件的浏览器有IE8+、Firefox 3.6+、Safari 5+、Chrome 和Opera 10.6+。<br>只有Firefox 6+、Chrome 和Opera 支持oldURL 和newURL 属性。<br>为此，最好是使用location对象来确定当前的参数列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"hashchange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Current hash: "</span> + location.hash);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>检测浏览器是否支持hashchange 事件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isSupported = (<span class="string">"onhashchange"</span> <span class="keyword">in</span> <span class="built_in">window</span>) &amp;&amp; (<span class="built_in">document</span>.documentMode === <span class="literal">undefined</span> || <span class="built_in">document</span>.documentMode &gt; <span class="number">7</span>);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十三章-5]]></title>
      <url>http://codingme.xyz/2016/10/16/javascript-note-13-5/</url>
      <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><h4 id="键码"><a href="#键码" class="headerlink" title="键码"></a>键码</h4><p>在发生keydown 和keyup 事件时，event 对象的keyCode 属性中会包含一个代码，与键盘上一个特定的键对应。<br>对数字字母字符键，keyCode 属性的值与ASCII 码中对应小写字母或数字的编码相同。<br>数字键7 的keyCode 值为55，而字母A 键的keyCode 值为65——与Shift 键的状态无关。<br>DOM 和IE 的event 对象都支持keyCode 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myText"</span>);</div><div class="line">EventUtil.addHandler(textbox, <span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    alert(event.keyCode);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>用户每次在文本框中按键触发keyup 事件时，都会显示keyCode 的值。<br>无论keydown 或keyup 事件都会存在的一些特殊情况。<br>在Firefox 和Opera 中，按分号键时keyCode值为59，也就是ASCII 中分号的编码；但IE 和Safari 返回186，即键盘中按键的键码。<br><a id="more"></a></p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>发生keypress 事件意味着按下的键会影响到屏幕中文本的显示。<br>在所有浏览器中，按下能够插入或删除字符的键都会触发keypress 事件；按下其他键能否触发此事件因浏览器而异。<br>IE9、Firefox、Chrome 和Safari 的event 对象都支持一个charCode 属性，<br>这个属性只有在发生keypress 事件时才包含值，而且这个值是按下的那个键所代表字符的ASCII 编码。<br>此时的keyCode通常等于0 或者也可能等于所按键的键码。<br>IE8 及之前版本和Opera 则是在keyCode 中保存字符的ASCII编码。<br>要想以跨浏览器的方式取得字符编码，必须首先检测charCode 属性是否可用，如果不可用则使用keyCode。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    <span class="comment">//省略的代码</span></div><div class="line">    getCharCode: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> event.charCode == <span class="string">"number"</span>)&#123;</div><div class="line">            <span class="keyword">return</span> event.charCode;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> event.keyCode;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//省略的代码</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>先检测charCode 属性是否包含数值(在不支持这个属性的浏览器中，值为undefined)，<br>否则，就返回keyCode 属性值。<br>在取得了字符编码之后，就可以使用String.fromCharCode()将其转换成实际的字符。</p>
<h4 id="DOM3-级变化"><a href="#DOM3-级变化" class="headerlink" title="DOM3 级变化"></a>DOM3 级变化</h4><p>DOM3级事件中的键盘事件，不再包含charCode 属性，而是包含两个新属性：key 和char。<br>key 属性是为了取代keyCode 而新增的，它的值是一个字符串。<br>在按下某个字符键时，key的值就是相应的文本字符(如“k”或“M”)；<br>在按下非字符键时， key 的值是相应键的名(如“Shift”或“Down”)<br>而char 属性在按下字符键时的行为与key 相同，但在按下非字符键时值为null。</p>
<p>IE9 支持key 属性，但不支持char 属性。Safari 5 和Chrome 支持名为keyIdentifier 的属性，<br>在按下非字符键(例如Shift)的情况下与key 的值相同。</p>
<p>由于存在跨浏览器问题，因此本书不推荐使用key、keyIdentifier 或char。</p>
<p>DOM3 级事件还添加了一个名为location 的属性，这是一个数值，表示按下了什么位置上的键：<br>0 表示默认键盘，1 表示左侧位置(例如左位的Alt 键)，2 表示右侧位置(例如右侧的Shift 键)，<br>3 表示数字小键盘，4 表示移动设备键盘(也就是虚拟键盘)，5 表示手柄(如任天堂Wii 控制器)。<br>IE9 支持这个属性。Safari 和Chrome 支持名为keyLocation 的等价属性，但即有bug——值始终是0，除非按下了数字键盘(此时，值 为3)；否则，不会是1、2、4、5。</p>
<p>与key 属性一样，支持location 的浏览器也不多，所以在跨浏览器开发中不推荐使用。<br>最后是给event 对象添加了getModifierState()方法。<br>这个方法接收一个参数，即等于Shift、Control、AltGraph 或Meta 的字符串，表示要检测的修改键。<br>如果指定的修改键是活动的(也就是处于被按下的状态)，这个方法返回true，否则返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myText"</span>);</div><div class="line">EventUtil.addHandler(textbox, <span class="string">"keypress"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    <span class="keyword">if</span> (event.getModifierState)&#123;</div><div class="line">        alert(event.getModifierState(<span class="string">"Shift"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>实际上，通过event 对象的shiftKey、altKey、ctrlKey 和metaKey 属性已经可以取得类似的属性了。<br>IE9 是唯一支持getModifierState()方法的浏览器。</p>
<h4 id="textInput-事件"><a href="#textInput-事件" class="headerlink" title="textInput 事件"></a>textInput 事件</h4><p>“DOM3 级事件”规范中引入了一个新事件，名叫textInput。<br>根据规范，当用户在可编辑区域中输入字符时，就会触发这个事件。<br>这个用于替代keypress 的textInput 事件的行为稍有不同。<br>区别之一就是任何可以获得焦点的元素都可以触发keypress 事件，但只有可编辑区域才能触发textInput事件。<br>区别之二是textInput 事件只会在用户按下能够输入实际字符的键时才会被触发，而keypress事件则在按下那些能够影响文本显示的键时也会触发(例如退格键)。<br>由于textInput 事件主要考虑的是字符，因此它的event 对象中还包含一个data 属性，这个属性的值就是用户输入的字符(而非字符编码)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.getElementById(<span class="string">"myText"</span>);</div><div class="line">EventUtil.addHandler(textbox, <span class="string">"textInput"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    alert(event.data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>插入到文本框中的字符会通过一个警告框显示出来。<br>event 对象上还有一个属性，叫inputMethod，表示把文本输入到文本框中的方式。</p>
<ul>
<li>0，表示浏览器不确定是怎么输入的。</li>
<li>1，表示是使用键盘输入的。</li>
<li>2，表示文本是粘贴进来的。</li>
<li>3，表示文本是拖放进来的。</li>
<li>4，表示文本是使用IME 输入的。</li>
<li>5，表示文本是通过在表单中选择某一项输入的。</li>
<li>6，表示文本是通过手写输入的(比如使用手写笔)。</li>
<li>7，表示文本是通过语音输入的。</li>
<li>8，表示文本是通过几种方法组合输入的。</li>
<li>9，表示文本是通过脚本输入的。</li>
</ul>
<p>支持textInput 属性的浏览器有IE9+、Safari 和Chrome。只有IE 支持inputMethod 属性。</p>
<h4 id="设备中的键盘事件"><a href="#设备中的键盘事件" class="headerlink" title="设备中的键盘事件"></a>设备中的键盘事件</h4><p>iOS 版Safari 和Android 版WebKit 在使用屏幕键盘时会触发键盘事件。</p>
<h3 id="复合事件"><a href="#复合事件" class="headerlink" title="复合事件"></a>复合事件</h3><p>复合事件(composition event)是DOM3 级事件中新添加的一类事件，用于处理IME 的输入序列。<br>IME(Input Method Editor，输入法编辑器)可以让用户输入在物理键盘上找不到的字符。<br>IME 通常需要同时按住多个键，但最终只输入一个字符。</p>
<p>IE9+是到2011 年唯一支持复合事件的浏览器。由于缺少支持，对于需要开发跨浏览器应用的开发人员，它的用处不大。</p>
<h3 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h3><p>DOM2 级的变动(mutation)事件能在DOM 中的某一部分发生变化时给出提示。<br>变动事件是为XML或HTML DOM设计的，并不特定于某种语言。DOM2 级定义了如下变动事件。</p>
<ul>
<li>DOMSubtreeModified：在DOM 结构中发生任何变化时触发。这个事件在其他任何事件触发后都会触发。</li>
<li>DOMNodeInserted：在一个节点作为子节点被插入到另一个节点中时触发。</li>
<li>DOMNodeRemoved：在节点从其父节点中被移除时触发。</li>
<li>DOMNodeInsertedIntoDocument：在一个节点被直接插入文档或通过子树间接插入文档之后触发。这个事件在DOMNodeInserted 之后触发。</li>
<li>DOMNodeRemovedFromDocument：在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved 之后触发。</li>
<li>DOMAttrModified：在特性被修改之后触发。</li>
<li>DOMCharacterDataModified：在文本节点的值发生变化时触发。</li>
</ul>
<p>使用代码检测浏览器是否支持变动事件：<br><code>var isSupported = document.implementation.hasFeature(&quot;MutationEvents&quot;, &quot;2.0&quot;);</code><br>IE8 及更早版本不支持任何变动事件。</p>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>在使用removeChild()或replaceChild()从DOM中删除节点时，首先会触发DOMNodeRemoved事件。<br>这个事件的目标(event.target)是被删除的节点，而event.relatedNode 属性中包含着对目标节点父节点的引用。<br>在这个事件触发时，节点尚未从其父节点删除，<br>因此其parentNode 属性仍然指向父节点(与event.relatedNode 相同)。<br>这个事件会冒泡，因而可以在DOM 的任何层次上面处理它。</p>
<p>如果被移除的节点包含子节点，那么在其所有子节点以及这个被移除的节点上会相继触发DOMNodeRemovedFromDocument 事件。<br>但这个事件不会冒泡，所以只有直接指定给其中一个子节点的事件处理程序才会被调用。<br>这个事件的 target 目标是相应的子节点或者那个被移除的节点，除此之外event对象中不包含其他信息。<br>紧随其后触发的是DOMSubtreeModified 事件。这个事件的目标是被移除节点的父节点；此时的event 对象也不会提供与事件相关的其他信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">!</span> <span class="attr">DOCTYPE</span> <span class="attr">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Node Removal Events Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>假设要移除<code>&lt;ul&gt;</code>元素。</p>
<p>(1) 在<code>&lt;ul&gt;</code>元素上触发DOMNodeRemoved 事件。relatedNode 属性等于document.body。<br>(2) 在<code>&lt;ul&gt;</code>元素上触发DOMNodeRemovedFromDocument 事件。<br>(3) 在身为<code>&lt;ul&gt;</code>元素子节点的每个<code>&lt;li&gt;</code>元素及文本节点上触发DOMNodeRemovedFromDocument事件。<br>(4) 在document.body 上触发DOMSubtreeModified 事件，因为<code>&lt;ul&gt;</code>元素是document.body的直接子元素。</p>
<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p>在使用appendChild()、replaceChild()或insertBefore()向DOM中插入节点时，首先会触发DOMNodeInserted 事件。<br>这个事件的目标是被插入的节点，而event.relatedNode 属性中包含一个对父节点的引用。<br>在这个事件触发时，节点已经被插入到了新的父节点中。这个事件是冒泡的，因此可以在DOM 的各个层次上处理它。<br>紧接着，会在新插入的节点上面触发DOMNodeInsertedIntoDocument 事件。<br>这个事件不冒泡，因此必须在插入节点之前为它添加这个事件处理程序。<br>这个事件的目标是被插入的节点，除此之外event 对象中不包含其他信息。<br>最后一个触发的事件是DOMSubtreeModified，触发于新插入节点的父节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</div><div class="line">    <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">    item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item 4"</span>));</div><div class="line">    EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"DOMSubtreeModified"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        alert(event.type);</div><div class="line">        alert(event.target);</div><div class="line">    &#125;);</div><div class="line">    EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"DOMNodeInserted"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        alert(event.type);</div><div class="line">        alert(event.target);</div><div class="line">        alert(event.relatedNode);</div><div class="line">    &#125;);</div><div class="line">    EventUtil.addHandler(item, <span class="string">"DOMNodeInsertedIntoDocument"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        alert(event.type);</div><div class="line">        alert(event.target);</div><div class="line">    &#125;);</div><div class="line">    list.appendChild(item);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>首先创建了一个包含文本”Item 4”的新<code>&lt;li&gt;</code>元素。由于DOMSubtreeModified 和DOMNodeInserted 事件是冒泡的，所以把它们的事件处理程序添加到了文档中。<br>在将列表项插入到其父节点之前，先将DOMNodeInsertedIntoDocument 事件的事件处理程序添加给它。<br>最后一步就是使用appendChild()来添加这个列表项。<br>事件开始依次被触发。<br>首先是在新<code>&lt;li&gt;</code>元素项上触发DOMNodeInserted 事件，其relatedNode 是<code>&lt;ul&gt;</code>元素。(冒泡到document的事件处理程序)<br>然后是触发新<code>&lt;li&gt;</code>元素上的DOMNodeInsertedIntoDocument 事件，(不是冒泡)<br>最后触发的是<code>&lt;ul&gt;</code>元素上的DOMSubtreeModified 事件。(同样冒泡到document)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十三章-4]]></title>
      <url>http://codingme.xyz/2016/10/16/javascript-note-13-4/</url>
      <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><h4 id="页面坐标位置"><a href="#页面坐标位置" class="headerlink" title="页面坐标位置"></a>页面坐标位置</h4><p>通过客户区坐标能够知道鼠标是在视口中什么位置发生的，<br>而页面坐标通过事件对象的pageX 和pageY 属性，能告诉你事件是在页面中的什么位置发生的。<br>这两个属性表示鼠标光标在页面中的位置，因此坐标是从页面本身而非视口的左边和顶边计算的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    alert(<span class="string">"Page coordinates: "</span> + event.pageX + <span class="string">","</span> + event.pageY);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在页面没有滚动的情况下，pageX 和pageY 的值与clientX 和clientY 的值相等。<br>IE8 及更早版本不支持事件对象上的页面坐标，不过使用客户区坐标和滚动信息可以计算出来。<br>这时候需要用到document.body(混杂模式)或document.documentElement(标准模式)中的scrollLeft 和scrollTop 属性。<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    <span class="keyword">var</span> pageX = event.pageX,</div><div class="line">    pageY = event.pageY;</div><div class="line">    <span class="keyword">if</span> (pageX === <span class="literal">undefined</span>)&#123;</div><div class="line">        pageX = event.clientX + (<span class="built_in">document</span>.body.scrollLeft ||</div><div class="line">        <span class="built_in">document</span>.documentElement.scrollLeft);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (pageY === <span class="literal">undefined</span>)&#123;</div><div class="line">        pageY = event.clientY + (<span class="built_in">document</span>.body.scrollTop ||</div><div class="line">        <span class="built_in">document</span>.documentElement.scrollTop);</div><div class="line">    &#125;</div><div class="line">    alert(<span class="string">"Page coordinates: "</span> + pageX + <span class="string">","</span> + pageY);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="屏幕坐标位置"><a href="#屏幕坐标位置" class="headerlink" title="屏幕坐标位置"></a>屏幕坐标位置</h4><p>鼠标事件发生时，不仅会有相对于浏览器窗口的位置，还有一个相对于整个电脑屏幕的位置。<br>而通过screenX 和screenY 属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    alert(<span class="string">"Screen coordinates: "</span> + event.screenX + <span class="string">","</span> + event.screenY);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="修改键"><a href="#修改键" class="headerlink" title="修改键"></a>修改键</h4><p>虽然鼠标事件主要是使用鼠标来触发的，但在按下鼠标时键盘上的某些键的状态也可以影响到所要采取的操作。<br>这些修改键就是Shift、Ctrl、Alt 和Meta(在Windows 键盘中是Windows 键，在苹果机中是Cmd 键)，它们经常被用来修改鼠标事件的行为。<br>DOM 为此规定了4 个属性，表示这些修改键的状态：shiftKey、ctrlKey、altKey 和metaKey。<br>这些属性中包含的都是布尔值，如果相应的键被按下了，则值为true，否则值为false。<br>当某个鼠标事件发生时，通过检测这几个属性就可以确定用户是否同时按下了其中的键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    <span class="keyword">var</span> keys = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    <span class="keyword">if</span> (event.shiftKey)&#123;</div><div class="line">        keys.push(<span class="string">"shift"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (event.ctrlKey)&#123;</div><div class="line">        keys.push(<span class="string">"ctrl"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (event.altKey)&#123;</div><div class="line">        keys.push(<span class="string">"alt"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (event.metaKey)&#123;</div><div class="line">        keys.push(<span class="string">"meta"</span>);</div><div class="line">    &#125;</div><div class="line">    alert(<span class="string">"Keys: "</span> + keys.join(<span class="string">","</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>IE9、Firefox、Safari、Chrome 和Opera 都支持这4 个键。IE8 及之前版本不支持metaKey 属性。</p>
<h4 id="相关元素"><a href="#相关元素" class="headerlink" title="相关元素"></a>相关元素</h4><p>在发生mouseover 和mouserout 事件时，还会涉及更多的元素。<br>这两个事件都会涉及把鼠标指针从一个元素的边界之内移动到另一个元素的边界之内。<br>对mouseover 事件而言，事件的主目标是获得光标的元素，而相关元素就是那个失去光标的元素。<br>类似地，对mouseout 事件而言，事件的主目标是失去光标的元素，而相关元素则是获得光标的元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Related Elements Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"background-color:red;height:100px;width:100px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果鼠标指针一开始位于这个<code>&lt;div&gt;</code>元素上，然后移出了这个元素，那么就会在<code>&lt;div&gt;</code>元素上触发mouseout 事件，相关元素就是<code>&lt;body&gt;</code>元素。<br>与此同时，<code>&lt;body&gt;</code>元素上面会触发mouseover 事件，而相关元素变成了<code>&lt;div&gt;</code>。<br>DOM通过event 对象的relatedTarget 属性提供了相关元素的信息。<br>这个属性只对于mouseover和mouseout 事件才包含值；对于其他事件，这个属性的值是null。<br>IE8及之前版本不支持relatedTarget属性，但提供了保存着同样信息的不同属性。<br>在mouseover 事件触发时，IE 的fromElement 属性中保存了相关元素；<br>在mouseout 事件触发时，IE 的toElement 属性中保存着相关元素。(IE9 支持所有这些属性。)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line"><span class="comment">//省略了其他代码</span></div><div class="line">    getRelatedTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.relatedTarget)&#123;</div><div class="line">            <span class="keyword">return</span> event.relatedTarget;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement)&#123;</div><div class="line">            <span class="keyword">return</span> event.toElement;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromElement)&#123;</div><div class="line">            <span class="keyword">return</span> event.fromElement;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"><span class="comment">//省略了其他代码</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="鼠标按钮"><a href="#鼠标按钮" class="headerlink" title="鼠标按钮"></a>鼠标按钮</h4><p>只有在主鼠标按钮被单击(或键盘回车键被按下)时才会触发click 事件，因此检测按钮的信息并不是必要的。<br>但对于mousedown 和mouseup 事件来说，则在其event 对象存在一个button 属性，表示按下或释放的按钮。<br>DOM的button 属性可能有如下3 个值：0 表示主鼠标按钮，1 表示中间的鼠标按钮(鼠标滚轮按钮)，2 表示次鼠标按钮。<br>IE8 及之前版本也提供了button 属性，但这个属性的值与DOM 的button 属性有很大差异。</p>
<ul>
<li>0：表示没有按下按钮。</li>
<li>1：表示按下了主鼠标按钮。</li>
<li>2：表示按下了次鼠标按钮。</li>
<li>3：表示同时按下了主、次鼠标按钮。</li>
<li>4：表示按下了中间的鼠标按钮。</li>
<li>5：表示同时按下了主鼠标按钮和中间的鼠标按钮。</li>
<li>6：表示同时按下了次鼠标按钮和中间的鼠标按钮。</li>
<li>7：表示同时按下了三个鼠标按钮。</li>
</ul>
<p>DOM 模型下的button 属性比IE 模型下的button 属性更简单也更为实用，因为同时按下多个鼠标按钮的情形十分罕见。<br>最常见的做法就是将IE 模型规范化为DOM 方式，毕竟除IE8 及更早版本之外的其他浏览器都原生支持DOM 模型。<br>而对主、中、次按钮的映射并不困难，只要将IE 的其他选项分别转换成如同按下这三个按键中的一个即可(同时将主按钮作为优先选取的对象)。<br>换句话说，IE 中返回的5 和7 会被转换成DOM 模型中的0。</p>
<p>由于单独使用能力检测无法确定差异(两种模型有同名的button 属性)，因此必须另辟蹊径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line"><span class="comment">//省略了其他代码</span></div><div class="line">    getButton: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>, <span class="string">"2.0"</span>))&#123;</div><div class="line">            <span class="keyword">return</span> event.button;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">switch</span>(event.button)&#123;</div><div class="line">                <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">5</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">7</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                <span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">                <span class="keyword">case</span> <span class="number">4</span>:</div><div class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line"><span class="comment">//省略了其他代码</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过检测”MouseEvents”这个特性，就可以确定event 对象中存在的button 属性中是否包含正确的值。<br>如果测试失败，说明是IE，就必须对相应的值进行规范化。</p>
<h4 id="更多的事件信息"><a href="#更多的事件信息" class="headerlink" title="更多的事件信息"></a>更多的事件信息</h4><p>event 对象中还提供了detail 属性，用于给出有关事件的更多信息。<br>对于鼠标事件来说，detail 中包含了一个数值，表示在给定位置上发生了多少次单击。<br>在同一个元素上相继地发生一次mousedown 和一次mouseup 事件算作一次单击。<br>detail 属性从1 开始计数，每次单击发生后都会递增。<br>如果鼠标在mousedown 和mouseup 之间移动了位置，则detail 会被重置为0。<br>IE 也通过下列属性为鼠标事件提供了更多信息。</p>
<ul>
<li>altLeft：布尔值，表示是否按下了Alt 键。如果altLeft 的值为true，则altKey 的值也为true。</li>
<li>ctrlLeft：布尔值，表示是否按下了Ctrl 键。如果ctrlLeft 的值为true，则ctrlKey 的值也为true。</li>
<li>offsetX：光标相对于目标元素边界的x 坐标。</li>
<li>offsetY：光标相对于目标元素边界的y 坐标。</li>
<li>shiftLeft：布尔值，表示是否按下了Shift 键。如果shiftLeft 的值为true，则shiftKey的值也为true。</li>
</ul>
<h4 id="鼠标滚轮事件"><a href="#鼠标滚轮事件" class="headerlink" title="鼠标滚轮事件"></a>鼠标滚轮事件</h4><p>IE 6.0 首先实现了mousewheel 事件。此后，Opera、Chrome 和Safari 也都实现了这个事件。<br>当用户通过鼠标滚轮与页面交互、在垂直方向上滚动页面时(无论向上还是向下)，就会触发mousewheel事件。<br>这个事件可以在任何元素上面触发，最终会冒泡到document(IE8)或window(IE9、Opera、Chrome 及Safari)对象。<br>与mousewheel 事件对应的event 对象除包含鼠标事件的所有标准信息外，还包含一个特殊的wheelDelta 属性。<br>当用户向前滚动鼠标滚轮时，wheelDelta 是120 的倍数；当用户向后滚动鼠标滚轮时，wheelDelta 是-120 的倍数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"mousewheel"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">event = EventUtil.getEvent(event);</div><div class="line">alert(event.wheelDelta);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在Opera 9.5 之前的版本中，wheelDelta 值的正负号是颠倒的。</p>
<p>由于mousewheel 事件非常流行，而且所有浏览器都支持它，所以HTML 5 也加入了该事件。</p>
<p>Firefox 支持一个名为DOMMouseScroll 的类似事件，也是在鼠标滚轮滚动时触发。<br>与mousewheel事件一样，DOMMouseScroll 也被视为鼠标事件，因而包含与鼠标事件有关的所有属性。<br>而有关鼠标滚轮的信息则保存在detail 属性中，当向前滚动鼠标滚轮时，这个属性的值是-3 的倍数，当向后滚动鼠标滚轮时，这个属性的值是3 的倍数。</p>
<p>可以将DOMMouseScroll 事件添加到页面中的任何元素，而且该事件会冒泡到window 对象。<br>因此，可以像下面这样针对这个事件来添加事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"DOMMouseScroll"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">event = EventUtil.getEvent(event);</div><div class="line">alert(event.detail);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>跨浏览器环境下的解决方案:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    <span class="comment">//省略了其他代码</span></div><div class="line">    getWheelDelta: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.wheelDelta)&#123;</div><div class="line">            <span class="keyword">return</span> (client.engine.opera &amp;&amp; client.engine.opera &lt; <span class="number">9.5</span> ?</div><div class="line">            -event.wheelDelta : event.wheelDelta);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> -event.detail * <span class="number">40</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//省略了其他代码</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleMouseWheel</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        event = EventUtil.getEvent(event);</div><div class="line">        <span class="keyword">var</span> delta = EventUtil.getWheelDelta(event);</div><div class="line">        alert(delta);</div><div class="line">    &#125;</div><div class="line">    EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"mousewheel"</span>, handleMouseWheel);</div><div class="line">    EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"DOMMouseScroll"</span>, handleMouseWheel);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>相关代码放在了一个私有作用域中，从而不会让新定义的函数干扰全局作用域。<br>这里定义的handleMouseWheel()函数可以用作两个事件的处理程序(如果指定的事件不存在，则为该事件指定处理程序的代码就会静默地失败)。</p>
<h4 id="触摸设备"><a href="#触摸设备" class="headerlink" title="触摸设备"></a>触摸设备</h4><ul>
<li>不支持dblclick 事件。双击浏览器窗口会放大画面，而且没有办法改变该行为。</li>
<li>轻击可单击元素会触发mousemove 事件。如果此操作会导致内容变化，将不再有其他事件发生；<br>  如果屏幕没有因此变化，那么会依次发生mousedown、mouseup 和click 事件。轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素(如链接)，或者那些已经被指定了onclick 事件处理程序的元素。</li>
<li>mousemove 事件也会触发mouseover 和mouseout 事件。</li>
<li>两个手指放在屏幕上且页面随手指移动而滚动时会触发mousewheel 和scroll 事件。</li>
</ul>
<h4 id="无障碍性问题"><a href="#无障碍性问题" class="headerlink" title="无障碍性问题"></a>无障碍性问题</h4><p>可以通过键盘上的回车键来触发click 事件，但其他鼠标事件却无法通过键盘来触发。<br>为此，我们不建议使用click 之外的其他鼠标事件来展示功能或引发代码执行。因为这样会给盲人或视障用户造成极大不便。</p>
<ul>
<li>使用click 事件执行代码。有人指出通过onmousedown 执行代码会让人觉得速度更快，对视力正常的人来说这是没错的。<br>  但是，在屏幕阅读器中，由于无法触发mousedown 事件，结果就会造成代码无法执行。</li>
<li>不要使用onmouseover 向用户显示新的选项。原因同上，屏幕阅读器无法触发这个事件。如果确实非要通过这种方式来显示新选项，可以考虑添加显示相同信息的键盘快捷方式。</li>
<li>不要使用dblclick 执行重要的操作。键盘无法触发这个事件。</li>
</ul>
<h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><p>“DOM2 级事件”最初规定了键盘事件，但在最终定稿之前又删除了相应的内容。<br>结果，对键盘事件的支持主要遵循的是DOM0 级。<br>“DOM3 级事件”为键盘事件制定了规范，IE9 率先完全实现了该规范。</p>
<ul>
<li>keydown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件。</li>
<li>keypress：当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件。<br>  按下Esc 键也会触发这个事件。Safari 3.1 之前的版本也会在用户按下非字符键时触发keypress事件。</li>
<li>keyup：当用户释放键盘上的键时触发。</li>
</ul>
<p>虽然所有元素都支持以上3 个事件，但只有在用户通过文本框输入文本时才最常用到。<br>只有一个文本事件：textInput。这个事件是对keypress 的补充，用意是在将文本显示给用户之前更容易拦截文本。<br>在文本插入文本框之前会触发textInput 事件。</p>
<p>在用户按了一下键盘上的字符键时，首先会触发keydown 事件，然后紧跟着是keypress 事件，最后会触发keyup 事件。<br>其中，keydown 和keypress 都是在文本框发生变化之前被触发的；<br>而keyup事件则是在文本框已经发生变化之后被触发的。<br>如果用户按下的是一个非字符键，那么首先会触发keydown 事件，然后就是keyup 事件。<br>如果按住这个非字符键不放，那么就会一直重复触发keydown 事件，直到用户松开这个键，此时会触发keyup事件。<br>键盘事件与鼠标事件一样，都支持相同的修改键。<br>而且，键盘事件的事件对象中也有shiftKey、ctrlKey、altKey 和metaKey 属性。IE 不支持metaKey。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十三章-3]]></title>
      <url>http://codingme.xyz/2016/10/16/javascript-note-13-3/</url>
      <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>“DOM3级事件”规定了以下几类事件。</p>
<ul>
<li>UI(User Interface，用户界面)事件，当用户与页面上的元素交互时触发；</li>
<li>焦点事件，当元素获得或失去焦点时触发；</li>
<li>鼠标事件，当用户通过鼠标在页面上执行操作时触发；</li>
<li>滚轮事件，当使用鼠标滚轮(或类似设备)时触发；</li>
<li>文本事件，当在文档中输入文本时触发；</li>
<li>键盘事件，当用户通过键盘在页面上执行操作时触发；</li>
<li>合成事件，当为IME(Input Method Editor，输入法编辑器)输入字符时触发；</li>
<li>变动(mutation)事件，当底层DOM 结构发生变化时触发。</li>
</ul>
<p>除了这几类事件之外，HTML5 也定义了一组事件，而有些浏览器还会在DOM 和BOM中实现其他专有事件。<br>这些专有的事件一般都是根据开发人员需求定制的，没有什么规范，因此不同浏览器的实现有可能不一致。<br><a id="more"></a><br>DOM3 级事件模块在DOM2 级事件模块基础上重新定义了这些事件，也添加了一些新事件。</p>
<h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><p>指的是那些不一定与用户操作有关的事件。<br>这些事件在DOM规范出现之前，都是以这种或那种形式存在的，而在DOM 规范中保留是为了向后兼容。</p>
<ul>
<li>DOMActivate：表示元素已经被用户操作(通过鼠标或键盘)激活。。考虑到不同浏览器实现的差异，不建议使用这个事件。</li>
<li>load：当页面完全加载后在window 上面触发，当所有框架都加载完毕时在框架集上面触发，<br>  当图像加载完毕时在<code>&lt;img&gt;</code>元素上面触发，或者当嵌入的内容加载完毕时在<code>&lt;object&gt;</code>元素上面触发。</li>
<li>unload：当页面完全卸载后在window 上面触发，当所有框架都卸载后在框架集上面触发，<br>  或者当嵌入的内容卸载完毕后在<code>&lt;object&gt;</code>元素上面触发。</li>
<li>abort：在用户停止下载过程时，如果嵌入的内容没有加载完，则在<code>&lt;object&gt;</code>元素上面触发。</li>
<li>error：当发生JavaScript 错误时在window 上面触发，当无法加载图像时在<code>&lt;img&gt;</code>元素上面触发，<br>  当无法加载嵌入内容时在<code>&lt;object&gt;</code>元素上面触发，或者当有一或多个框架无法加载时在框架集上面触发。</li>
<li>select：当用户选择文本框(<code>&lt;input&gt;</code>或<code>&lt;texterea&gt;</code>)中的一或多个字符时触发。</li>
<li>resize：当窗口或框架的大小变化时在window 或框架上面触发。</li>
<li>scroll：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。<code>&lt;body&gt;</code>元素中包含所加载页面的滚动条。</li>
</ul>
<p>多数这些事件都与window 对象或表单控件相关。<br>除了DOMActivate 之外，其他事件在DOM2 级事件中都归为HTML 事件(DOMActivate 在DOM2级中仍然属于UI 事件)。<br>要确定浏览器是否支持DOM2 级事件规定的HTML 事件:<br><code>var isSupported = document.implementation.hasFeature(&quot;HTMLEvents&quot;, &quot;2.0&quot;);</code><br>要确定浏览器是否支持“DOM3 级事件”定义的事件:<br><code>var isSupported = document.implementation.hasFeature(&quot;UIEvent&quot;, &quot;3.0&quot;);</code></p>
<h4 id="load-事件"><a href="#load-事件" class="headerlink" title="load 事件"></a>load 事件</h4><p>JavaScript 中最常用的一个事件。当页面完全加载后(包括所有图像、JavaScript 文件、CSS 文件等外部资源)，就会触发window 上面的load 事件。<br>有两种定义onload 事件处理程序的方式。<br>第一种：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Loaded!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过JavaScript 来指定事件处理程序的方式，使用了前面定义的跨浏览器的EventUtil对象。<br>这个event 对象中不包含有关这个事件的任何附加信息，但在兼容DOM 的浏览器中，event.target 属性的值会被设置为document，而IE 并不会为这个事件设置srcElement 属性。</p>
<p>第二种:<br>为<code>&lt;body&gt;</code>元素添加一个onload 特性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"alert('Loaded!')"</span>&gt;</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>一般来说，在window 上面发生的任何事件都可以在<code>&lt;body&gt;</code>元素中通过相应的特性来指定，因为在HTML 中无法访问window 元素。<br>实际上，这只是为了保证向后兼容的一种权宜之计，但所有浏览器都能很好地支持这种方式。</p>
<p>建议尽可能使用JavaScript 方式。<br>根据“DOM2 级事件”规范，<strong>应该在document 而非window 上面触发load 事件</strong>。<br>但是，<strong>所有浏览器都在window 上面实现了该事件</strong>，以确保向后兼容。</p>
<p>图像上面也可以触发load 事件，无论是在DOM 中的图像元素还是HTML 中的图像元素。<br>可以在HTML 中为任何图像指定onload 事件处理程序:<br><code>&lt;img src=&quot;smile.gif&quot; onload=&quot;alert(&#39;Image loaded.&#39;)&quot;&gt;</code><br>使用JavaScript方式实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> image = <span class="built_in">document</span>.getElementById(<span class="string">"myImage"</span>);</div><div class="line">EventUtil.addHandler(image, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    alert(EventUtil.getTarget(event).src);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>传入event 对象，尽管它也不包含什么有用的信息。不过，事件的目标是<code>&lt;img&gt;</code>元素，因此可以通过src 属性访问并显示该信息。<br>在创建新的<code>&lt;img&gt;</code>元素时，可以为其指定一个事件处理程序，以便图像加载完毕后给出提示。最重要的是要在指定src 属性之前先指定事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</div><div class="line">    EventUtil.addHandler(image, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        event = EventUtil.getEvent(event);</div><div class="line">        alert(EventUtil.getTarget(event).src);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">document</span>.body.appendChild(image);</div><div class="line">    image.src = <span class="string">"smile.gif"</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>首先为window 指定了onload 事件处理程序。<br>原因在于，我们是想向DOM中添加一个新元素，所以必须确定页面已经加载完毕——如果在页面加载前操作document.body 会导致错误。<br>新图像元素不一定要从添加到文档后才开始下载，只要设置了src 属性就会开始下载。</p>
<p>同样的功能也可以通过使用DOM0 级的Image 对象实现。在DOM出现之前，开发人员经常使用Image 对象在客户端预先加载图像。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</div><div class="line">    EventUtil.addHandler(image, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        alert(<span class="string">"Image loaded!"</span>);</div><div class="line">    &#125;);</div><div class="line">    image.src = <span class="string">"smile.gif"</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>有的浏览器将Image 对象实现为<code>&lt;img&gt;</code>元素，但并非所有浏览器都如此，所以最好将它们区别对待。<br>在不属于DOM 文档的图像(包括未添加到文档的<code>&lt;img&gt;</code>元素和Image 对象)上触发load 事件时，IE8 及之前版本不会生成event 对象。IE9 修复了这个问题。</p>
<p>在IE9+、Firefox、Opera、Chrome 和Safari 3+及更高版本中，<code>&lt;script&gt;</code>元素也会触发load 事件，以便开发人员确定动态加载的JavaScript 文件是否加载完毕。<br>与图像不同，只有在设置了<code>&lt;script&gt;</code>元素的src 属性并将该元素添加到文档后，才会开始下载JavaScript 文件。<br>对于<code>&lt;script&gt;</code>元素而言，指定src 属性和指定事件处理程序的先后顺序就不重要了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    EventUtil.addHandler(script, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        alert(<span class="string">"Loaded"</span>);</div><div class="line">    &#125;);</div><div class="line">    script.src = <span class="string">"example.js"</span>;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>大多数浏览器中event 对象的target 属性引用的都是<code>&lt;script&gt;</code>节点，而在Firefox 3 之前的版本中，引用的则是document。<br>IE8 及更早版本不支持<code>&lt;script&gt;</code>元素上的load 事件。<br>IE 和Opera 还支持<code>&lt;link&gt;</code>元素上的load 事件，以便开发人员确定样式表是否加载完毕。<br>与<code>&lt;script&gt;</code>节点类似，在未指定href 属性并将<code>&lt;link&gt;</code>元素添加到文档之前也不会开始下载样式表。</p>
<h4 id="unload-事件"><a href="#unload-事件" class="headerlink" title="unload 事件"></a>unload 事件</h4><p>这个事件在文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload 事件。<br>而利用这个事件最多的情况是清除引用，以避免内存泄漏。<br>与load 事件类似，也有两种指定onunload 事件处理程序的方式。<br>第一种：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"unload"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Unloaded"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>此时生成的event 对象在兼容DOM 的浏览器中只包含target 属性(值为document)。<br>IE8 及之前版本则为这个事件对象提供了srcElement 属性。</p>
<p>第二种：<br><code>&lt;body onunload=&quot;alert(&#39;Unloaded!&#39;)&quot;&gt;</code></p>
<p>无论使用哪种方式，都要小心编写onunload 事件处理程序中的代码。<br>既然unload 事件是在一切都被卸载之后才触发，那么在页面加载后存在的那些对象，此时就不一定存在了。<br>此时，操作DOM节点或者元素的样式就会导致错误。</p>
<p>根据“DOM2 级事件”，应该在<code>&lt;body&gt;</code>元素而非window 对象上面触发unload事件。<br>不过，所有浏览器都在window 上实现了unload 事件，以确保向后兼容。</p>
<h4 id="resize-事件"><a href="#resize-事件" class="headerlink" title="resize 事件"></a>resize 事件</h4><p>当浏览器窗口被调整到一个新的高度或宽度时，就会触发resize 事件。<br>在window(窗口)上面触发，因此可以通过JavaScript 或者<code>&lt;body&gt;</code>元素中的onresize 特性来指定事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"resize"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Resized"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在兼容DOM 的浏览器中，传入事件处理程序中的event 对象有一个target 属性，值为document；而IE8 及之前版本则未提供任何属性。<br>关于何时会触发resize 事件，不同浏览器有不同的机制。<br>IE、Safari、Chrome 和Opera 会在浏览器窗口变化了1 像素时就触发resize 事件，然后随着变化不断重复触发。<br>Firefox 则只会在用户停止调整窗口大小时才会触发resize 事件。<br>由于存在这个差别，应该注意不要在这个事件的处理程序中加入大计算量的代码，因为这些代码有可能被频繁执行，从而导致浏览器反应明显变慢。</p>
<p>窗口最小化或最大化时也会触发resize 事件。</p>
<h4 id="scroll-事件"><a href="#scroll-事件" class="headerlink" title="scroll 事件"></a>scroll 事件</h4><p>scroll 事件是在window 对象上发生的，但它实际表示的则是页面中相应元素的变化。<br>混杂模式下，可以通过<code>&lt;body&gt;</code>元素的scrollLeft 和scrollTop 来监控到这一变化；<br>而在标准模式下，除Safari 之外的所有浏览器都会通过<code>&lt;html&gt;</code>元素来反映这一变化(Safari 仍然基于<code>&lt;body&gt;</code>跟踪滚动位置)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123;</div><div class="line">        alert(<span class="built_in">document</span>.documentElement.scrollTop);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        alert(<span class="built_in">document</span>.body.scrollTop);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>由于Safari 3.1 之前的版本不支持document.compatMode，因此旧版本的浏览器就会满足第二个条件。<br>与resize 事件类似，scroll 事件也会在文档被滚动期间重复被触发，所以有必要尽量保持事件处理程序的代码简单。</p>
<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>焦点事件会在页面元素获得或失去焦点时触发。<br>利用这些事件并与document.hasFocus()方法及document.activeElement 属性配合，可以知晓用户在页面上的行踪。</p>
<ul>
<li>blur：在元素失去焦点时触发。这个事件不会冒泡；所有浏览器都支持它。</li>
<li>DOMFocusIn：在元素获得焦点时触发。这个事件与HTML 事件focus 等价，但它冒泡。只有Opera 支持这个事件。DOM3 级事件废弃了DOMFocusIn，选择了focusin。</li>
<li>DOMFocusOut：在元素失去焦点时触发。这个事件是HTML 事件blur 的通用版本。只有Opera支持这个事件。DOM3 级事件废弃了DOMFocusOut，选择了focusout。</li>
<li>focus：在元素获得焦点时触发。这个事件不会冒泡；所有浏览器都支持它。</li>
<li>focusin：在元素获得焦点时触发。这个事件与HTML 事件focus 等价，但它冒泡。支持这个事件的浏览器有IE5.5+、Safari 5.1+、Opera 11.5+和Chrome。</li>
<li>focusout：在元素失去焦点时触发。这个事件是HTML 事件blur 的通用版本。支持这个事件的浏览器有IE5.5+、Safari 5.1+、Opera 11.5+和Chrome。</li>
</ul>
<p>最主要的两个是focus 和blur，它们都是JavaScript 早期就得到所有浏览器支持的事件。这些事件的最大问题是它们不冒泡。<br>因此，IE 的focusin 和focusout 与Opera 的DOMFocusIn和DOMFocusOut 才会发生重叠。IE 的方式最后被DOM3 级事件采纳为标准方式。<br>当焦点从页面中的一个元素移动到另一个元素，会依次触发下列事件：<br>(1) focusout 在失去焦点的元素上触发；<br>(2) focusin 在获得焦点的元素上触发；<br>(3) blur 在失去焦点的元素上触发；<br>(4) DOMFocusOut 在失去焦点的元素上触发；<br>(5) focus 在获得焦点的元素上触发；<br>(6) DOMFocusIn 在获得焦点的元素上触发。</p>
<p>其中，blur、DOMFocusOut 和focusout 的事件目标是失去焦点的元素；而focus、DOMFocusIn和focusin 的事件目标是获得焦点的元素。<br>判断浏览器是否支持:<br><code>var isSupported = document.implementation.hasFeature(&quot;FocusEvent&quot;, &quot;3.0&quot;);</code><br>即使focus 和blur 不冒泡，也可以在捕获阶段侦听到它们。</p>
<h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><p>鼠标事件是Web 开发中最常用的一类事件，毕竟鼠标还是最主要的定位设备。<br>DOM3 级事件中定义了9个鼠标事件:</p>
<ul>
<li>click：在用户单击主鼠标按钮(一般是左边的按钮)或者按下回车键时触发。这一点对确保易访问性很重要，意味着onclick 事件处理程序既可以通过键盘也可以通过鼠标执行。</li>
<li>dblclick：在用户双击主鼠标按钮(一般是左边的按钮)时触发。从技术上说，这个事件并不是DOM2 级事件规范中规定的，但鉴于它得到了广泛支持，所以DOM3 级事件将其纳入了标准。</li>
<li>mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件。</li>
<li>mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事件，但DOM3 级事件将它纳入了规范。IE、Firefox 9+和Opera 支持这个事件。</li>
<li>mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2 级事件并没有定义这个事件，但DOM3 级事件将它纳入了规范。IE、Firefox 9+和Opera 支持这个事件。</li>
<li>mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。</li>
<li>mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。</li>
<li>mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。不能通过键盘触发这个事件。</li>
<li>mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。</li>
</ul>
<p>页面上的所有元素都支持鼠标事件。<br>除了mouseenter 和mouseleave，所有鼠标事件都会冒泡，也可以被取消，而取消鼠标事件将会影响浏览器的默认行为。<br>取消鼠标事件的默认行为还会影响其他事件，因为鼠标事件与其他事件是密不可分的关系。<br>只有在同一个元素上相继触发mousedown 和mouseup 事件，才会触发click 事件；<br>如果mousedown 或mouseup 中的一个被取消，就不会触发click 事件。<br>只有触发两次click 事件，才会触发一次dblclick 事件。<br>如果有代码阻止了连续两次触发click 事件(可能是直接取消click事件，也可能通过取消mousedown 或mouseup 间接实现)，<br>那么就不会触发dblclick 事件了。</p>
<p>4个事件触发的顺序始终如下：<br>(1) mousedown<br>(2) mouseup<br>(3) click<br>(4) mousedown<br>(5) mouseup<br>(6) click<br>(7) dblclick</p>
<p>click 和dblclick 事件都会依赖于其他先行事件的触发；而mousedown 和mouseup 则不受其他事件的影响。<br>IE8 及之前版本中的实现有一个小bug，因此在双击事件中，会跳过第二个mousedown 和click事件:<br>(1) mousedown<br>(2) mouseup<br>(3) click<br>(4) mouseup<br>(5) dblclick<br>IE9 修复了这个bug。</p>
<p>检测浏览器是否支持以上DOM2 级事件(除dbclick、mouseenter 和mouseleave 之外)：<br><code>var isSupported = document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;);</code>]<br>检测浏览器是否支持上面的所有事件：<br><code>var isSupported = document.implementation.hasFeature(&quot;MouseEvent&quot;, &quot;3.0&quot;)</code><br>DOM3 级事件的feature 名是”MouseEvent”，而非”MouseEvents”。</p>
<p>鼠标事件中还有一类滚轮事件。<br>而说是一类事件，其实就是一个mousewheel 事件。<br>这个事件跟踪鼠标滚轮，类似于Mac 的触控板。</p>
<h4 id="客户区坐标位置"><a href="#客户区坐标位置" class="headerlink" title="客户区坐标位置"></a>客户区坐标位置</h4><p>鼠标事件都是在浏览器视口中的特定位置上发生的。<br>这个位置信息保存在事件对象的clientX 和clientY 属性中。<br>所有浏览器都支持这两个属性，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">EventUtil.addHandler(div, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    alert(<span class="string">"Client coordinates: "</span> + event.clientX + <span class="string">","</span> + event.clientY);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当用户单击这个元素时，就会看到事件的客户端坐标信息。<br>注意，这些值中不包括页面滚动的距离，因此这个位置并不表示鼠标在页面上的位置。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十三章-2]]></title>
      <url>http://codingme.xyz/2016/10/16/javascript-note-13-2/</url>
      <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。<br>包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。<br>所有浏览器都支持event 对象，但支持方式不同。</p>
<h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><p>兼容DOM 的浏览器会将一个event 对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法(DOM0 级或DOM2 级)，都会传入event 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(event.type); <span class="comment">//"click"</span></div><div class="line">&#125;;</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(event.type); <span class="comment">//"click"</span></div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>在通过HTML 特性指定事件处理程序时，变量event 中保存着event 对象。<br><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;/&gt;</code><br>以这种方式提供event 对象，可以让HTML 特性事件处理程序与JavaScript 函数执行相同的操作。<br><a id="more"></a><br>event 对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。</p>
<pre><code>属性/方法 类 型 读/写 说 明
bubbles Boolean 只读 表明事件是否冒泡
cancelable Boolean 只读 表明是否可以取消事件的默认行为
currentTarget Element 只读 其事件处理程序当前正在处理事件的那个元素
defaultPrevented Boolean 只读 为true 表示已经调用了preventDefault()(DOM3级事件中新增)
detail Integer 只读 与事件相关的细节信息
eventPhase Integer 只读 调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段
preventDefault() Function 只读 取消事件的默认行为。如果cancelable是true，则可以使用这个方法
stopImmediatePropagation() Function 只读 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用(DOM3级事件中新增)
stopPropagation() Function 只读 取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法
target Element 只读 事件的目标
trusted Boolean 只读 为true表示事件是浏览器生成的。为false表示事件是由开发人员通过JavaScript 创建的(DOM3级事件中新增)
type String 只读 被触发的事件的类型
view AbstractView 只读 与事件关联的抽象视图。等同于发生事件的window对象
</code></pre><p>在事件处理程序内部，对象this 始终等于currentTarget 的值，而target 则只包含事件的实际目标。<br>如果直接将事件处理程序指定给了目标元素，则this、currentTarget 和target 包含相同的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(event.currentTarget === <span class="keyword">this</span>); <span class="comment">//true</span></div><div class="line">    alert(event.target === <span class="keyword">this</span>); <span class="comment">//true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由于click 事件的目标是按钮，因此这三个值是相等的。<br>如果事件处理程序存在于按钮的父节点中(例如document.body)，那么这些值是不相同的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">alert(event.currentTarget === <span class="built_in">document</span>.body); <span class="comment">//true</span></div><div class="line">alert(<span class="keyword">this</span> === <span class="built_in">document</span>.body); <span class="comment">//true</span></div><div class="line">alert(event.target === <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>)); <span class="comment">//true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当单击这个例子中的按钮时，this 和currentTarget 都等于document.body，因为事件处理程序是注册到这个元素上的。<br>然而，target 元素却等于按钮元素，因为它是click 事件真正的目标。<br>由于按钮上并没有注册事件处理程序，结果click 事件就冒泡到了document.body，在那里事件才得到了处理。</p>
<p>在需要通过一个函数处理多个事件时，可以使用type 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(event.type)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"click"</span>:</div><div class="line">            alert(<span class="string">"Clicked"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"mouseover"</span>:</div><div class="line">            event.target.style.backgroundColor = <span class="string">"red"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"mouseout"</span>:</div><div class="line">            event.target.style.backgroundColor = <span class="string">""</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">btn.onclick = handler;</div><div class="line">btn.onmouseover = handler;</div><div class="line">btn. onmouseout = handler;</div></pre></td></tr></table></figure>
<p>定义了一个名为handler 的函数，用于处理3 种事件：click、mouseover 和mouseout。<br>当单击按钮时，会出现一个与前面例子中一样的警告框。<br>当按钮移动到按钮上面时，背景颜色应该会变成红色，而当鼠标移动出按钮的范围时，背景颜色应该会恢复为默认值。<br>这里通过检测event.type属性，让函数能够确定发生了什么事件，并执行相应的操作。</p>
<p>要阻止特定事件的默认行为，可以使用preventDefault()方法。<br>例如，链接的默认行为就是在被单击时会导航到其href 特性指定的URL。<br>果你想阻止链接导航这一默认行为，那么通过链接的onclick 事件处理程序可以取消它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</div><div class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event.preventDefault();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>只有cancelable 属性设置为true 的事件，才可以使用preventDefault()来取消其默认行为。</p>
<p>stopPropagation()方法用于立即停止事件在DOM 层次中的传播，即取消进一步的事件捕获或冒泡。<br>例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation()，从而避免触发注册在document.body 上面的事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">alert(<span class="string">"Clicked"</span>);</div><div class="line">event.stopPropagation();</div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">alert(<span class="string">"Body clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果不调用stopPropagation()，就会在单击按钮时出现两个警告框。<br>可是，由于click 事件根本不会传播到document.body，因此就不会触发注册在这个元素上的onclick 事件处理程序。</p>
<p>事件对象的eventPhase 属性，可以用来确定事件当前正位于事件流的哪个阶段。<br>如果是在捕获阶段调用的事件处理程序，那么eventPhase 等于1；<br>如果事件处理程序处于目标对象上，则event-Phase 等于2；<br>如果是在冒泡阶段调用的事件处理程序，eventPhase 等于3。</p>
<p>尽管“处于目标”发生在冒泡阶段，但eventPhase 仍然一直等于2。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">alert(event.eventPhase); <span class="comment">//2</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">alert(event.eventPhase); <span class="comment">//1</span></div><div class="line">&#125;, <span class="literal">true</span>);</div><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">alert(event.eventPhase); <span class="comment">//3</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>单击这个例子中的按钮时，首先执行的事件处理程序是在捕获阶段触发的添加到document.body中的那一个，<br>结果会弹出一个警告框显示表示eventPhase 的1。接着，会触发在按钮上注册的事件处理程序，此时的eventPhase 值为2。<br>最后一个被触发的事件处理程序，是在冒泡阶段执行的添加到document.body 上的那一个，显示eventPhase 的值为3。<br>而当eventPhase 等于2 时，this、target和currentTarget 始终都是相等的。</p>
<p>只有在事件处理程序执行期间，event 对象才会存在；一旦事件处理程序执行完成，event 对象就会被销毁。</p>
<h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><p>要访问IE 中的event 对象有几种不同的方式，取决于指定事件处理程序的方法。<br>在使用DOM0 级方法添加事件处理程序时，event 对象作为window 对象的一个属性存在。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> event = <span class="built_in">window</span>.event;</div><div class="line">alert(event.type); <span class="comment">//"click"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果事件处理程序是使用attachEvent()添加的，那么就会有一个event 对象作为参数被传入事件处理程序函数中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">alert(event.type); <span class="comment">//"click"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在像这样使用attachEvent()的情况下，也可以通过window 对象来访问event 对象，就像使用DOM0 级方法时一样。<br>不过为方便起见，同一个对象也会作为参数传递。<br>如果是通过HTML特性指定的事件处理程序，那么还可以通过一个名叫event 的变量来访问event对象(与DOM 中的事件模型相同)<br><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;&gt;</code></p>
<p>IE 的event 对象同样也包含与创建它的事件相关的属性和方法。<br>其中很多属性和方法都有对应的或者相关的DOM属性和方法。<br>与DOM的event 对象一样，这些属性和方法也会因为事件类型的不同而不同，但所有事件对象都会包含下表所列的属性和方法。</p>
<pre><code>属性/方法 类 型 读/写 说 明
cancelBubble Boolean 读/写 默认值为false，但将其设置为true就可以取消事件冒泡(与DOM中的stopPropagation()方法的作用相同)
returnValue Boolean 读/写 默认值为true，但将其设置为false就可以取消事件的默认行为(与DOM中的preventDefault()方法的作用相同)
srcElement Element 只读 事件的目标(与DOM中的target属性相同)
type String 只读 被触发的事件的类型
</code></pre><p>因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this 会始终等于事件目标。<br>故而，最好还是使用event.srcElement 比较保险。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>); <span class="comment">//true</span></div><div class="line">&#125;;</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">alert(event.srcElement === <span class="keyword">this</span>); <span class="comment">//false</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>returnValue 属性相当于DOM 中的preventDefault()方法，它们的作用都是取消给定事件的默认行为。<br>只要将returnValue 设置为false，就可以阻止默认行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</div><div class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>与DOM不同的是，在此没有办法确定事件是否能被取消。</p>
<p>cancelBubble 属性与DOM 中的stopPropagation()方法作用相同，都是用来停止事件冒泡的。<br>由于IE 不支持事件捕获，因而只能取消事件冒泡；但stopPropagatioin()可以同时取消事件捕获和冒泡。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="string">"Clicked"</span>);</div><div class="line"><span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="string">"Body clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过在onclick 事件处理程序中将cancelBubble 设置为true，就可阻止事件通过冒泡而触发document.body 中注册的事件处理程序。<br>结果，在单击按钮之后，只会显示一个警告框。</p>
<h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><p>虽然DOM 和IE 中的event 对象不同，但基于它们之间的相似性依旧可以拿出跨浏览器的方案来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">    <span class="comment">//省略的代码</span></div><div class="line">    &#125;,</div><div class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</div><div class="line">    &#125;,</div><div class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">    &#125;,</div><div class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.preventDefault)&#123;</div><div class="line">            event.preventDefault();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            event.returnValue = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">    <span class="comment">//省略的代码</span></div><div class="line">    &#125;,</div><div class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.stopPropagation)&#123;</div><div class="line">            event.stopPropagation();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            event.cancelBubble = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>添加了4 个新方法。第一个是getEvent()，它返回对event对象的引用。<br>考虑到IE 中事件对象的位置不同，可以使用这个方法来取得event 对象，而不必担心指定事件处理程序的方式。</p>
<p>在使用这个方法时，必须假设有一个事件对象传入到事件处理程序中，而且要把该变量传给这个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在兼容DOM 的浏览器中，event 变量只是简单地传入和返回。而在IE 中，event 参数是未定义的(undefined)，因此就会返回window.event。</p>
<p>第二个方法是getTarget()，它返回事件的目标。<br>在这个方法内部，会检测event 对象的target属性，如果存在则返回该属性的值；否则，返回srcElement 属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第三个方法是preventDefault()，用于取消事件的默认行为。<br>在传入event 对象后，这个方法会检查是否存在preventDefault()方法，如果存在则调用该方法。<br>如果preventDefault()方法不存在，则将returnValue 设置为false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</div><div class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    EventUtil.preventDefault(event);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第四个方法是stopPropagation()，其实现方式类似。首先尝试使用DOM 方法阻止事件流，否则就使用cancelBubble 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Clicked"</span>);</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    EventUtil.stopPropagation(event);</div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Body clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由于IE 不支持事件捕获，因此这个方法在跨浏览器的情况下，也只能用来阻止事件冒泡。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十三章-1]]></title>
      <url>http://codingme.xyz/2016/10/12/javascript-note-13-1/</url>
      <content type="html"><![CDATA[<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>JavaScript 与HTML 之间的交互是通过事件实现的。<br><strong>事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间</strong>。<br>可以使用侦听器(或处理程序)来预订事件，以便事件发生时执行相应的代码。<br>这种在传统软件工程中被称为观察员模式的模型，支持页面的行为(JavaScript 代码)与页面的外观(HTML 和CSS 代码)之间的松散耦合。</p>
<p>IE9、Firefox、Opera、Safari 和Chrome 全都已经实现了“DOM2 级事件”模块的核心部分。<strong>IE8 是最后一个仍然使用其专有事件系统的主要浏览器。</strong><br>尽管所有主要浏览器已经实现了“DOM2 级事件”，但这个规范本身并没有涵盖所有事件类型。</p>
<h2 id="1事件流"><a href="#1事件流" class="headerlink" title="1事件流"></a>1事件流</h2><p>在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面。<br>事件流描述的是从页面中接收事件的顺序。<br>当时，IE 的事件流是事件冒泡流，而Netscape Communicator 的事件流是事件捕获流。</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>即事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点(文档)。<br><a id="more"></a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果你单击了页面中的<code>&lt;div&gt;</code>元素，那么这个click 事件的传播顺序：<br>(1) <code>&lt;div&gt;</code><br>(2) <code>&lt;body&gt;</code><br>(3) <code>&lt;html&gt;</code><br>(4) <code>document</code></p>
<p>click 事件首先在<code>&lt;div&gt;</code>元素上发生，而这个元素就是我们单击的元素。然后，click事件沿DOM树向上传播，在每一级节点上都会发生，直至传播到document 对象。</p>
<p>所有现代浏览器都支持事件冒泡，但在具体实现上还是有一些差别。IE5.5 及更早版本中的事件冒泡会跳过<code>&lt;html&gt;</code>元素(从<code>&lt;body&gt;</code>直接跳到document)。<br>IE9、Firefox、Chrome 和Safari 则将事件一直冒泡到window 对象。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。<br>事件捕获的用意在于在事件到达预定目标之前捕获它。</p>
<p>以前面的HTML 页面作为演示事件捕获的例子,click事件的触发顺序是:<br>(1) <code>document</code><br>(2) <code>&lt;html&gt;</code><br>(3) <code>&lt;body&gt;</code><br>(4) <code>&lt;div&gt;</code></p>
<p>在事件捕获过程中，document 对象首先接收到click 事件，然后事件沿DOM 树依次向下，一直传播到事件的实际目标，即<code>&lt;div&gt;</code>元素。</p>
<p>IE9、Safari、Chrome、Opera和Firefox 目前也都支持这种事件流模型。<br>尽管“DOM2 级事件”规范要求事件应该从document 对象开始传播，但这些浏览器都是从window 对象开始捕获事件的。<br>由于老版本的浏览器不支持，因此很少有人使用事件捕获。<br>也建议放心地使用事件冒泡，在有特殊需要时再使用事件捕获。</p>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>“DOM2级事件”规定的事件流包括三个阶段：<strong>事件捕获阶段、处于目标阶段和事件冒泡阶段。</strong></p>
<p>首先发生的是事件捕获，为截获事件提供了机会。<br>然后是实际的目标接收到事件。<br>最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。</p>
<p>在DOM 事件流中，实际的目标(<code>&lt;div&gt;</code>元素)在捕获阶段不会接收到事件。<br>这意味着在捕获阶段，事件从document 到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>后就停止了。<br>下一个阶段是“处于目标”阶段，于是事件在<code>&lt;div&gt;</code>上发生，并在事件处理(后面将会讨论这个概念)中被看成冒泡阶段的一部分。<br>然后，冒泡阶段发生，事件又传播回文档。</p>
<p>多数支持DOM 事件流的浏览器都实现了一种特定的行为；即使“DOM2 级事件”规范明确要求捕获阶段不会涉及事件目标，<br>但IE9、Safari、Chrome、Firefox 和Opera 9.5 及更高版本都会在捕获阶段触发事件对象上的事件。<br>结果，就是有两个机会在目标对象上面操作事件。</p>
<p>IE9、Opera、Firefox、Chrome 和Safari 都支持DOM 事件流；<strong>IE8 及更早版本不支持DOM 事件流</strong>。</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p><strong>事件就是用户或浏览器自身执行的某种动作</strong>。诸如click、load 和mouseover，都是事件的名字。<br>而响应某个事件的函数就叫做事件处理程序(或事件侦听器)。<br><strong>事件处理程序的名字以”on”开头</strong>，因此click 事件的事件处理程序就是onclick，load 事件的事件处理程序就是onload。</p>
<h3 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h3><p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML 特性来指定。这个特性的值应该是能够执行的JavaScript 代码。<br><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&#39;Clicked&#39;)&quot; /&gt;</code><br>这个操作是通过指定onclick 特性并将一些JavaScript代码作为它的值来定义的。<br>由于这个值是JavaScript，因此不能在其中使用未经转义的HTML 语法字符，例如和号(&amp;)、双引号(“”)、小于号(&lt;)或大于号(&gt;)。<br>为了避免使用HTML 实体，这里使用了单引号。<br>如果想要使用双引号:<br><code>&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(&amp;quot;Clicked&amp;quot;)&quot; /&gt;</code></p>
<p>在HTML 中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Hello world!"</span>);</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。<br>这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。<br>这个函数中有一个局部变量event，也就是事件对象：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 输出 "click" --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>通过event 变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。<br>在这个函数内部，this 值等于事件的目标元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 输出 "Click Me" --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(this.value)"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>关于这个<strong>动态创建的函数</strong>，另一个有意思的地方是它扩展作用域的方式。<br>在这个函数内部，可以像访问局部变量一样访问document 及该元素本身的成员。<br>这个函数使用with 像下面这样扩展作用域:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">with</span>(<span class="built_in">document</span>)&#123;</div><div class="line">        <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</div><div class="line">            <span class="comment">//元素属性值</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此一来，事件处理程序要访问自己的属性就简单多了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 输出 "Click Me" --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(value)"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果当前元素是一个表单输入元素，则作用域中还会包含访问表单元素(父元素)的入口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">with</span>(<span class="built_in">document</span>)&#123;</div><div class="line">        <span class="keyword">with</span>(<span class="keyword">this</span>.form)&#123;</div><div class="line">            <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</div><div class="line">            <span class="comment">//元素属性值</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样扩展作用域的方式，无非就是想让事件处理程序无需引用表单元素就能访问其他表单字段。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Echo Username"</span> <span class="attr">onclick</span>=<span class="string">"alert(username.value)"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这个例子中，单击按钮会显示文本框中的文本。值得注意的是，这里直接引用了username 元素。</p>
<p>在HTML 中指定事件处理程序有两个缺点。首先，存在一个时差问题。<br>因为用户可能会在HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。<br>假设showMessage()函数是在按钮下方、页面的最底部定义的。<br>如果用户在页面解析showMessage()函数之前就单击了按钮，就会引发错误。<br>(思考：那么如何解决？先把按钮设置成disabled，等对应函数的脚本加载成功后改成可点击？)<br>很多HTML 事件处理程序都会被封装在一个try-catch 块中，以便错误不会浮出水面。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"try&#123;showMessage();&#125;catch(ex)&#123;&#125;"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果在showMessage()函数有定义之前单击了按钮，用户将不会看到JavaScript 错误，因为在浏览器有机会处理错误之前，错误就被捕获了。</p>
<p>另一个缺点是，这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。<br>不同JavaScript引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。<br>最后一个缺点是HTML 与JavaScript 代码紧密耦合。<br>如果要更换事件处理程序，就要改动两个地方：HTML 代码和JavaScript 代码。<br>所以许多开发人员摒弃HTML 事件处理程序，转而使用JavaScript 指定事件处理程序。</p>
<h3 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h3><p>通过JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。<br>这种为事件处理程序赋值的方法是在第四代Web 浏览器中出现的，而且至今仍然为所有现代浏览器所支持。<br>原因一是简单，二是具有跨浏览器的优势。<br>要使用JavaScript 指定事件处理程序，首先必须取得一个要操作的对象的引用。</p>
<p>每个元素(包括window 和document)都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。<br>将这种属性的值设置为一个函数，就可以指定事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在这些代码运行以前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面，就有可能在一段时间内怎么单击都没有反应。<br>使用DOM0 级方法指定的事件处理程序被认为是元素的方法。<br>因此，这时候的事件处理程序是在元素的作用域中运行；换句话说，程序中的this 引用当前元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.id); <span class="comment">//"myBtn"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>实际上可以在事件处理程序中通过this 访问元素的任何属性和方法。<br>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。<br>将事件处理程序设置为null 之后，再单击按钮将不会有任何动作发生。</p>
<p>如果使用HTML 指定事件处理程序，那么onclick 属性的值就是一个包含着在同名HTML 特性中指定的代码的函数。<br>而将相应的属性设置为null，也可以删除以这种方式指定的事件处理程序。</p>
<h3 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h3><p>“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。<br>所有DOM节点中都包含这两个方法，并且它们都接受3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。<br>最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>与DOM0 级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行。<br>使用DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Hello world!"</span>);</div><div class="line">&#125;, f alse);</div></pre></td></tr></table></figure>
<p>这两个事件处理程序会按照添加它们的顺序触发，因此首先会显示元素的ID，其次会显示”Hello world!”消息。<br>通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；<br>移除时传入的参数与添加处理程序时使用的参数相同。<br>这也意味着通过addEventListener()添加的匿名函数将无法移除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里省略了其他代码</span></div><div class="line">btn.removeEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//没有用！</span></div><div class="line">    alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>但实际上，第二个参数与传入addEventListener()中的那一个是完全不同的函数。<br>而传入removeEventListener()中的事件处理程序函数必须与传入addEventListener()中的相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.id);</div><div class="line">&#125;;</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</div><div class="line"><span class="comment">//这里省略了其他代码</span></div><div class="line">btn.removeEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>); <span class="comment">//有效！</span></div></pre></td></tr></table></figure>
<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。<br>最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。<br>如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。</p>
<h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3><p>attachEvent()和detachEvent()。<br>接受相同的两个参数：事件处理程序名称与事件处理程序函数。<br>由于IE8 及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Clicked"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>attachEvent()的第一个参数是”onclick”，而非DOM 的addEventListener()方法中的”click”。<br>在IE 中使用attachEvent()与使用DOM0 级方法的主要区别在于事件处理程序的作用域。<br>在使用DOM0 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；<br>在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this 等于window。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在编写跨浏览器的代码时，牢记这一区别非常重要。<br>attachEvent()方法也可以用来为一个元素添加多个事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Clicked"</span>);</div><div class="line">&#125;);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Hello world!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>与DOM方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。<br>首先看到的是”Hello world!”，然后才是”Clicked”。<br>使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。<br>与DOM 方法一样，这也意味着添加的匿名函数将不能被移除。<br>不过，只要能够将对相同函数的引用传给detachEvent()，就可以移除相应的事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Clicked"</span>);</div><div class="line">&#125;;</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, handler);</div><div class="line"><span class="comment">//这里省略了其他代码</span></div><div class="line">btn.detachEvent(<span class="string">"onclick"</span>, handler);</div></pre></td></tr></table></figure>
<p>这个例子将保存在变量handler 中的函数作为事件处理程序。因此，后面的detachEvent()可以使用相同的函数来移除事件处理程序。</p>
<h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3><p>为了以跨浏览器的方式处理事件，不少开发人员会使用能够隔离浏览器差异的JavaScript 库，还有一些开发人员会自己开发最合适的事件处理的方法。<br>第一个要创建的方法是addHandler()，它的职责是视情况分别使用DOM0 级方法、DOM2 级方法或IE 方法来添加事件。<br>这个方法属于一个名叫EventUtil 的对象，将使用这个对象来处理浏览器间的差异。<br>addHandler()方法接受3 个参数：要操作的元素、事件名称和事件处理程序函数。</p>
<p>与addHandler()对应的方法是removeHandler()，它也接受相同的参数。<br>这个方法的职责是移除之前添加的事件处理程序——无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无效，默认采用DOM0 级方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.addEventListener)&#123;</div><div class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent)&#123;</div><div class="line">            element.attachEvent(<span class="string">"on"</span> + type, handler);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">"on"</span> + type] = handler;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.removeEventListener)&#123;</div><div class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent)&#123;</div><div class="line">            element.detachEvent(<span class="string">"on"</span> + type, handler);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"Clicked"</span>);</div><div class="line">&#125;;</div><div class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, handler);</div><div class="line"><span class="comment">//这里省略了其他代码</span></div><div class="line">EventUtil.removeHandler(btn, <span class="string">"click"</span>, handler);</div></pre></td></tr></table></figure>
<p>首先都会检测传入的元素中是否存在DOM2 级方法。<br>如果存在DOM2 级方法，则使用该方法：传入事件类型、事件处理程序函数和第三个参数false(表示冒泡阶段)。<br>如果存在的是IE 的方法，则采取第二种方案。<br>最后一种可能就是使用DOM0 级方法(在现代浏览器中，应该不会执行这里的代码)。</p>
<p>addHandler()和removeHandler()没有考虑到所有的浏览器问题，例如在IE 中的作用域问题。<br>不过，使用它们添加和移除事件处理程序还是足够了。<br>此外还要注意，DOM0 级对每个事件只支持一个事件处理程序。(好在，只支持DOM0 级的浏览器已经没有那么多了)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十二章-4]]></title>
      <url>http://codingme.xyz/2016/10/09/javascript-note-12-4/</url>
      <content type="html"><![CDATA[<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><h2 id="DOM中的范围"><a href="#DOM中的范围" class="headerlink" title="DOM中的范围"></a>DOM中的范围</h2><h3 id="操作DOM-范围中的内容"><a href="#操作DOM-范围中的内容" class="headerlink" title="操作DOM 范围中的内容"></a>操作DOM 范围中的内容</h3><p>在创建范围时 ，内部会为这个范围创建一个文档片段，范围所属的全部节点都被添加到了这个文档片段中。<br>为了创建这个文档片段，范围内容的格式必须正确有效。<br>在前面的例子中，我们创建的选区分别开始和结束于两个文本节点的内部，因此不能算是格式良好的DOM结构，也就无法通过DOM来表示。<br>范围知道自身缺少哪些开标签和闭标签，它能够重新构建有效的DOM结构以便我们对其进行操作。</p>
<p>范围经过计算知道选区中缺少一个开始的<code>&lt;b&gt;</code>标签，因此就会在后台动态加入一个该标签，同时还会在前面加入一个表示结束的<code>&lt;/b&gt;</code>标签以结束”He”。于是，修改后的DOM 就变成了:<br><code>&lt;p&gt;&lt;b&gt;He&lt;/b&gt;&lt;b&gt;llo&lt;/b&gt; world!&lt;/p&gt;</code><br>文本节点”world!”也被拆分为两个文本节点，一个包含”wo”，另一个包含”rld!”。</p>
<p>像这样创建了范围之后，就可以使用各种方法对范围的内容进行操作了。<br>deleteContents()这个方法能够从文档中删除范围所包含的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</div><div class="line">helloNode = p1.firstChild.firstChild;</div><div class="line">worldNode = p1.lastChild;</div><div class="line">range = <span class="built_in">document</span>.createRange();</div><div class="line">range.setStart(helloNode, <span class="number">2</span>);</div><div class="line">range.setEnd(worldNode, <span class="number">3</span>);</div><div class="line">range.deleteContents();</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>执行完后，<br><code>&lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt;</code><br>由于范围选区在修改底层DOM 结构时能够保证格式良好，因此即使内容被删除了，最终的DOM结构依旧是格式良好的。<br>与deleteContents()方法相似，extractContents()也会从文档中移除范围选区。<br>但这两个方法的区别在于，extractContents()会返回范围的文档片段。<br>利用这个返回的值，可以将范围的内容插入到文档中的其他地方。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</div><div class="line">helloNode = p1.firstChild.firstChild;</div><div class="line">worldNode = p1.lastChild;</div><div class="line">range = <span class="built_in">document</span>.createRange();</div><div class="line">range.setStart(helloNode, <span class="number">2</span>);</div><div class="line">range.setEnd(worldNode, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> fragment = range.extractContents();</div><div class="line">p1.parentNode.appendChild(fragment);</div></pre></td></tr></table></figure>
<p>在这个例子中，我们将提取出来的文档片段添加到了文档<code>&lt;body&gt;</code>元素的末尾。<br>(在将文档片段传入appendChild()方法中时，添加到文档中的只是片段的子节点，而非片段本身。)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span>rld!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> wo</div></pre></td></tr></table></figure>
<p>cloneContents()创建范围对象的一个副本，然后在文档的其他地方插入该副本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>),</div><div class="line">helloNode = p1.firstChild.firstChild,</div><div class="line">worldNode = p1.lastChild,</div><div class="line">range = <span class="built_in">document</span>.createRange();</div><div class="line">range.setStart(helloNode, <span class="number">2</span>);</div><div class="line">range.setEnd(worldNode, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> fragment = range.cloneContents();</div><div class="line">p1.parentNode.appendChild(fragment);</div></pre></td></tr></table></figure>
<p>与extractContents()非常类似，因为它们都返回文档片段。<br>它们的主要区别在于，cloneContents()返回的文档片段包含的是范围中节点的副本，而不是实际的节点。<br>结果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> wo</div></pre></td></tr></table></figure>
<p>调用上面介绍的方法之前，拆分的节点并不会产生格式良好的文档片段。<br>换句话说，原始的HTML 在DOM 被修改之前会始终保持不变。</p>
<h3 id="插入DOM-范围中的内容"><a href="#插入DOM-范围中的内容" class="headerlink" title="插入DOM 范围中的内容"></a>插入DOM 范围中的内容</h3><p>使用insertNode()方法可以向范围选区的开始处插入一个节点。<br>若想插入：<code>&lt;span style=&quot;color: red&quot;&gt;Inserted text&lt;/span&gt;</code><br>可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</div><div class="line">helloNode = p1.firstChild.firstChild;</div><div class="line">worldNode = p1.lastChild;</div><div class="line">range = <span class="built_in">document</span>.createRange();</div><div class="line">range.setStart(helloNode, <span class="number">2</span>);</div><div class="line">range.setEnd(worldNode, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>);</div><div class="line">span.style.color = <span class="string">"red"</span>;</div><div class="line">span.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Inserted text"</span>));</div><div class="line">range.insertNode(span);</div></pre></td></tr></table></figure>
<p>结果就是：<code>&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;He&lt;span style=&quot;color: red&quot;&gt;Inserted text&lt;/span&gt;llo&lt;/b&gt; world&lt;/p&gt;</code><br><code>&lt;span&gt;</code>正好被插入到了”Hello”中的”llo”前面，而该位置就是范围选区的开始位置。<br>这里没有使用上一节介绍的方法，结果原始的HTML 并没有添加或删除<code>&lt;b&gt;</code>元素。<br>使用这种技术可以插入一些帮助提示信息，例如在打开新窗口的链接旁边插入一幅图像。</p>
<p>除了向范围内部插入内容之外，还可以环绕范围插入内容。<br>surroundContents()这个方法接受一个参数，即环绕范围内容的节点。<br>后台会执行下列步骤。<br>(1) 提取出范围中的内容(类似执行extractContent())；<br>(2) 将给定节点插入到文档中原来范围所在的位置上；<br>(3) 将文档片段的内容添加到给定节点中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</div><div class="line">helloNode = p1.firstChild.firstChild;</div><div class="line">worldNode = p1.lastChild;</div><div class="line">range = <span class="built_in">document</span>.createRange();</div><div class="line">range.selectNode(helloNode);</div><div class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">"span"</span>);</div><div class="line">span.style.backgroundColor = <span class="string">"yellow"</span>;</div><div class="line">range.surroundContents(span);</div></pre></td></tr></table></figure>
<p>结果是，提取出helloNode的内容即文本节点”Hello”,把span插入原本的位置上，再把”Hello”插入span中：<br><code>&lt;p&gt;&lt;b&gt;&lt;span style=&quot;background-color:yellow&quot;&gt;Hello&lt;/span&gt;&lt;/b&gt; world!&lt;/p&gt;</code></p>
<p>为了插入<code>&lt;span&gt;</code>，范围必须包含整个DOM 选区(不能仅仅包含选中的DOM 节点)。</p>
<h3 id="折叠DOM-范围"><a href="#折叠DOM-范围" class="headerlink" title="折叠DOM 范围"></a>折叠DOM 范围</h3><p>折叠范围，就是指范围中未选择文档的任何部分。可以用文本框来描述折叠范围的过程。<br>假设文本框中有一行文本，你用鼠标选择了其中一个完整的单词。然后，你单击鼠标左键，选区消失，而光标则落在了其中两个字母之间。<br>在折叠范围时，其位置会落在文档中的两个部分之间，可能是范围选区的开始位置，也可能是结束位置。<br>使用collapse()方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠到范围的哪一端。<br>参数true 表示折叠到范围的起点，参数false 表示折叠到范围的终点。<br>要确定范围已经折叠完毕，可以检查collapsed 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">range.collapse(<span class="literal">true</span>); <span class="comment">//折叠到起点</span></div><div class="line">alert(range.collapsed); <span class="comment">//输出true</span></div></pre></td></tr></table></figure>
<p>检测某个范围是否处于折叠状态，可以帮我们确定范围中的两个节点是否紧密相邻。<br><code>&lt;p id=&quot;p1&quot;&gt;Paragraph 1&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;Paragraph 2&lt;/p&gt;</code><br>如果不知道其实际构成(比如说，这行代码是动态生成的)，那么可以创建一个范围。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>),</div><div class="line">p2 = <span class="built_in">document</span>.getElementById(<span class="string">"p2"</span>),</div><div class="line">range = <span class="built_in">document</span>.createRange();</div><div class="line">range.setStartAfter(p1);</div><div class="line">range.setStartBefore(p2);</div><div class="line">alert(range.collapsed); <span class="comment">//输出true</span></div></pre></td></tr></table></figure>
<p>在这个例子中，新创建的范围是折叠的，因为p1 的后面和p2 的前面什么也没有。<br>(所以p1和p2是相连的)<br>(但是，下面的比较 DOM 范围不是可以更加直接的发现是否是相连的么(比较第一个终点和第二个起点)？难道多新建一个Range对象就变成劣势了？)</p>
<h3 id="比较DOM-范围"><a href="#比较DOM-范围" class="headerlink" title="比较DOM 范围"></a>比较DOM 范围</h3><p>使用compareBoundaryPoints()方法来确定这些范围是否有公共的边界(起点或终点)。<br>这个方法接受两个参数：表示比较方式的常量值和要比较的范围。<br>表示比较方式的常量值:</p>
<ul>
<li>Range.START_TO_START(0)：比较第一个范围和第二个范围的起点；</li>
<li>Range.START_TO_END(1)：比较第一个范围的起点和第二个范围的终点；</li>
<li>Range.END_TO_END(2)：比较第一个范围和第二个范围的终点；</li>
<li>Range.END_TO_START(3)：比较第一个范围的终点和第一个范围的起点。</li>
</ul>
<p>compareBoundaryPoints()方法可能的返回值如下：如果第一个范围中的点位于第二个范围中的点之前，返回-1；<br>如果两个点相等，返回0；如果第一个范围中的点位于第二个范围中的点之后，返回1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange();</div><div class="line"><span class="keyword">var</span> range2 = <span class="built_in">document</span>.createRange();</div><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</div><div class="line">range1.selectNodeContents(p1);</div><div class="line">range2.selectNodeContents(p1);</div><div class="line">range2.setEndBefore(p1.lastChild);</div><div class="line">alert(range1.compareBoundaryPoints(Range.START_TO_START, range2)); <span class="comment">//0</span></div><div class="line">alert(range1.compareBoundaryPoints(Range.END_TO_END, range2)); <span class="comment">//1</span></div></pre></td></tr></table></figure>
<h3 id="复制DOM-范围"><a href="#复制DOM-范围" class="headerlink" title="复制DOM 范围"></a>复制DOM 范围</h3><p>使用cloneRange()方法复制范围。这个方法会创建调用它的范围的一个副本。<br><code>var newRange = range.cloneRange();</code><br>新创建的范围与原来的范围包含相同的属性，而修改它的端点不会影响原来的范围。</p>
<h3 id="清理DOM-范围"><a href="#清理DOM-范围" class="headerlink" title="清理DOM 范围"></a>清理DOM 范围</h3><p>使用完范围之后，最好是调用detach()方法，以便从创建范围的文档中分离出该范围。<br>调用detach()之后，就可以放心地解除对范围的引用，从而让垃圾回收机制回收其内存了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">range.detach(); <span class="comment">//从文档中分离</span></div><div class="line">range = <span class="literal">null</span>; <span class="comment">//解除引用</span></div></pre></td></tr></table></figure>
<p>在使用范围的最后再执行这两个步骤。一旦分离范围，就不能再恢复使用了。</p>
<h2 id="IE8-及更早版本中的范围"><a href="#IE8-及更早版本中的范围" class="headerlink" title="IE8 及更早版本中的范围"></a>IE8 及更早版本中的范围</h2><p>IE9 支持DOM 范围，但IE8 及之前版本不支持DOM范围。<br>IE8 及早期版本支持一种类似的概念，即文本范围(text range)。IE 专有的特性，其他浏览器都不支持。<br>文本范围处理的主要是文本(不一定是DOM 节点)。<br>通过<code>&lt;body&gt;</code>、<code>&lt;button&gt;</code>、<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>等这几个元素，可以调用createTextRange()方法来创建文本范围。<br><code>var range = document.body.createTextRange();</code><br>像这样通过document 创建的范围可以在页面中的任何地方使用(通过其他元素创建的范围则只能在相应的元素中使用)。</p>
<h3 id="用IE-范围实现简单的选择"><a href="#用IE-范围实现简单的选择" class="headerlink" title="用IE 范围实现简单的选择"></a>用IE 范围实现简单的选择</h3><p>选择页面中某一区域的最简单方式，就是使用范围的findText()方法。<br>法会找到第一次出现的给定文本，并将范围移过来以环绕该文本。<br>如果没有找到文本，这个方法返回false；否则返回true。<br><code>&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.body.createTextRange();</div><div class="line"><span class="keyword">var</span> found = range.findText(<span class="string">"Hello"</span>);</div><div class="line"></div><div class="line">alert(found); <span class="comment">//true</span></div><div class="line">alert(range.text); <span class="comment">//"Hello"</span></div></pre></td></tr></table></figure>
<p>还可以为findText()传入另一个参数，即一个表示向哪个方向继续搜索的数值。负值表示应该从当前位置向后搜索，而正值表示应该从当前位置向前搜索。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = range.findText(<span class="string">"Hello"</span>);</div><div class="line"><span class="keyword">var</span> foundAgain = range.findText(<span class="string">"Hello"</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>与DOM 中的selectNode()方法最接近的方法是moveToElementText()，接受一个DOM 元素，并选择该元素的所有文本，包括HTML 标签。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.body.createTextRange();</div><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</div><div class="line">range.moveToElementText(p1);</div></pre></td></tr></table></figure>
<p>在文本范围中包含HTML 的情况下，可以使用htmlText 属性取得范围的全部内容，包括HTML和文本。<br><code>alert(range.htmlText);</code></p>
<p>IE 的范围没有任何属性可以随着范围选区的变化而动态更新。<br>不过，其parentElement()方法倒是与DOM 的commonAncestorContainer 属性类似。<br><code>var ancestor = range.parentElement();</code><br>这样得到的父元素始终都可以反映文本选区的父节点。</p>
<h3 id="使用IE-范围实现复杂的选择"><a href="#使用IE-范围实现复杂的选择" class="headerlink" title="使用IE 范围实现复杂的选择"></a>使用IE 范围实现复杂的选择</h3><p>在IE 中创建复杂范围的方法，就是以特定的增量向四周移动范围。<br>move()、moveStart()、moveEnd()和expand()。这些方法都接受两个参数：移动单位和移动单位的数量。<br>移动单位是一种字符串值。</p>
<ul>
<li>“character”：逐个字符地移动。</li>
<li>“word”：逐个单词(一系列非空格字符)地移动。</li>
<li>“sentence”：逐个句子(一系列以句号、问号或叹号结尾的字符)地移动。</li>
<li>“textedit”：移动到当前范围选区的开始或结束位置。</li>
</ul>
<p>moveStart()方法可以移动范围的起点，通过moveEnd()方法可以移动范围的终点，移动的幅度由单位数量指定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">range.moveStart(<span class="string">"word"</span>, <span class="number">2</span>); <span class="comment">//起点移动2 个单词</span></div><div class="line">range.moveEnd(<span class="string">"character"</span>, <span class="number">1</span>); <span class="comment">//终点移动1 个字符</span></div></pre></td></tr></table></figure>
<p>expand()方法可以将范围规范化。expand()方法的作用是将任何部分选择的文本全部选中。<br>例如，当前选择的是一个单词中间的两个字符，调用expand(“word”)可以将整个单词都包含在范围之内。</p>
<p>move()方法则首先会折叠当前范围(让起点和终点相等)，然后再将范围移动指定的单位数量。<br><code>range.move(&quot;character&quot;, 5); //移动5 个字符</code><br>调用move()之后，范围的起点和终点相同，因此必须再使用moveStart()或moveEnd()创建新的选区。</p>
<h3 id="操作IE-范围中的内容"><a href="#操作IE-范围中的内容" class="headerlink" title="操作IE 范围中的内容"></a>操作IE 范围中的内容</h3><p>在IE 中操作范围中的内容可以使用text 属性或pasteHTML()方法。<br>通过text 属性可以取得范围中的内容文本；但是，也可以通过这个属性设置范围中的内容文本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.body.createTextRange();</div><div class="line">range.findText(<span class="string">"Hello"</span>);</div><div class="line">range.text = <span class="string">"Howdy"</span>;</div></pre></td></tr></table></figure>
<p>执行以上代码后:<code>&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Howdy&lt;/b&gt; world!&lt;/p&gt;</code><br>在设置text 属性的情况下，HTML 标签保持不变。</p>
<p>要向范围中插入HTML 代码，就得使用pasteHTML()方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.body.createTextRange();</div><div class="line">range.findText(<span class="string">"Hello"</span>);</div><div class="line">range.pasteHTML(<span class="string">"&lt;em&gt;Howdy&lt;/em&gt;"</span>);</div></pre></td></tr></table></figure>
<p>执行这些代码后:<code>&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;&lt;em&gt;Howdy&lt;/em&gt;&lt;/b&gt; world!&lt;/p&gt;</code><br>不过，在范围中包含HTML 代码时，不应该使用pasteHTML()，因为这样很容易导致不可预料的结果——很可能是格式不正确的HTML。</p>
<h3 id="折叠IE-范围"><a href="#折叠IE-范围" class="headerlink" title="折叠IE 范围"></a>折叠IE 范围</h3><p>IE 为范围提供的collapse()方法与相应的DOM 方法用法一样：<br>传入true 把范围折叠到起点，传入false 把范围折叠到终点。<br><code>range.collapse(true); //折叠到起点</code><br>可惜的是，没有对应的collapsed 属性让我们知道范围是否已经折叠完毕。<br>使用boundingWidth 属性，该属性返回范围的宽度(以像素为单位)。如果boundingWidth 属性等于0，就说明范围已经折叠了。<br><code>var isCollapsed = (range.boundingWidth == 0);</code><br>还有boundingHeight、boundingLeft 和boundingTop 等属性，虽然它们都不像boundingWidth 那么有用，但也可以提供一些有关范围位置的信息。</p>
<h3 id="比较IE-范围"><a href="#比较IE-范围" class="headerlink" title="比较IE 范围"></a>比较IE 范围</h3><p>IE 中的compareEndPoints()方法与DOM范围的compareBoundaryPoints()方法类似。<br>这个方法接受两个参数：比较的类型和要比较的范围。<br>比较类型的取值范围是几个字符串值：”StartToStart”、”StartToEnd”、”EndToEnd”和”EndToStart”。<br>这几种比较类型与比较DOM范围时使用的几个值是相同的。<br>同样与DOM类似的是，compareEndPoints()方法也会按照相同的规则返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.body.createTextRange();</div><div class="line"><span class="keyword">var</span> range2 = <span class="built_in">document</span>.body.createTextRange();</div><div class="line">range1.findText(<span class="string">"Hello world!"</span>);</div><div class="line">range2.findText(<span class="string">"Hello"</span>);</div><div class="line">alert(range1.compareEndPoints(<span class="string">"StartToStart"</span>, range2)); <span class="comment">//0</span></div><div class="line">alert(range1.compareEndPoints(<span class="string">"EndToEnd"</span>, range2)); <span class="comment">//1</span></div></pre></td></tr></table></figure>
<p>isEqual()用于确定两个范围是否相等，inRange()用于确定一个范围是否包含另一个范围。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.body.createTextRange();</div><div class="line"><span class="keyword">var</span> range2 = <span class="built_in">document</span>.body.createTextRange();</div><div class="line">range1.findText(<span class="string">"Hello World"</span>);</div><div class="line">range2.findText(<span class="string">"Hello"</span>);</div><div class="line">alert(<span class="string">"range1.isEqual(range2): "</span> + range1.isEqual(range2)); <span class="comment">//false</span></div><div class="line">alert(<span class="string">"range1.inRange(range2):"</span> + range1.inRange(range2)); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h3 id="复制IE-范围"><a href="#复制IE-范围" class="headerlink" title="复制IE 范围"></a>复制IE 范围</h3><p>在IE 中使用duplicate()方法可以复制文本范围，结果会创建原范围的一个副本。</p>
<p><code>var newRange = range.duplicate();</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十二章-3]]></title>
      <url>http://codingme.xyz/2016/10/09/javascript-note-12-3/</url>
      <content type="html"><![CDATA[<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>“DOM2 级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM 结构的类型：<br>NodeIterator和TreeWalker。<br>能够基于给定的起点对DOM 结构执行深度优先(depth-first)的遍历操作。<br>IE 不支持DOM 遍历。<br>检测浏览器对DOM2 级遍历能力的支持情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> supportsTraversals = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"Traversal"</span>, <span class="string">"2.0"</span>);</div><div class="line"><span class="keyword">var</span> supportsNodeIterator = (<span class="keyword">typeof</span> <span class="built_in">document</span>.createNodeIterator == <span class="string">"function"</span>);</div><div class="line"><span class="keyword">var</span> supportsTreeWalker = (<span class="keyword">typeof</span> <span class="built_in">document</span>.createTreeWalker == <span class="string">"function"</span>);</div></pre></td></tr></table></figure>
<p>DOM 遍历是深度优先的DOM 结构遍历，也就是说，移动的方向至少有两个(取决于使用的遍历类型)。<br>遍历以给定节点为根，不可能向上超出DOM 树的根节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>假设<code>&lt;body&gt;</code>元素为根节点，那么遍历的第一步就是访问<code>&lt;p&gt;</code>元素，然后再访问同为<code>&lt;body&gt;</code>元素后代的两个文本节点。<br>这次遍历永远不会到达<code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>元素，也不会到达不属于<code>&lt;body&gt;</code>元素子树的任何节点。</p>
<h2 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h2><p>可以使用document.createNodeIterator()方法创建它的新实例。</p>
<ul>
<li>root：想要作为搜索起点的树中的节点。</li>
<li>whatToShow：表示要访问哪些节点的数字代码。</li>
<li>filter：是一个NodeFilter 对象，或者一个表示应该接受还是拒绝某种特定节点的函数。</li>
<li>entityReferenceExpansion：布尔值，表示是否要扩展实体引用。这个参数在HTML 页面中没有用，因为其中的实体引用不能扩展。</li>
</ul>
<p>whatToShow 参数是一个位掩码，通过应用一或多个过滤器(filter)来确定要访问哪些节点。<br>这个参数的值以常量形式在NodeFilter 类型中定义。</p>
<ul>
<li>NodeFilter.SHOW_ALL：显示所有类型的节点。</li>
<li>NodeFilter.SHOW_ELEMENT：显示元素节点。</li>
<li>NodeFilter.SHOW_ATTRIBUTE：显示特性节点。由于DOM结构原因，实际上不能使用这个值。</li>
<li>NodeFilter.SHOW_TEXT：显示文本节点。</li>
<li>NodeFilter.SHOW_CDATA_SECTION：显示CDATA 节点。对HTML 页面没有用。</li>
<li>NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML 页面没有用。</li>
<li>NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML 页面没有用。</li>
<li>NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML 页面没有用。</li>
<li>NodeFilter.SHOW_COMMENT：显示注释节点。</li>
<li>NodeFilter.SHOW_DOCUMENT：显示文档节点。</li>
<li>NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型节点。</li>
<li>NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段节点。对HTML 页面没有用。</li>
<li>NodeFilter.SHOW_NOTATION：显示符号节点。对HTML 页面没有用。</li>
</ul>
<p>除了NodeFilter.SHOW_ALL 之外，可以使用按位或操作符来组合多个选项。<br><code>var whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT;</code><br>可以通过createNodeIterator()方法的filter 参数来指定自定义的NodeFilter 对象，或者指定一个功能类似节点过滤器(node filter)的函数。<br>每个NodeFilter 对象只有一个方法，即acceptNode()；<br>如果应该访问给定的节点，该方法返回NodeFilter.FILTER_ACCEPT，<br>如果不应该访问给定的节点，该方法返回NodeFilter.FILTER_SKIP。<br>由于NodeFilter 是一个抽象的类型，因此不能直接创建它的实例。<br>在必要时，只要创建一个包含acceptNode()方法的对象，然后将这个对象传入createNodeIterator()中即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> filter = &#123;</div><div class="line">acceptNode: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">"p"</span> ?</div><div class="line">    NodeFilter.FILTER_ACCEPT :</div><div class="line">    NodeFilter.FILTER_SKIP;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(root, NodeFilter.SHOW_ELEMENT,</div><div class="line">filter, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>第三个参数也可以是一个与acceptNode()方法类似的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> filter = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">"p"</span> ?</div><div class="line">    NodeFilter.FILTER_ACCEPT :</div><div class="line">    NodeFilter.FILTER_SKIP;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(root, NodeFilter.SHOW_ELEMENT,</div><div class="line">filter, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>一般来说，这就是在JavaScript 中使用这个方法的形式，这种形式比较简单，而且也跟其他的JavaScript 代码很相似。<br>如果不指定过滤器，那么应该在第三个参数的位置上传入null。<br>一个能够访问所有类型节点的简单的NodeIterator:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(<span class="built_in">document</span>, NodeFilter.SHOW_ALL,</div><div class="line"><span class="literal">null</span>, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>NodeIterator 类型的两个主要方法是nextNode()和previousNode()。<br>在深度优先的DOM 子树遍历中，nextNode()方法用于向前前进一步，而previousNode()用于向后后退一步。<br>在刚刚创建的NodeIterator 对象中，有一个内部指针指向根节点，因此第一次调用nextNode()会返回根节点。<br>当遍历到DOM 子树的最后一个节点时，nextNode()返回null。<br>previousNode()方法的工作机制类似。<br>当遍历到DOM 子树的最后一个节点，且previousNode()返回根节点之后，再次调用它就会返回null。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</div><div class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(div, NodeFilter.SHOW_ELEMENT,</div><div class="line"><span class="literal">null</span>, <span class="literal">false</span>);</div><div class="line"><span class="keyword">var</span> node = iterator.nextNode();</div><div class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</div><div class="line">    alert(node.tagName); <span class="comment">//输出标签名</span></div><div class="line">    node = iterator.nextNode();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次调用nextNode()返回<code>&lt;p&gt;</code>元素。<br>执行上面的代码会显示如下标签名：<br>DIV<br>P<br>B<br>UL<br>LI<br>LI<br>LI</p>
<p>只想返回遍历中遇到的<code>&lt;li&gt;</code>元素的话只要使用一个过滤器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">var filter = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> node.tagName.toLowerCase() == <span class="string">"li"</span> ?</div><div class="line">    NodeFilter.FILTER_ACCEPT :</div><div class="line">    NodeFilter.FILTER_SKIP;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> iterator = <span class="built_in">document</span>.createNodeIterator(div, NodeFilter.SHOW_ELEMENT,</div><div class="line">filter, <span class="literal">false</span>);</div><div class="line">...</div></pre></td></tr></table></figure>
<p>由于nextNode()和previousNode()方法都基于NodeIterator 在DOM 结构中的内部指针工作，所以DOM 结构的变化会反映在遍历的结果中。</p>
<h2 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h2><p>TreeWalker 是NodeIterator 的一个更高级的版本。<br>除了包括nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM 结构的方法。</p>
<ul>
<li>parentNode()：遍历到当前节点的父节点；</li>
<li>firstChild()：遍历到当前节点的第一个子节点；</li>
<li>lastChild()：遍历到当前节点的最后一个子节点；</li>
<li>nextSibling()：遍历到当前节点的下一个同辈节点；</li>
<li>previousSibling()：遍历到当前节点的上一个同辈节点。</li>
</ul>
<p>document.createTreeWalker()方法，这个方法接受的4 个参数与document.createNodeIterator()方法相同：作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。<br>由于这两个创建方法很相似，所以很容易用TreeWalker来代替NodeIterator。</p>
<p>在使用NodeIterator 对象时，NodeFilter.FILTER_SKIP 与 NodeFilter.FILTER_REJECT 的作用相同：跳过指定的节点。<br>但在使用TreeWalker 对象时，NodeFilter.FILTER_SKIP 会跳过相应节点继续前进到子树中的下一个节点，<br>而NodeFilter.FILTER_REJECT 则会跳过相应节点及该节点的整个子树。</p>
<p>例如，将前面例子中的NodeFilter.FILTER_SKIP 修改成 NodeFilter.FILTER_REJECT，结果就是不会访问任何节点。<br>因为第一个返回的节点是<code>&lt;div&gt;</code>，它的标签名不是”li”，于是就会返回NodeFilter.FILTER_REJECT，<br>这意味着遍历会跳过整个子树。在这个例子中，<code>&lt;div&gt;</code>元素是遍历的根节点，于是结果就会停止遍历。</p>
<p>TreeWalker 真正强大的地方在于能够在DOM结构中沿任何方向移动。<br>使用TreeWalker遍历DOM 树，即使不定义过滤器，也可以取得所有<code>&lt;li&gt;</code>元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"div1"</span>);</div><div class="line"><span class="keyword">var</span> walker = <span class="built_in">document</span>.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, <span class="literal">null</span>, <span class="literal">false</span>);</div><div class="line">walker.firstChild(); <span class="comment">//转到&lt;p&gt;</span></div><div class="line">walker.nextSibling(); <span class="comment">//转到&lt;ul&gt;</span></div><div class="line"><span class="keyword">var</span> node = walker.firstChild(); <span class="comment">//转到第一个&lt;li&gt;</span></div><div class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</div><div class="line">    alert(node.tagName);</div><div class="line">    node = walker.nextSibling();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TreeWalker 类型还有一个属性，名叫currentNode，表示任何遍历方法在上一次遍历中返回的节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> node = walker.nextNode();</div><div class="line">alert(node === walker.currentNode); <span class="comment">//true</span></div><div class="line">walker.currentNode = <span class="built_in">document</span>.body; <span class="comment">//修改起点</span></div></pre></td></tr></table></figure>
<p>与NodeIterator 相比，TreeWalker 类型在遍历DOM时拥有更大的灵活性。<br>由于IE 中没有对应的类型和方法，所以使用遍历的跨浏览器解决方案非常少见。</p>
<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><p>“DOM2 级遍历和范围”模块定义了“范围”(range)接口。<br>Firefox、Opera、Safari 和Chrome 都支持DOM 范围。IE 以专有方式实现了自己的范围特性。</p>
<h2 id="DOM中的范围"><a href="#DOM中的范围" class="headerlink" title="DOM中的范围"></a>DOM中的范围</h2><p>createRange()方法在兼容DOM 的浏览器中，这个方法属于document 对象。<br>通过范围可以选择文档中的一个区域，而不必考虑节点的界限。<br>使用hasFeature()或者直接检测该方法，都可以确定浏览器是否支持范围。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> supportsRange = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"Range"</span>, <span class="string">"2.0"</span>);</div><div class="line"><span class="keyword">var</span> alsoSupportsRange = (<span class="keyword">typeof</span> <span class="built_in">document</span>.createRange == <span class="string">"function"</span>);</div></pre></td></tr></table></figure>
<p>如果浏览器支持范围，那么就可以使用createRange()来创建DOM范围。<br><code>var range = document.createRange();</code></p>
<p>与节点类似，新创建的范围也直接与创建它的文档关联在一起，不能用于其他文档。<br>创建了范围之后，接下来就可以使用它在后台选择文档中的特定部分。<br>创建范围并设置了其位置之后，还可以针对范围的内容执行很多种操作，从而实现对底层DOM 树的更精细的控制。</p>
<p>每个范围由一个Range 类型的实例表示，这个实例拥有很多属性和方法。</p>
<ul>
<li>startContainer：包含范围起点的节点(即选区中第一个节点的父节点)。</li>
<li>startOffset：范围在startContainer 中起点的偏移量。如果startContainer 是文本节点、注释节点或CDATA 节点，那么startOffset 就是范围起点之前跳过的字符数量。否则，startOffset 就是范围中第一个子节点的索引。</li>
<li>endContainer：包含范围终点的节点(即选区中最后一个节点的父节点)。</li>
<li>endOffset：范围在endContainer 中终点的偏移量(与startOffset 遵循相同的取值规则)。</li>
<li>commonAncestorContainer：startContainer 和endContainer 共同的祖先节点在文档树中位置最深的那个。</li>
</ul>
<h3 id="用DOM-范围实现简单选择"><a href="#用DOM-范围实现简单选择" class="headerlink" title="用DOM 范围实现简单选择"></a>用DOM 范围实现简单选择</h3><p>要使用范围来选择文档中的一部分，最简的方式就是使用selectNode()或selectNodeContents()。<br>这两个方法都接受一个参数，即一个DOM 节点，然后使用该节点中的信息来填充范围。<br>selectNode()方法选择整个节点，包括其子节点；而selectNodeContents()方法则只选择节点的子节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange();</div><div class="line">range2 = <span class="built_in">document</span>.createRange();</div><div class="line">p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</div><div class="line">range1.selectNode(p1);</div><div class="line">range2.selectNodeContents(p1);</div></pre></td></tr></table></figure>
<p>在调用selectNode()时，startContainer、endContainer 和commonAncestorContainer都等于传入节点的父节点，也就是这个例子中的document.body。<br>startOffset 属性等于给定节点在其父节点的childNodes 集合中的索引(在这个例子中是1——因为兼容DOM的浏览器将空格算作一个文本节点)，<br>endOffset 等于startOffset 加1(因为只选择了一个节点)。<br>在调用selectNodeContents()时，startContainer、endContainer 和commonAncestorContainer等于传入的节点，即这个例子中的<code>&lt;p&gt;</code>元素。<br>startOffset 属性始终等于0，因为范围从给定节点的第一个子节点开始。最后，endOffset 等于子节点的数量(node.childNodes.length)，在这个例子中是2。</p>
<p>此外，为了更精细地控制将哪些节点包含在范围中，还可以使用下列方法。</p>
<ul>
<li>setStartBefore(refNode)：将范围的起点设置在refNode 之前，因此refNode 也就是范围选区中的第一个子节点。同时会将startContainer 属性设置为refNode.parentNode，将startOffset 属性设置为refNode 在其父节点的childNodes 集合中的索引。</li>
<li>setStartAfter(refNode)：将范围的起点设置在refNode 之后，因此refNode 也就不在范围之内了，其下一个同辈节点才是范围选区中的第一个子节点。同时会将startContainer 属性设置为refNode.parentNode，将startOffset 属性设置为refNode 在其父节点的childNodes 集合中的索引加1。</li>
<li>setEndBefore(refNode)：将范围的终点设置在refNode 之前，因此refNode 也就不在范围之内了，其上一个同辈节点才是范围选区中的最后一个子节点。同时会将endContainer 属性设置为refNode.parentNode，将endOffset 属性设置为refNode 在其父节点的childNodes集合中的索引。</li>
<li>setEndAfter(refNode)：将范围的终点设置在refNode 之后，因此refNode 也就是范围选区中的最后一个子节点。同时会将endContainer 属性设置为refNode.parentNode，将endOffset 属性设置为refNode 在其父节点的childNodes 集合中的索引加1。</li>
</ul>
<p>###　用DOM 范围实现复杂选择</p>
<p>要创建复杂的范围就得使用setStart()和setEnd()方法。<br>都接受两个参数：一个参照节点和一个偏移量值。<br>对setStart()来说，参照节点会变成startContainer，而偏移量值会变成startOffset。<br>对于setEnd()来说，参照节点会变成endContainer，而偏移量值会变成endOffset。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> range1 = <span class="built_in">document</span>.createRange();</div><div class="line">range2 = <span class="built_in">document</span>.createRange();</div><div class="line">p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</div><div class="line">p1Index = <span class="number">-1</span>;</div><div class="line">i, len;</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>, len=p1.parentNode.childNodes.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (p1.parentNode.childNodes[i] == p1) &#123;</div><div class="line">        p1Index = i;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">range1.setStart(p1.parentNode, p1Index);</div><div class="line">range1.setEnd(p1.parentNode, p1Index + <span class="number">1</span>);</div><div class="line">range2.setStart(p1, <span class="number">0</span>);</div><div class="line">range2.setEnd(p1, p1.childNodes.length);</div></pre></td></tr></table></figure>
<p>要选择这个节点(使用range1)，就必须确定当前节点(p1)在其父节点的childNodes集合中的索引。<br>而要选择这个节点的内容(使用range2)，也不必计算什么；只要通过setStart()和setEnd()设置默认值即可。<br>模仿selectNode()和selectNodeContents()并不是setStart()和setEnd()的主要用途，它们更胜一筹的地方在于能够选择节点的一部分。</p>
<p>假设只想选择前面HTML 示例代码中从”Hello”的”llo”到”world!”的”o”——很容易做到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">"p1"</span>);</div><div class="line">helloNode = p1.firstChild.firstChild;</div><div class="line">worldNode = p1.lastChild;</div><div class="line"></div><div class="line"><span class="keyword">var</span> range = <span class="built_in">document</span>.createRange();</div><div class="line">range.setStart(helloNode, <span class="number">2</span>);</div><div class="line">rang e.setEnd(worldNode, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>这个范围的选区应该从”Hello”中”e”的后面开始，所以在setStart()中传入helloNode的同时，传入了偏移量2(即”e”的下一个位置；”H”的位置是0)。<br>设置选区的终点时，在setEnd()中传入worldNode 的同时传入了偏移量3，表示选区之外的第一个字符的位置，这个字符是”r”，它的位置是3(位置0 上还有一个空格)<br>由于helloNode 和worldNode 都是文本节点，因此它们分别变成了新建范围的startContainer和endContainer。<br>此时startOffset 和endOffset 分别用以确定两个节点所包含的文本中的位置，而不是用以确定子节点的位置(就像传入的参数为元素节点时那样)。<br>此时的commonAncestorContainer 是<code>&lt;p&gt;</code>元素，也就是同时包含这两个节点的第一个祖先元素。</p>
<p>仅仅是选择了文档中的某一部分用处并不大。但重要的是，选择之后才可以对选区进行操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十二章-2]]></title>
      <url>http://codingme.xyz/2016/10/08/javascript-note-12-2/</url>
      <content type="html"><![CDATA[<h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><p>定义样式的方式有3 种：通过<code>&lt;link/&gt;</code>元素包含外部样式表文件、[外联]<br>使用<code>&lt;style/&gt;</code>元素定义嵌入式样式，[内联]<br>以及使用style 特性定义针对特定元素的样式。[行内]</p>
<p>可以用来确定浏览器是否支持DOM2 级定义的CSS 能力：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> supportsDOM2CSS = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"CSS"</span>, <span class="string">"2.0"</span>);</div><div class="line"><span class="keyword">var</span> supportsDOM2CSS2 = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"CSS2"</span>, <span class="string">"2.0"</span>);</div></pre></td></tr></table></figure>
<h2 id="访问元素的样式"><a href="#访问元素的样式" class="headerlink" title="访问元素的样式"></a>访问元素的样式</h2><p>任何支持style 特性的HTML 元素在JavaScript 中都有一个对应的style 属性。<br>这个style 对象是CSSStyleDeclaration 的实例，包含着通过HTML 的style 特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表经层叠而来的样式。<br>在style 特性中指定的任何CSS 属性都将表现为这个style 对象的相应属性。<br>对于使用短划线(分隔不同的词汇，例如background-image)的CSS 属性名，必须将其转换成驼峰大小写形式，才能通过JavaScript 来访问。</p>
<p>例如:</p>
<pre><code>background-image    style.backgroundImage
color               style.color
display             style.display
font-family         style.fontFamily
</code></pre><a id="more"></a>
<p>多数情况下，都可以简单地转换属性名的格式来实现转换。<br>但是float就不行，因为它是Javascript的保留字，因此不能用来做属性名。<br>所以css的float在对象上对应的属性名应该是cssFloat;大部分浏览器都支持。<br>而IE支持的则是styleFloat。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="comment">//设置背景颜色</span></div><div class="line">myDiv.style.backgroundColor = <span class="string">"red"</span>;</div><div class="line"><span class="comment">//改变大小</span></div><div class="line">myDiv.style.width = <span class="string">"100px"</span>;</div><div class="line">myDiv.style.height = <span class="string">"200px"</span>;</div><div class="line"><span class="comment">//指定边框</span></div><div class="line">myDiv.style.border = <span class="string">"1px solid black"</span>;</div></pre></td></tr></table></figure>
<p>在实践中，最好始终都指定度量单位。否则标准模式下会因为没有度量单位而导致数值被忽略。</p>
<p>通过style 对象同样可以取得在style 特性中指定的样式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(myDiv.style.backgroundColor); <span class="comment">//"blue"</span></div><div class="line">alert(myDiv.style.width); <span class="comment">//"10px"</span></div><div class="line">alert(myDiv.style.height); <span class="comment">//"25px"</span></div></pre></td></tr></table></figure>
<p>如果没有为元素设置style 特性，那么style 对象中可能会包含一些默认的值，但这些值并不能准确地反映该元素的样式信息。</p>
<h3 id="DOM-样式属性和方法"><a href="#DOM-样式属性和方法" class="headerlink" title="DOM 样式属性和方法"></a>DOM 样式属性和方法</h3><p>提供元素的style特性值的同时，也可以修改样式的属性和方法。</p>
<ul>
<li>cssText：如前所述，通过它能够访问到style 特性中的CSS 代码。</li>
<li>length：应用给元素的CSS 属性的数量。</li>
<li>parentRule：表示CSS 信息的CSSRule 对象。</li>
<li>getPropertyCSSValue(propertyName)：返回包含给定属性值的CSSValue 对象。</li>
<li>getPropertyPriority(propertyName)：如果给定的属性使用了!important 设置，则返回”important”；否则，返回空字符串。</li>
<li>getPropertyValue(propertyName)：返回给定属性的字符串值。</li>
<li>item(index)：返回给定位置的CSS 属性的名称。</li>
<li>removeProperty(propertyName)：从样式中删除给定属性。</li>
<li>setProperty(propertyName,value,priority)：将给定属性设置为相应的值，并加上优先权标志(“important”或者一个空字符串)。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myDiv.style.cssText = <span class="string">"width: 25px; height: 100px; background-color: green"</span>;</div><div class="line">alert(myDiv.style.cssText);</div></pre></td></tr></table></figure>
<p>设置cssText 是为元素应用多项变化最快捷的方式，因为可以一次性地应用所有变化。<br>设计length 属性的目的，就是将其与item()方法配套使用，以便迭代在元素中定义的CSS 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=myDiv.style.length; i &lt; len; i++)&#123;</div><div class="line">    alert(myDiv.style[i]); <span class="comment">//或者myDiv.style.item(i)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论是使用方括号语法还是使用item()方法，都可以取得CSS 属性名(“background-color”，不是”backgroundColor”)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prop, value, i, len;</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>, len=myDiv.style.length; i &lt; len; i++)&#123;</div><div class="line">    prop = myDiv.style[i]; <span class="comment">//或者 myDiv.style.item(i)</span></div><div class="line">    value = myDiv.style.getPropertyValue(prop);</div><div class="line">    alert(prop + <span class="string">" : "</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getPropertyValue()方法取得的始终都是CSS 属性值的字符串表示。<br>如果用getPropertyCSSValue()方法，它返回一个包含两个属性的CSSValue 对象，这两个属性分别是：cssText 和cssValueType。其中，cssText 属性的值与getPropertyValue()返回的值相同，而cssValueType 属性则是一个数值常量，表示值的类型：0 表示继承的值，1 表示基本的值，2 表示<br>值列表，3 表示自定义的值。</p>
<p>在实际开发中，getPropertyCSSValue()使用得比getPropertyValue()少得多。IE9+、Safari3+以及Chrome 支持这个方法。Firefox 7 及之前版本也提供这个访问，但调用总返回null。</p>
<p>要从元素的样式中移除某个CSS 属性，需要使用removeProperty()方法。使用这个方法移除一个属性，意味着将会为该属性应用默认的样式(从其他样式表经层叠而来)。<br>在不确定某个给定的CSS 属性拥有什么默认值的情况下，就可以使用这个方法。只要移除相应的属性，就可以为元素应用默认值。</p>
<h3 id="计算的样式"><a href="#计算的样式" class="headerlink" title="计算的样式"></a>计算的样式</h3><p>document.defaultView，提供了getComputedStyle()方法。<br>getComputedStyle()方法返回一个CSSStyleDeclaration 对象(与style 属性的类型相同)，其中包含当前元素的所有计算的样式。<br>这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串(例如”:after”)。如果不需要伪元素信息，第二个参数可以是null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="keyword">var</span> computedStyle = <span class="built_in">document</span>.defaultView.getComputedStyle(myDiv, <span class="literal">null</span>);</div><div class="line">alert(computedStyle.backgroundColor); <span class="comment">// "red"</span></div><div class="line">alert(computedStyle.width); <span class="comment">// "100px"</span></div><div class="line">alert(computedStyle.height); <span class="comment">// "200px"</span></div><div class="line">alert(computedStyle.border); <span class="comment">// 在某些浏览器中是"1px solid black"</span></div></pre></td></tr></table></figure>
<p>边框属性可能会也可能不会返回样式表中实际的border 规则(Opera 会返回，但其他浏览器不会)。<br>存在这个差别的原因是不同浏览器解释综合(rollup)属性(如border)的方式不同，因为设置这种属性实际上会涉及很多其他属性。</p>
<p>IE 不支持getComputedStyle(),但有一个currentStyle 属性。这个属性是CSSStyleDeclaration 的实例，包含当前元素全部计算后的样式。<br>与DOM 版本的方式一样，IE 也没有返回border 样式，因为这是一个综合属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="keyword">var</span> computedStyle = myDiv.currentStyle;</div><div class="line">alert(computedStyle.backgroundColor); <span class="comment">//"red"</span></div><div class="line">alert(computedStyle.width); <span class="comment">//"100px"</span></div><div class="line">alert(computedStyle.height); <span class="comment">//"200px"</span></div><div class="line">alert(computedStyle.border); <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>所有计算的样式都是只读的；不能修改计算后样式对象中的CSS 属性。<br>计算后的样式也包含属于浏览器内部样式表的样式信息，因此任何具有默认值的CSS 属性都会表现在计算后的样式中。<br>不能指望某个CSS 属性的默认值在不同浏览器中是相同的。<br>如果你需要元素具有某个特定的默认值，应该手工在样式表中指定该值。</p>
<h2 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h2><p>CSSStyleSheet 类型表示的是样式表，包括通过<code>&lt;link&gt;</code>元素包含的样式表和在<code>&lt;style&gt;</code>元素中定义的样式表。<br>这两个元素本身分别是由HTMLLinkElement 和HTMLStyleElement 类型表示的。<br>但是，CSSStyleSheet 类型相对更加通用一些，它只表示样式表，而不管这些样式表在HTML中是如何定义的。<br>上述两个针对元素的类型允许修改HTML 特性，但CSSStyleSheet 对象则是一套只读的接口(有一个属性例外)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//确定浏览器是否支持DOM2 级样式表。</span></div><div class="line"><span class="keyword">var</span> supportsDOM2StyleSheets =</div><div class="line"><span class="built_in">document</span>.implementation.hasFeature(<span class="string">"StyleSheets"</span>, <span class="string">"2.0"</span>);</div></pre></td></tr></table></figure>
<p>CSSStyleSheet 继承自StyleSheet，后者可以作为一个基础接口来定义非CSS 样式表。</p>
<ul>
<li>disabled：表示样式表是否被禁用的布尔值。这个属性是可读/写的，将这个值设置为true 可以禁用样式表。</li>
<li>href：如果样式表是通过<code>&lt;link&gt;</code>包含的，则是样式表的URL；否则，是null。</li>
<li>media：当前样式表支持的所有媒体类型的集合。与所有DOM 集合一样，这个集合也有一个length 属性和一个item()方法。<br>  也可以使用方括号语法取得集合中特定的项。如果集合是空列表，表示样式表适用于所有媒体。<br>  在IE 中，media 是一个反映<code>&lt;link&gt;</code>和<code>&lt;style&gt;</code>元素media特性值的字符串。</li>
<li>ownerNode：指向拥有当前样式表的节点的指针，样式表可能是在HTML 中通过<code>&lt;link&gt;</code>或<code>&lt;style/&gt;</code>引入的(在XML 中可能是通过处理指令引入的)。<br>  如果当前样式表是其他样式表通过@import 导入的，则这个属性值为null。IE 不支持这个属性。</li>
<li>parentStyleSheet：在当前样式表是通过@import 导入的情况下，这个属性是一个指向导入它的样式表的指针。</li>
<li>title：ownerNode 中title 属性的值。</li>
<li>type：表示样式表类型的字符串。对CSS 样式表而言，这个字符串是”type/css”。</li>
</ul>
<p>除了disabled 属性之外，其他属性都是只读的。<br>CSSStyleSheet 类型还支持下列属性和方法：</p>
<ul>
<li>cssRules：样式表中包含的样式规则的集合。IE 不支持这个属性，但有一个类似的rules 属性。</li>
<li>ownerRule：如果样式表是通过@import 导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为null。IE 不支持这个属性。</li>
<li>deleteRule(index)：删除cssRules 集合中指定位置的规则。IE 不支持这个方法，但支持一个类似的removeRule()方法。</li>
<li>insertRule(rule,index)：向cssRules 集合中指定的位置插入rule 字符串。IE 不支持这个方法，但支持一个类似的addRule()方法。</li>
</ul>
<p>应用于文档的所有样式表是通过document.styleSheets 集合来表示的。<br>通过这个集合的length属性可以获知文档中样式表的数量，而通过方括号语法或item()方法可以访问每一个样式表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sheet = <span class="literal">null</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=<span class="built_in">document</span>.styleSheets.length; i &lt; len; i++)&#123;</div><div class="line">    sheet = <span class="built_in">document</span>.styleSheets[i];</div><div class="line">    alert(sheet.href);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码可以输出文档中使用的每一个样式表的href 属性(<code>&lt;style&gt;</code>元素包含的样式表没有href 属性)。</p>
<p>也可以直接通过<code>&lt;link&gt;</code>或<code>&lt;style&gt;</code>元素取得CSSStyleSheet 对象。DOM 规定了一个包含CSSStyleSheet 对象的属性，名叫sheet；除了IE，其他浏览器都支持这个属性。IE 支持的是styleSheet 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyleSheet</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> element.sheet || element.styleSheet;</div><div class="line">&#125;</div><div class="line"><span class="comment">//取得第一个&lt;link/&gt;元素引入的样式表</span></div><div class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"link"</span>)[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> sheet = getStylesheet(link);</div></pre></td></tr></table></figure>
<p>getStyleSheet()返回的样式表对象与document.styleSheets 集合中的样式表对象相同。</p>
<h3 id="CSS-规则"><a href="#CSS-规则" class="headerlink" title="CSS 规则"></a>CSS 规则</h3><p>CSSRule 对象表示样式表中的每一条规则。<br>CSSRule 是一个供其他多种类型继承的基类型，其中最常见的就是CSSStyleRule 类型，表示样式信息。<br>(其他规则还有@import、@font-face、@page 和@charset，但这些规则很少有必要通过脚本来访问)<br>CSSStyleRule 对象包含:</p>
<ul>
<li>cssText：返回整条规则对应的文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样；Safari 始终都会将文本转换成全部小写。IE 不支持这个属性。</li>
<li>parentRule：如果当前规则是导入的规则，这个属性引用的就是导入规则；否则，这个值为null。IE 不支持这个属性。</li>
<li>parentStyleSheet：当前规则所属的样式表。IE 不支持这个属性。</li>
<li>selectorText：返回当前规则的选择符文本。由于浏览器对样式表的内部处理方式不同，返回的文本可能会与样式表中实际的文本不一样(例如，Safari 3 之前的版本始终会将文本转换成全部小写)。在Firefox、Safari、Chrome 和IE 中这个属性是只读的。Opera 允许修改selectorText。</li>
<li>style：一个CSSStyleDeclaration 对象，可以通过它设置和取得规则中特定的样式值。</li>
<li>type：表示规则类型的常量值。对于样式规则，这个值是1。IE 不支持这个属性。</li>
</ul>
<p>最常用的属性是cssText、selectorText 和style。<br>cssText 属性与style.cssText属性类似，但并不相同。前者包含选择符文本和围绕样式信息的花括号，后者只包含样式信息(类似于元素的style.cssText)。<br>cssText 是只读的，而style.cssText 也可以被重写。</p>
<p>大多数情况下，仅使用style 属性就可以满足所有操作样式规则的需求了。这个对象就像每个元素上的style 属性一样，可以通过它读取和修改规则中的样式信息。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-class">.box</span> &#123;</div><div class="line"><span class="attribute">background-color</span>: blue;</div><div class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sheet = <span class="built_in">document</span>.styleSheets[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> rules = sheet.cssRules || sheet.rules; <span class="comment">//取得规则列表</span></div><div class="line"><span class="keyword">var</span> rule = rules[<span class="number">0</span>]; <span class="comment">//取得第一条规则</span></div><div class="line">alert(rule.selectorText); <span class="comment">//"div.box"</span></div><div class="line">alert(rule.style.cssText); <span class="comment">//完整的CSS 代码</span></div><div class="line">alert(rule.style.backgroundColor); <span class="comment">//"blue"</span></div><div class="line">alert(rule.style.width); <span class="comment">//"100px"</span></div><div class="line">alert(rule.style.height); <span class="comment">//"200px"</span></div><div class="line"></div><div class="line"><span class="comment">//在这种方式下也可以修改样式信息</span></div><div class="line">rule.style.backgroundColor = <span class="string">"red"</span></div></pre></td></tr></table></figure>
<h3 id="创建规则"><a href="#创建规则" class="headerlink" title="创建规则"></a>创建规则</h3><p>DOM 规定，要向现有样式表中添加新规则，需要使用insertRule()方法。这个方法接受两个参数：规则文本和表示在哪里插入规则的索引。<br><code>sheet.insertRule(&quot;body { background-color: silver }&quot;, 0); //DOM 方法</code></p>
<p>这个例子插入的规则会改变元素的背景颜色。插入的规则将成为样式表中的第一条规则(插入到了位置0)。<br>IE8 及更早版本支持一个类似的方法，名叫addRule()，也接收两必选参数：选择符文本和CSS样式信息；一个可选参数：插入规则的位置。<br><code>sheet.addRule(&quot;body&quot;, &quot;background-color: silver&quot;, 0); //仅对IE 有效</code><br>有关这个方法的规定中说，最多可以使用addRule()添加4 095 条样式规则。超出这个上限的调用将会导致错误。</p>
<p>组装函数,这个函数接受4个参数：要向其中添加规则的样式表以及与addRule()相同的3个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertRule</span>(<span class="params">sheet, selectorText, cssText, position</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (sheet.insertRule)&#123;</div><div class="line">        sheet.insertRule(selectorText + <span class="string">"&#123;"</span> + cssText + <span class="string">"&#125;"</span>, position);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sheet.addRule)&#123;</div><div class="line">        sheet.addRule(selectorText, cssText, position);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">insertRule(<span class="built_in">document</span>.styleSheets[<span class="number">0</span>], <span class="string">"body"</span>, <span class="string">"background-color: silver"</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>虽然可以像这样来添加规则，但随着要添加规则的增多，这种方法就会变得非常繁琐。因此，如果要添加的规则非常多，建议还是采用动态加载样式表的技术。</p>
<h3 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h3><p>deleteRule()，这个方法接受一个参数：要删除的规则的位置。<br><code>sheet.deleteRule(0); //DOM 方法</code><br>IE 支持的类似方法叫removeRule()，使用方法相同。<br><code>sheet.removeRule(0); //仅对IE 有效</code></p>
<p>同样写成函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteRule</span>(<span class="params">sheet, index</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (sheet.deleteRule)&#123;</div><div class="line">        sheet.deleteRule(index);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sheet.removeRule)&#123;</div><div class="line">        sheet.removeRule(index);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与添加规则相似，删除规则也不是实际Web 开发中常见的做法。</p>
<h2 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h2><h3 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h3><p>(offset dimension)，包括元素在屏幕上占用的所有可见的空间。<br>元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小(注意，不包括外边距)。</p>
<ul>
<li>offsetHeight：元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、(可见的)水平滚动条的高度、上边框高度和下边框高度。</li>
<li>offsetWidth：元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、(可见的)垂直滚动条的宽度、左边框宽度和右边框宽度。</li>
<li>offsetLeft：元素的左外边框至包含元素的左内边框之间的像素距离。</li>
<li>offsetTop：元素的上外边框至包含元素的上内边框之间的像素距离。</li>
</ul>
<p>其中，offsetLeft 和offsetTop 属性与包含元素有关，包含元素的引用保存在offsetParent属性中。offsetParent 属性不一定与parentNode 的值相等。</p>
<p>要想知道某个元素在页面上的偏移量，将这个元素的offsetLeft 和offsetTop 与其offsetParent的相同属性相加，如此循环直至根元素，就可以得到一个基本准确的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementLeft</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> actualLeft = element.offsetLeft;</div><div class="line">    <span class="keyword">var</span> current = element.offsetParent;</div><div class="line">    <span class="keyword">while</span> (current !== <span class="literal">null</span>)&#123;</div><div class="line">        actualLeft += current.offsetLeft;</div><div class="line">        current = current.offsetParent;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> actualLeft;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementTop</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> actualTop = element.offsetTop;</div><div class="line">    <span class="keyword">var</span> current = element.offsetParent;</div><div class="line">    <span class="keyword">while</span> (current !== <span class="literal">null</span>)&#123;</div><div class="line">        actualTop += current. offsetTop;</div><div class="line">        current = current.offsetParent;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> actualTop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于简单的CSS 布局的页面，这两函数可以得到非常精确的结果。<br>对于使用表格和内嵌框架布局的页面，由于不同浏览器实现这些元素的方式不同，因此得到的值就不太精确了。</p>
<p>一般来说，页面中的所有元素都会被包含在几个<code>&lt;div&gt;</code>元素中，而这些<code>&lt;div&gt;</code>元素的offsetParent 又是<code>&lt;body&gt;</code>元素，所以getElementLeft()与getElementTop()会返回与offsetLeft 和offsetTop相同的值。</p>
<p>所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能。</p>
<h3 id="客户区大小"><a href="#客户区大小" class="headerlink" title="客户区大小"></a>客户区大小</h3><p>(client dimension)，指的是元素内容及其内边距所占据的空间大小。<br>属性有两个：clientWidth 和clientHeight。<br>clientWidth 属性是元素内容区宽度加上左右内边距宽度；clientHeight 属性是元素内容区高度加上上下内边距高度。<br>从字面上看，客户区大小就是元素内部的空间大小，因此滚动条占用的空间不计算在内。</p>
<p>要确定浏览器视口大小，可以使用document.documentElement 或document.body(在IE7 之前的版本中)的clientWidth 和clientHeight。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewport</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"BackCompat"</span>)&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            width: <span class="built_in">document</span>.body.clientWidth,</div><div class="line">            height: <span class="built_in">document</span>.body.clientHeight</div><div class="line">        &#125;;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            width: <span class="built_in">document</span>.documentElement.clientWidth,</div><div class="line">            height: <span class="built_in">document</span>.documentElement.clientHeight</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先检查document.compatMode 属性，以确定浏览器是否运行在混杂模式。<br>与偏移量相似，客户区大小也是只读的，也是每次访问都要重新计算的。</p>
<h3 id="滚动大小"><a href="#滚动大小" class="headerlink" title="滚动大小"></a>滚动大小</h3><p>滚动大小(scroll dimension)，指的是包含滚动内容的元素的大小。。<br>有些元素(例如<code>&lt;html&gt;</code>元素)，即使没有执行任何代码也能自动地添加滚动条；但另外一些元素，则需要通过CSS 的overflow 属性进行设置才能滚动。</p>
<ul>
<li>scrollHeight：在没有滚动条的情况下，元素内容的总高度。</li>
<li>scrollWidth：在没有滚动条的情况下，元素内容的总宽度。</li>
<li>scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</li>
<li>scrollTop：被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</li>
</ul>
<p>scrollWidth 和scrollHeight 主要用于确定元素内容的实际大小。<br>例如，通常认为<code>&lt;html&gt;</code>元素是在Web 浏览器的视口中滚动的元素(IE6 之前版本运行在混杂模式下时是<code>&lt;body&gt;</code>元素)。<br>因此，带有垂直滚动条的页面总高度就是document.documentElement.scrollHeight。</p>
<p>对于不包含滚动条的页面而言， scrollWidth 和scrollHeight 与clientWidth 和clientHeight 之间的关系并不十分清晰。</p>
<ul>
<li>Firefox 中这两组属性始终都是相等的，但大小代表的是文档内容区域的实际尺寸，而非视口的尺寸。</li>
<li>Opera、Safari 3.1 及更高版本、Chrome 中的这两组属性是有差别的，其中scrollWidth 和scrollHeight 等于视口大小，而clientWidth 和clientHeight 等于文档内容区域的大小。</li>
<li>IE(在标准模式)中的这两组属性不相等，其中scrollWidth 和scrollHeight 等于文档内容区域的大小，而clientWidth 和clientHeight 等于视口大小。</li>
</ul>
<p>在确定文档的总高度时(包括基于视口的最小高度时)，必须取得scrollWidth/clientWidth 和scrollHeight/clientHeight 中的最大值，才能保证在跨浏览器的环境下得到精确的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> docHeight = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollHeight,</div><div class="line"><span class="built_in">document</span>.documentElement.clientHeight);</div><div class="line"><span class="keyword">var</span> docWidth = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.scrollWidth,</div><div class="line"><span class="built_in">document</span>.documentElement.clientWidth);</div></pre></td></tr></table></figure>
<p>对于运行在混杂模式下的IE，则需要用document.body 代替document.documentElement。</p>
<p>通过scrollLeft 和scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。<br>在元素尚未被滚动时，这两个属性的值都等于0。如果元素被垂直滚动了，那么scrollTop 的值会大于0，且表示元素上方不可见内容的像素高度。<br>如果元素被水平滚动了，那么scrollLeft 的值会大于0，且表示元素左侧不可见内容的像素宽度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollToTop</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (element.scrollTop != <span class="number">0</span>)&#123;</div><div class="line">        element.scrollTop = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数会检测元素是否位于顶部，如果不是就将其回滚到顶部。既取得了scrollTop 的值，也设置了它的值。</p>
<h3 id="确定元素大小"><a href="#确定元素大小" class="headerlink" title="确定元素大小"></a>确定元素大小</h3><p>IE、Firefox 3+、Safari 4+、Opera 9.5 及Chrome 为每个元素都提供了一个getBoundingClientRect()方法。<br>这个方法返回会一个矩形对象，包含4 个属性：left、top、right 和bottom。<br>这些属性给出了元素在页面中相对于视口的位置。</p>
<p>浏览器的实现稍有不同。IE8 及更早版本认为文档的左上角坐标是(2, 2)，而其他浏览器包括IE9 则将传统的(0,0)作为起点坐标。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBoundingClientRect</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.offset != <span class="string">"number"</span>)&#123;</div><div class="line">        <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</div><div class="line">        <span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">        temp.style.cssText = <span class="string">"position:absolute;left:0;top:0;"</span>;</div><div class="line">        <span class="built_in">document</span>.body.appendChild(temp);</div><div class="line">        <span class="built_in">arguments</span>.callee.offset = -temp.getBoundingClientRect().top - scrollTop;</div><div class="line">        <span class="built_in">document</span>.body.removeChild(temp);</div><div class="line">        temp = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> rect = element.getBoundingClientRect();</div><div class="line">    <span class="keyword">var</span> offset = <span class="built_in">arguments</span>.callee.offset;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        left: rect.left + offset,</div><div class="line">        right: rect.right + offset,</div><div class="line">        top: rect.top + offset,</div><div class="line">        bottom: rect.bottom + offset</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>arguments.callee.offset:检测属性是否有定义，如果没有就定义一个。<br>最终的offset 会被设置为新元素上坐标的负值，实际上就是在IE 中设置为-2，在Firefox 和Opera 中设置为-0。<br>创建一个临时的元素，将其位置设置在(0,0)，然后再调用其getBoundingClientRect()。<br>而之所以要减去视口的scrollTop，是为了防止调用这个函数时窗口被滚动了。<br>这样编写代码，就无需每次调用这个函数都执行两次getBoundingClientRect()了。<br>再在传入的元素上调用这个方法并基于新的计算公式创建一个对象。<br>对于不支持getBoundingClientRect()的浏览器，可以通过其他手段取得相同的信息。<br>一般来说，right 和left 的差值与offsetWidth 的值相等，而bottom 和top 的差值与offsetHeight相等。<br>而且，left 和top 属性大致等于使用本章前面定义的getElementLeft()和getElementTop()函数取得的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBoundingClientRect</span>(<span class="params">element</span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop;</div><div class="line">    <span class="keyword">var</span> scrollLeft = <span class="built_in">document</span>.documentElement.scrollLeft;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (element.getBoundingClientRect)&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.offset != <span class="string">"number"</span>)&#123;</div><div class="line">            <span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">            temp.style.cssText = <span class="string">"position:absolute;left:0;top:0;"</span>;</div><div class="line">            <span class="built_in">document</span>.body.appendChild(temp);</div><div class="line">            <span class="built_in">arguments</span>.callee.offset = -temp.getBoundingClientRect().top - scrollTop;</div><div class="line">            <span class="built_in">document</span>.body.removeChild(temp);</div><div class="line">            temp = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> rect = element.getBoundingClientRect();</div><div class="line">        <span class="keyword">var</span> offset = <span class="built_in">arguments</span>.callee.offset;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            left: rect.left + offset,</div><div class="line">            right: rect.right + offset,</div><div class="line">            top: rect.top + offset,</div><div class="line">            bottom: rect.bottom + offset</div><div class="line">        &#125;;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">var</span> actualLeft = getElementLeft(element);</div><div class="line">        <span class="keyword">var</span> actualTop = getElementTop(element);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            left: actualLeft - scrollLeft,</div><div class="line">            right: actualLeft + element.offsetWidth - scrollLeft,</div><div class="line">            top: actualTop - scrollTop,</div><div class="line">            bottom: actualTop + element.offsetHeight - scrollTop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数在getBoundingClientRect()有效时，就使用这个原生方法，而在这个方法无效时则使用默认的计算公式。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十二章-1]]></title>
      <url>http://codingme.xyz/2016/10/07/javascript-note-12-1/</url>
      <content type="html"><![CDATA[<h1 id="DOM2-和-DOM3"><a href="#DOM2-和-DOM3" class="headerlink" title="DOM2 和 DOM3"></a>DOM2 和 DOM3</h1><h1 id="DOM-变化"><a href="#DOM-变化" class="headerlink" title="DOM 变化"></a>DOM 变化</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> supportsDOM2Core = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"Core"</span>, <span class="string">"2.0"</span>);</div><div class="line"><span class="keyword">var</span> supportsDOM3Core = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"Core"</span>, <span class="string">"3.0"</span>);</div><div class="line"><span class="keyword">var</span> supportsDOM2HTML = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"HTML"</span>, <span class="string">"2.0"</span>);</div><div class="line"><span class="keyword">var</span> supportsDOM2Views = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"Views"</span>, <span class="string">"2.0"</span>);</div><div class="line"><span class="keyword">var</span> supportsDOM2XML = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"XML"</span>, <span class="string">"2.0"</span>);</div></pre></td></tr></table></figure>
<h2 id="针对XML命名空间的变化"><a href="#针对XML命名空间的变化" class="headerlink" title="针对XML命名空间的变化"></a>针对XML命名空间的变化</h2><p>XML 命名空间使不同XML 文档的元素可以混合在一起，共同构成格式良好的文档不必担心发生命名冲突。<br>HTML 不支持XML 命名空间，但XHTML 支持XML 命名空间。<br>命名空间要使用xmlns 特性来指定。<br>XHTML 的命名空间是<code>http://www.w3.org/1999/xhtml</code>，在任何格式良好XHTML 页面中，都应该将其包含在<code>&lt;html&gt;</code>元素中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example XHTML page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        Hello world!</div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>其中的所有元素默认都被视为XHTML 命名空间中的元素。<br>要想明确地为XML命名空间创建前缀，可以使用xmlns 后跟冒号，再后跟前缀。</p>
<figure class="highlight xhtml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xhtml:html</span> <span class="attr">xmlns:xhtml</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">xhtml:head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">xhtml:title</span>&gt;</span>Example XHTML page<span class="tag">&lt;/<span class="name">xhtml:title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xhtml:head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">xhtml:body</span>&gt;</span></div><div class="line">Hello world!</div><div class="line"><span class="tag">&lt;/<span class="name">xhtml:body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xhtml:html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里为XHTML 的命名空间定义了一个名为xhtml 的前缀，并要求所有XHTML 元素都以该前缀开头。<br>有时候为了避免不同语言间的冲突，也需要使用命名空间来限定特性。</p>
<figure class="highlight xhtml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xhtml:html</span> <span class="attr">xmlns:xhtml</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">xhtml:head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">xhtml:title</span>&gt;</span>Example XHTML page<span class="tag">&lt;/<span class="name">xhtml:title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xhtml:head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">xhtml:body</span> <span class="attr">xhtml:class</span>=<span class="string">"home"</span>&gt;</span></div><div class="line">Hello world!</div><div class="line"><span class="tag">&lt;/<span class="name">xhtml:body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xhtml:html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在只基于一种语言编写XML 文档的情况下，命名空间实际上也没有什么用。不过，在混合使用两种语言的情况下，命名空间的用处就非常大了。</p>
<figure class="highlight xhtml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Example XHTML page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">version</span>=<span class="string">"1.1"</span></span></div><div class="line"><span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">style</span>=<span class="string">"width:100%; height:100%"</span>&gt;</div><div class="line"><span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">style</span>=<span class="string">"fill:red"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>通过设置命名空间，将<code>&lt;svg&gt;</code>标识为了与包含文档无关的元素。此时，<code>&lt;svg&gt;</code>元素的所有子元素，以及这些元素的所有特性，都被认为属于<code>http://www.w3.org/2000/svg</code> 命名空间。即使这个文档从技术上说是一个XHTML文档，但因为有了命名空间，其中的SVG代码也仍然是有效的。</p>
<p>最有意思的事发生在调用方法操作文档节点的情况下。<br>例如，在创建一个元素时，这个元素属于哪个命名空间呢？<br>在查询一个特殊标签名时，应该将结果包含在哪个命名空间中呢？</p>
<p>“DOM2 级核心”通过为大多数DOM1 级方法提供特定于命名空间的版本解决了这个问题。</p>
<h3 id="Node-类型的变化"><a href="#Node-类型的变化" class="headerlink" title="Node 类型的变化"></a>Node 类型的变化</h3><p>在DOM2 级中，Node 类型包含特定于命名空间的属性。</p>
<ul>
<li>localName：不带命名空间前缀的节点名称。</li>
<li>namespaceURI：命名空间URI 或者(在未指定的情况下是)null。</li>
<li>prefix：命名空间前缀或者(在未指定的情况下是)null。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example XHTML page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">s:svg</span> <span class="attr">xmlns:s</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">version</span>=<span class="string">"1.1"</span></span></div><div class="line">        <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">style</span>=<span class="string">"width:100%; height:100%"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">s:rect</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">style</span>=<span class="string">"fill:red"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">s:svg</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当节点使用了命名空间前缀时，其nodeName 等于prefix+”:”+ localName。<br>对于<code>&lt;html&gt;</code>元素来说，它的localName 和tagName 是”html”，namespaceURI 是”<a href="http://www.w3.org/1999/xhtml/" target="_blank" rel="external">http://www.w3.org/1999/xhtml/</a>“，而prefix 是null。<br>对于<code>&lt;s:svg&gt;</code>元素而言，它的localName 是”svg”，tagName 是”s:svg”，namespaceURI 是”<a href="http://www.w3.org/2000/svg/" target="_blank" rel="external">http://www.w3.org/2000/svg/</a>“，而prefix 是”s”。</p>
<p>DOM3 级在此基础上更进一步，又引入了与命名空间有关的方法。</p>
<ul>
<li>isDefaultNamespace(namespaceURI)：在指定的namespaceURI 是当前节点的默认命名空间的情况下返回true。</li>
<li>lookupNamespaceURI(prefix)：返回给定prefix 的命名空间。</li>
<li>lookupPrefix(namespaceURI)：返回给定namespaceURI 的前缀。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">document</span>.body.isDefaultNamespace(<span class="string">"http://www.w3.org/1999/xhtml"</span>); <span class="comment">//true</span></div><div class="line"><span class="comment">//假设svg 中包含着对&lt;s:svg&gt;的引用</span></div><div class="line">alert(svg.lookupPrefix(<span class="string">"http://www.w3.org/2000/svg"</span>)); <span class="comment">//"s"</span></div><div class="line">alert(svg.lookupNamespaceURI(<span class="string">"s"</span>)); <span class="comment">//"http://www.w3.org/2000/svg"</span></div></pre></td></tr></table></figure>
<h3 id="Document-类型的变化"><a href="#Document-类型的变化" class="headerlink" title="Document 类型的变化"></a>Document 类型的变化</h3><p>DOM2 级中的Document 类型也发生了变化。</p>
<ul>
<li>createElementNS(namespaceURI, tagName)：使用给定的tagName 创建一个属于命名空间namespaceURI 的新元素。</li>
<li>createAttributeNS(namespaceURI, attributeName)：使用给定的attributeName 创建一个属于命名空间namespaceURI 的新特性。</li>
<li>getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName 元素的NodeList。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个新的SVG 元素</span></div><div class="line"><span class="keyword">var</span> svg = <span class="built_in">document</span>.createElementNS(<span class="string">"http://www.w3.org/2000/svg"</span>,<span class="string">"svg"</span>);</div><div class="line"><span class="comment">//创建一个属于某个命名空间的新特性</span></div><div class="line"><span class="keyword">var</span> att = <span class="built_in">document</span>.createAttributeNS(<span class="string">"http://www.somewhere.com"</span>, <span class="string">"random"</span>);</div><div class="line"><span class="comment">//取得所有XHTML 元素</span></div><div class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagNameNS(<span class="string">"http://www.w3.org/1999/xhtml"</span>, <span class="string">"*"</span>);</div></pre></td></tr></table></figure>
<p>只有在文档中存在两个或多个命名空间时，这些与命名空间有关的方法才是必需的。</p>
<h3 id="Element-类型的变化"><a href="#Element-类型的变化" class="headerlink" title="Element 类型的变化"></a>Element 类型的变化</h3><ul>
<li>getAttributeNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的特性。</li>
<li>getAttributeNodeNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的特性节点。</li>
<li>getElementsByTagNameNS(namespaceURI, tagName)：返回属于命名空间namespaceURI的tagName 元素的NodeList。</li>
<li>hasAttributeNS(namespaceURI,localName)：确定当前元素是否有一个名为localName的特性，而且该特性的命名空间是namespaceURI。注意，“DOM2 级核心”也增加了一个hasAttribute()方法，用于不考虑命名空间的情况。</li>
<li>removeAttriubteNS(namespaceURI,localName)：删除属于命名空间namespaceURI 且名为localName 的特性。</li>
<li>setAttributeNS(namespaceURI,qualifiedName,value)：设置属于命名空间namespaceURI 且名为qualifiedName 的特性的值为value。</li>
<li>setAttributeNodeNS(attNode)：设置属于命名空间namespaceURI 的特性节点。</li>
</ul>
<h3 id="NamedNodeMap-类型的变化"><a href="#NamedNodeMap-类型的变化" class="headerlink" title="NamedNodeMap 类型的变化"></a>NamedNodeMap 类型的变化</h3><p>由于特性是通过NamedNodeMap 表示的，因此这些方法多数情况下只针对特性使用。</p>
<ul>
<li>getNamedItemNS(namespaceURI,localName)：取得属于命名空间namespaceURI 且名为localName 的项。</li>
<li>removeNamedItemNS(namespaceURI,localName)：移除属于命名空间namespaceURI 且名为localName 的项。</li>
<li>setNamedItemNS(node)：添加node，这个节点已经事先指定了命名空间信息。</li>
</ul>
<p>由于一般都是通过元素访问特性，所以这些方法很少使用。</p>
<h2 id="其他方面的变化"><a href="#其他方面的变化" class="headerlink" title="其他方面的变化"></a>其他方面的变化</h2><h3 id="DocumentType-类型的变化"><a href="#DocumentType-类型的变化" class="headerlink" title="DocumentType 类型的变化"></a>DocumentType 类型的变化</h3><p>DocumentType 类型新增了3 个属性：publicId、systemId 和internalSubset。<br>前两个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1 级中是没有办法访问到的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"</span></div><div class="line">"http://www.w3.org/TR/html4/strict.dtd"&gt;</div></pre></td></tr></table></figure>
<p>对这个文档类型声明而言，publicId 是”-//W3C//DTD HTML 4.01//EN”，<br>而systemId 是”<code>http://www.w3.org/TR/html4/strict.dtd</code>“。<br>实际上，很少需要在网页中访问此类信息。</p>
<p>最后一个属性internalSubset，用于访问包含在文档类型声明中的额外定义。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"</span></div><div class="line">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</div><div class="line">[&lt;!ELEMENT name (#PCDATA)&gt;] &gt;</div></pre></td></tr></table></figure>
<h3 id="Document类型的变化"><a href="#Document类型的变化" class="headerlink" title="Document类型的变化"></a>Document类型的变化</h3><p>Document 类型的变化中唯一与命名空间无关的方法是importNode()。<br>这个方法的用途是从一个文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分。<br>每个节点都有一个ownerDocument 属性，表示所属的文档。<br>如果调用appendChild()时传入的节点属于不同的文档(ownerDocument 属性的值不一样)，则会导致错误。<br>但在调用importNode()时传入不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。<br>importNode()方法与Element 的cloneNode()方法非常相似。<br>它接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。<br>返回的结果是原来节点的副本，但能够在当前文档中使用。</p>
<p>“DOM2 级视图”模块添加了一个名为defaultView 的属性，其中保存着一个指针，指向拥有给定文档的窗口(或框架)。除IE 之外的所有浏览器都支持defaultView 属性。在IE 中有一个等价的属性名叫parentWindow(Opera 也支持这个属性)。</p>
<p><code>var parentWindow = document.defaultView || document.parentWindow;</code></p>
<p>“DOM2 级核心”还为document.implementation 对象规定了两个新方法：createDocumentType()和createDocument()。<br>前者用于创建一个新的DocumentType节点，接受3 个参数：文档类型名称、publicId、systemId。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.implementation.createDocumentType(<span class="string">"html"</span>,</div><div class="line"><span class="string">"-//W3C//DTD HTML 4.01//EN"</span>,</div><div class="line"><span class="string">"http://www.w3.org/TR/html4/strict.dtd"</span>);</div></pre></td></tr></table></figure>
<p>由于既有文档的文档类型不能改变，因此createDocumentType()只在创建新文档时有用；<br>创建新文档时需要用到createDocument()方法。这个方法接受3 个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> doc = <span class="built_in">document</span>.implementation.createDocument(<span class="string">""</span>, <span class="string">"root"</span>, <span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.implementation.createDocumentType(<span class="string">"html"</span>,</div><div class="line"><span class="string">" -//W3C//DTD XHTML 1.0 Strict//EN"</span>,</div><div class="line"><span class="string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>);</div><div class="line"><span class="keyword">var</span> doc = <span class="built_in">document</span>.implementation.createDocument(<span class="string">"http://www.w3.org/1999/xhtml"</span>,</div><div class="line"><span class="string">"html"</span>, doctype);</div></pre></td></tr></table></figure>
<p>这样，就创建了一个带有适当命名空间和文档类型的新XHTML 文档。不过，新文档当前只有文档元素<code>&lt;html&gt;</code>，剩下的所有元素都需要继续添加。</p>
<p>“DOM2 级HTML”模块也为document.implementation 新增了一个方法，名叫createHTMLDocument()。这个方法的用途是创建一个完整的HTML 文档，包括<code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>、<code>&lt;title&gt;</code>和<code>&lt;body&gt;</code>元素。这个方法只接受一个参数，即新创建文档的标题(放在<code>&lt;title&gt;</code>元素中的字符串)，返回新的HTML 文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> htmldoc = <span class="built_in">document</span>.implementation.createHTMLDocument(<span class="string">"New Doc"</span>);</div><div class="line">alert(htmldoc.title); <span class="comment">//"New Doc"</span></div><div class="line">alert(<span class="keyword">typeof</span> htmldoc.body); <span class="comment">//"object"</span></div></pre></td></tr></table></figure>
<h3 id="Node类型的变化"><a href="#Node类型的变化" class="headerlink" title="Node类型的变化"></a>Node类型的变化</h3><p>Node 类型中唯一与命名空间无关的变化，就是添加了isSupported()方法。<br>如果浏览器实现了相应特性，而且能够基于给定节点执行该特性，isSupported()就返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.body.isSupported(<span class="string">"HTML"</span>, <span class="string">"2.0"</span>))&#123;</div><div class="line"><span class="comment">//执行只有"DOM2 级HTML"才支持的操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也存在与hasFeature()方法相同的问题:不同实现在决定对什么特性返回true 或false 时并不一致。<br>所以还是使用能力检测。</p>
<p>DOM3 级引入了两个辅助比较节点的方法：isSameNode()和isEqualNode()。这两个方法都接受一个节点参数，并在传入节点与引用的节点相同或相等时返回true</p>
<p>相等:相同的类型，具有相等的属性(nodeName、nodeValue，等等)，而且它们的attributes 和childNodes 属性也相等(相同位置包含相同的值)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">div1.setAttribute(<span class="string">"class"</span>, <span class="string">"box"</span>);</div><div class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">div2.setAttribute(<span class="string">"class"</span>, <span class="string">"box"</span>);</div><div class="line">alert(div1.isSameNode(div1)); <span class="comment">//true</span></div><div class="line">alert(div1.isEqualNode(div2)); <span class="comment">//true</span></div><div class="line">alert(div1.isSameNode(div2)); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>setUserData()方法会将数据指定给节点，它接受3 个参数：要设置的键、实际的数据(可以是任何数据类型)和处理函数。<br><code>document.body.setUserData(&quot;name&quot;, &quot;Nicholas&quot;, function(){});</code><br>然后，使用getUserData()并传入相同的键，就可以取得该数据。<br><code>var value = document.body.getUserData(&quot;name&quot;);</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">div.setUserData(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">operation, key, value, src, dest</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (operation == <span class="number">1</span>)&#123;</div><div class="line">        dest.setUserData(key, value, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;); &#125;</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> newDiv = div.cloneNode(<span class="literal">true</span>);</div><div class="line">alert(newDiv.getUserData(<span class="string">"name"</span>)); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>先创建了一个<code>&lt;div&gt;</code>元素，然后又为它添加了一些数据(用户数据)。<br>在使用cloneNode()复制这个元素时，就会调用处理函数，从而将数据自动复制到了副本节点。<br>结果在通过副本节点调用getUserData()时，就会返回与原始节点中包含的相同的值。</p>
<h3 id="框架的变化"><a href="#框架的变化" class="headerlink" title="框架的变化"></a>框架的变化</h3><p>框架和内嵌框架分别用HTMLFrameElement 和HTMLIFrameElement 表示。<br>在DOM 2级中有一个新属性，名叫contentDocument。<br>包含一个指针，指向表示框架内容的文档对象。<br>在此之前，无法直接通过元素取得这个文档对象(只能使用frames 集合)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">"myIframe"</span>);</div><div class="line"><span class="keyword">var</span> iframeDoc = iframe.contentDocument; <span class="comment">//在IE8 以前的版本中无效</span></div></pre></td></tr></table></figure>
<p>由于contentDocument 属性是Document 类型的实例，因此可以像使用其他HTML 文档一样使用它，包括所有属性和方法。Opera、Firefox、Safari 和Chrome 支持这个属性。<br>IE8 之前不支持框架中的contentDocument 属性，但支持一个名叫contentWindow 的属性，该属性返回框架的window 对<br>象，而这个window 对象又有一个document 属性。<br>所有浏览器都支持contentWindow 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">"myIframe"</span>);</div><div class="line"><span class="keyword">var</span> iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</div></pre></td></tr></table></figure>
<p>访问框架或内嵌框架的文档对象要受到跨域安全策略的限制。如果某个框架中的页面来自其他域或不同子域，或者使用了不同的协议，那么要访问这个框架的文档对象就会导致错误。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十一章-2]]></title>
      <url>http://codingme.xyz/2016/10/05/javascript-note-11-2/</url>
      <content type="html"><![CDATA[<h1 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h1><h2 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h2><p>在需要给文档插入大量新HTML 标记的情况下，通过DOM操作仍然非常麻烦。<br>因为不仅要创建一系列DOM 节点，而且还要小心地按照正确的顺序把它们连接起来。<br>相对而言，使用插入标记的技术，直接插入HTML 字符串不仅更简单，速度也更快。</p>
<h3 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h3><p>在读模式下，innerHTML 属性返回与调用元素的所有子节点(包括元素、注释和文本节点)对应的HTML 标记。<br>在写模式下，innerHTML 会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>&lt;div&gt;</code>元素的innerHTML 属性会返回如下字符串。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>但是，不同浏览器返回的文本格式会有所不同。<br>IE 和Opera 会将所有标签转换为大写形式，<br>而Safari、Chrome 和Firefox 则会原原本本地按照原先文档中(或指定这些标签时)的格式返回HTML，包括空格和缩进。</p>
<p>不要指望所有浏览器返回的innerHTML 值完全相同。</p>
<p>在写模式下，innerHTML 的值会被解析为DOM 子树，替换调用元素原来的所有子节点。<br>因为它的值被认为是HTML，所以其中的所有标签都会按照浏览器处理HTML 的标准方式转换为元素(同样，这里的转换结果也因浏览器而异)。<br>如果设置的值仅是文本而没有HTML 标签，那么结果就是设置纯文本。<br><code>div.innerHTML = &quot;Hello &amp; welcome, &lt;b&gt;\&quot;reader\&quot;!&lt;/b&gt;&quot;;</code><br>结果是：<br><code>&lt;div id=&quot;content&quot;&gt;Hello &amp;amp; welcome, &lt;b&gt;&amp;quot;reader&amp;quot;!&lt;/b&gt;&lt;/div&gt;</code><br>设置了innerHTML 之后，可以像访问文档中的其他节点一样访问新创建的节点。<br>为innerHTML 设置HTML 字符串后，浏览器会将这个字符串解析为相应的DOM树。<br>因此设置了innerHTML 之后，再从中读取HTML 字符串，会得到与设置时不一样的结果。<br>原因在于返回的字符串是根据原始HTML 字符串创建的DOM树经过序列化之后的结果。</p>
<p>使用innerHTML 属性也有一些限制。比如，在大多数浏览器中，通过innerHTML 插入<code>&lt;script&gt;</code>元素并不会执行其中的脚本。</p>
<p>IE8 及更早版本是唯一能在这种情况下执行脚本的浏览器，但必须满足一些条件。<br>一是必须为<code>&lt;script&gt;</code>元素指定defer 属性，二是<code>&lt;script&gt;</code>元素必须位于(微软所谓的)“有作用域的元素”(scoped element)之后。<br><code>&lt;script&gt;</code>元素被认为是“无作用域的元素”(NoScope element)，也就是在页面中看不到的元素，与<code>&lt;style&gt;</code>元素或注释类似。</p>
<p>如果通过innerHTML 插入的字符串开头就是一个“无作用域的元素”，那么IE 会在解析这个字符串前先删除该元素。<br><code>div.innerHTML = &quot;&lt;script defer&gt;alert(&#39;hi&#39;);&lt;\/script&gt;&quot;; //无效</code><br>如果想插入这段脚本，必须在前面添加一个“有作用域的元素”，可以是一个文本节点，也可以是一个没有结束标签的元素如<code>&lt;input&gt;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div.innerHTML = <span class="string">"_&lt;script defer&gt;alert('hi');&lt;\/script&gt;"</span>;</div><div class="line">div.innerHTML = <span class="string">"&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;script defer&gt;alert('hi');&lt;\/script&gt;"</span>;</div><div class="line">div.innerHTML = <span class="string">"&lt;input type=\"hidden\"&gt;&lt;script defer&gt;alert('hi');&lt;\/script&gt;"</span>;</div></pre></td></tr></table></figure>
<p>第一行代码会在<code>&lt;script&gt;</code>元素前插入一个文本节点。事后，为了不影响页面显示，可能需要移除这个文本节点。<br>第二行代码采用的方法类似，只不过使用的是一个包含非换行空格的<code>&lt;div&gt;</code>元素。<br>如果仅仅插入一个空的<code>&lt;div&gt;</code>元素，还是不行；必须要包含一点儿内容，浏览器才会创建文本节点。同样，为了不影响页面布局，恐怕还得移除这个节点。<br>第三行代码使用的是一个隐藏的<code>&lt;input&gt;</code>域，也能达到相同的效果。<br>由于隐藏的<code>&lt;input&gt;</code>域不影响页面布局，因此这种方式在大多数情况下都是首选。</p>
<p>大多数浏览器都支持以直观的方式通过innerHTML 插入<code>&lt;style&gt;</code>元素。<br><code>div.innerHTML = &quot;&lt;style type=\&quot;text/css\&quot;&gt;body {background-color: red; }&lt;/style&gt;&quot;;</code><br>但在IE8 及更早版本中，<code>&lt;style&gt;</code>也是一个“没有作用域的元素”，因此必须给它前置一个“有作用域的元素”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">div.innerHTML = <span class="string">"_&lt;style type=\"text/css\"&gt;body &#123;background-color: red; &#125;&lt;/style&gt;"</span>;</div><div class="line">div.removeChild(div.firstChild);</div></pre></td></tr></table></figure>
<p>并不是所有元素都支持innerHTML 属性。不支持innerHTML 的元素有：<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;frameset&gt;</code>、<code>&lt;head&gt;</code>、<code>html&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tfoot&gt;</code>和<code>&lt;tr&gt;</code>。</p>
<p>在IE8 及更早版本中，<code>&lt;title&gt;</code>元素也没有innerHTML 属性。<br>Firefox 对在内容类型为application/xhtml+xml 的XHTML 文档中设置innerHTML有严格的限制。</p>
<p>无论什么时候，只要使用innerHTML 从外部插入HTML，都应该首先以可靠的方式处理HTML。<br>IE8 为此提供了window.toStaticHTML()方法，这个方法接收一个参数，即一个HTML 字符串；<br>返回一个经过无害处理后的版本——从源HTML 中删除所有脚本节点和事件处理程序属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"&lt;a href=\"#\" onclick=\"alert('hi')\"&gt;Click Me&lt;/a&gt;"</span>;</div><div class="line"><span class="keyword">var</span> sanitized = <span class="built_in">window</span>.toStaticHTML(text); <span class="comment">//Internet Explorer 8 only</span></div><div class="line">alert(sanitized); <span class="comment">//"&lt;a href=\"#\"&gt;Click Me&lt;/a&gt;"</span></div></pre></td></tr></table></figure>
<p>得到的无害版本中去掉了onclick 属性。<br>虽然目前只有IE8 原生支持这个方法，但还是建议在通过innerHTML 插入代码之前，尽可能先手工检查一下其中的文本内容。</p>
<h3 id="outerHTML-属性"><a href="#outerHTML-属性" class="headerlink" title="outerHTML 属性"></a>outerHTML 属性</h3><p>在读模式下，outerHTML 返回调用它的元素及所有子节点的HTML 标签。<br>在写模式下，outerHTML会根据指定的HTML 字符串创建新的DOM 子树，然后用这个DOM子树完全替换调用元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果在<code>&lt;div&gt;</code>元素上调用outerHTML，会返回与上面相同的代码，包括<code>&lt;div&gt;</code>本身。<br>不过，由于浏览器解析和解释HTML 标记的不同，结果也可能会有所不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div.outerHTML = <span class="string">"&lt;p&gt;This is a paragraph.&lt;/p&gt;"</span>;</div><div class="line"><span class="comment">//等同于</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</div><div class="line">p.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"This is a paragraph."</span>));</div><div class="line">div.parentNode.replaceChild(p, div);</div></pre></td></tr></table></figure>
<p>结果，就是新创建的<code>&lt;p&gt;</code>元素会取代DOM 树中的<code>&lt;div&gt;</code>元素。<br>支持outerHTML 属性的浏览器有IE4+、Safari 4+、Chrome 和Opera 8+。Firefox 7 及之前版本都不支持outerHTML 属性。</p>
<h3 id="insertAdjacentHTML-方法"><a href="#insertAdjacentHTML-方法" class="headerlink" title="insertAdjacentHTML()方法"></a>insertAdjacentHTML()方法</h3><p>插入标记的最后一个新增方式是insertAdjacentHTML()方法。<br>最早也是在IE 中出现的，它接收两个参数：插入位置和要插入的HTML 文本。<br>第一个参数必须是：</p>
<ul>
<li>“beforebegin”，在当前元素之前插入一个紧邻的同辈元素；</li>
<li>“afterbegin”，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；</li>
<li>“beforeend”，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；</li>
<li>“afterend”，在当前元素之后插入一个紧邻的同辈元素。</li>
</ul>
<p>这些值都必须是小写形式。第二个参数是一个HTML 字符串(与innerHTML 和outerHTML的值相同)，如果浏览器无法解析该字符串，就会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作为前一个同辈元素插入</span></div><div class="line">element.insertAdjacentHTML(<span class="string">"beforebegin"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</div><div class="line"><span class="comment">//作为第一个子元素插入</span></div><div class="line">element.insertAdjacentHTML(<span class="string">"afterbegin"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</div><div class="line"><span class="comment">//作为最后一个子元素插入</span></div><div class="line">element.insertAdjacentHTML(<span class="string">"beforeend"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</div><div class="line"><span class="comment">//作为后一个同辈元素插入</span></div><div class="line">element.insertAdjacentHTML(<span class="string">"afterend"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>);</div></pre></td></tr></table></figure>
<p>支持insertAdjacentHTML()方法的浏览器有IE、Firefox 8+、Safari、Opera 和Chrome。</p>
<h3 id="内存与性能问题"><a href="#内存与性能问题" class="headerlink" title="内存与性能问题"></a>内存与性能问题</h3><p>使用方法替换子节点可能会导致浏览器的内存占用问题，尤其是在IE 中，问题更加明显。<br>在删除带有事件处理程序或引用了其他JavaScript 对象子树时，就有可能导致内存占用问题。<br>假设某个元素有一个事件处理程序(或者引用了一个JavaScript 对象作为属性)，<br>在使用前述某个属性将该元素从文档树中删除后，元素与事件处理程序(或JavaScript 对象)之间的绑定关系在内存中并没有一并删除。<br>如果这种情况频繁出现，页面占用的内存数量就会明显增加。</p>
<p>因此，在使用innerHTML、outerHTML 属性和insertAdjacentHTML()方法时，最好先手工删除要被替换的元素的所有事件处理程序和JavaScript 对象属性。</p>
<p>使用这几个属性——特别是使用innerHTML，仍然还是可以为我们提供很多便利的。<br>在插入大量新HTML 标记时，使用innerHTML 属性与通过多次DOM 操作先创建节点再指定它们之间的关系相比，效率要高得多。<br>因为在设置innerHTML 或outerHTML 时，就会创建一个HTML解析器。这个解析器是在浏览器级别的代码(通常是C++编写的)基础上运行的，因此比执行JavaScript快得多。<br>不可避免地，创建和销毁HTML 解析器也会带来性能损失，所以最好能够将设置innerHTML或outerHTML 的次数控制在合理的范围内。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=values.length; i &lt; len; i++)&#123;</div><div class="line">    ul.innerHTML += <span class="string">"&lt;li&gt;"</span> + values[i] + <span class="string">"&lt;/li&gt;"</span>; <span class="comment">//要避免这种频繁操作！！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种每次循环都设置一次innerHTML 的做法效率很低。<br>每次循环还要从innerHTML 中读取一次信息，就意味着每次循环要访问两次innerHTML。<br>最好的做法是单独构建字符串，然后再一次性地将结果字符串赋值给innerHTML。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> itemsHtml = <span class="string">""</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=values.length; i &lt; len; i++)&#123;</div><div class="line">    itemsHtml += <span class="string">"&lt;li&gt;"</span> + values[i] + <span class="string">"&lt;/li&gt;"</span>;</div><div class="line">&#125;</div><div class="line">ul.innerHTML = itemsHtml;</div></pre></td></tr></table></figure>
<h2 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView()方法"></a>scrollIntoView()方法</h2><p>在各种专有方法中，HTML5 最终选择了scrollIntoView()作为标准方法。<br>scrollIntoView()可以在所有HTML 元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。<br>如果给这个方法传入true 作为参数，或者不传入任何参数，那么窗口滚动之后会让调用元素的顶部与视口顶部尽可能平齐。<br>如果传入false 作为参数，调用元素会尽可能全部出现在视口中，(可能的话，调用元素的底部会与视口顶部平齐。)不过顶部不一定平齐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//让元素可见</span></div><div class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].scrollIntoView();</div></pre></td></tr></table></figure>
<p>当页面发生变化时，一般会用这个方法来吸引用户的注意力。<br>实际上，为某个元素设置焦点也会导致浏览器滚动并显示出获得焦点的元素。</p>
<h1 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h1><h2 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h2><p>IE8 引入，决定了可以使用什么功能。<br>决定了你可以使用哪个级别的CSS，可以在JavaScript 中使用哪些API，以及如何对待文档类型(doctype)。<br>到了IE9，总共有4 种文档模式。</p>
<ul>
<li>IE5：以混杂模式渲染页面(IE5 的默认模式就是混杂模式)。IE8 及更高版本中的新功能都无法使用。</li>
<li>IE7：以IE7 标准模式渲染页面。IE8 及更高版本中的新功能都无法使用。</li>
<li>IE8：以IE8 标准模式渲染页面。IE8 中的新功能都可以使用，因此可以使用Selectors API、更多CSS2 级选择符和某些CSS3 功能，还有一些HTML5 的功能。不过IE9 中的新功能无法使用。</li>
<li>IE9：以IE9 标准模式渲染页面。IE9 中的新功能都可以使用，比如ECMAScript 5、完整的CSS3以及更多HTML5 功能。这个文档模式是最高级的模式。</li>
</ul>
<p>要理解IE8 及更高版本的工作原理，必须理解文档模式。<br>要强制浏览器以某种模式渲染页面，可以使用HTTP 头部信息X-UA-Compatible，或通过等价的<code>&lt;meta&gt;</code>标签来设置。<br><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=IEVersion&quot;&gt;</code><br>这里IE 的版本(IEVersion)有以下一些不同的值，而且这些值并不一定与上述4 种文档模式对应。</p>
<ul>
<li>Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。对于IE8，始终保持以IE8 标准模式渲染页面。对于IE9，则以IE9 标准模式渲染页面。</li>
<li>EmulateIE9：如果有文档类型声明，则以IE9 标准模式渲染页面，否则将文档模式设置为IE5。</li>
<li>EmulateIE8：如果有文档类型声明，则以IE8 标准模式渲染页面，否则将文档模式设置为IE5。</li>
<li>EmulateIE7：如果有文档类型声明，则以IE7 标准模式渲染页面，否则将文档模式设置为IE5。</li>
<li>9：强制以IE9 标准模式渲染页面，忽略文档类型声明。</li>
<li>8：强制以IE8 标准模式渲染页面，忽略文档类型声明。</li>
<li>7：强制以IE7 标准模式渲染页面，忽略文档类型声明。</li>
<li>5：强制将文档模式设置为IE5，忽略文档类型声明。</li>
</ul>
<p>通过document.documentMode 属性可以知道给定页面使用的是什么文档模式。<br>这个属性是IE8中新增的，它会返回使用的文档模式的版本号(在IE9 中，可能返回的版本号为5、7、8、9)<br>知道页面采用的是什么文档模式，有助于理解页面的行为方式。无论在什么文档模式下，都可以访问这个属性。</p>
<h2 id="children属性"><a href="#children属性" class="headerlink" title="children属性"></a>children属性</h2><p>IE9 之前的版本与其他浏览器在处理文本节点中的空白符时有差异，因此出现。<br>HTMLCollection 的实例，只包含元素中同样还是元素的子节点。<br>除此之外，children 属性与childNodes 没有什么区别，即在元素只包含元素子节点时，这两个属性的值相同。<br>IE8 及更早版本的children 属性中也会包含注释节点，但IE9 之后的版本则只返回元素节点。</p>
<h2 id="contains-方法"><a href="#contains-方法" class="headerlink" title="contains()方法"></a>contains()方法</h2><p>调用contains()方法的应该是祖先节点，也就是搜索开始的节点，<br>这个方法接收一个参数，即要检测的后代节点。如果被检测的节点是后代节点，该方法返回true；否则，返回false。<br><code>alert(document.documentElement.contains(document.body)); //true</code></p>
<p>例子测试了<code>&lt;body&gt;</code>元素是不是<code>&lt;html&gt;</code>元素的后代。<br>支持contains()方法的浏览器有IE、Firefox 9+、Safari、Opera 和Chrome。</p>
<p>DOM Level 3 的compareDocumentPosition()也能够确定节点间的关系。<br>支持这个方法的浏览器有IE9+、Firefox、Safari、Opera 9.5+和Chrome。</p>
<p>返回一个表示该关系的位掩码( bitmask)。</p>
<p>1 无关(给定的节点不在当前文档中)<br>2 居前(给定的节点在DOM树中位于参考节点之前)<br>4 居后(给定的节点在DOM树中位于参考节点之后)<br>8 包含(给定的节点是参考节点的祖先)<br>16 被包含(给定的节点是参考节点的后代)</p>
<p>为模仿contains()方法，应该关注的是掩码16。<br>可以对compareDocumentPosition()的结果执行按位与，以确定参考节点(调用compareDocumentPosition()方法的当前节点)是否包含给定的节点(传入的节点)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">refNode, otherNode</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> refNode.contains == <span class="string">"function"</span> &amp;&amp;</div><div class="line">    (!client.engine.webkit || client.engine.webkit &gt;= <span class="number">522</span>))&#123;</div><div class="line">        <span class="keyword">return</span> refNode.contains(otherNode);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> refNode.compareDocumentPosition == <span class="string">"function"</span>)&#123;</div><div class="line">        <span class="keyword">return</span> !!(refNode.compareDocumentPosition(otherNode) &amp; <span class="number">16</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">var</span> node = otherNode.parentNode;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="keyword">if</span> (node === refNode)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                node = node.parentNode;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">while</span> (node !== <span class="literal">null</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的第一个参数是参考节点，第二个参数是要检查的节点。</p>
<p>在函数体内，首先检测refNode 中是否存在contains()方法(能力检测)。还检查了当前浏览器所用的WebKit 版本号。如果方法存在而且不是WebKit，则继续执行代码。否则，如果浏览器是WebKit 且至少是Safari 3(WebKit版本号为522 或更高)，那么也可以继续执行代码。<br>在WebKit 版本号小于522 的Safari 浏览器中，contains()方法不能正常使用。</p>
<p>接下来检查是否存在compareDocumentPosition()方法，而函数的最后一步则是自otherNode开始向上遍历DOM 结构，以递归方式取得parentNode，并检查其是否与refNode 相等。<br>在文档树的顶端，parentNode 的值等于null，于是循环结束。这是针对旧版本Safari 设计的一个后备策略。</p>
<h2 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h2><p>IE 原来专有的插入标记的属性innerHTML 和outerHTML 已经被HTML5 纳入规范。<br>但另外两个插入文本的专有属性则没有这么好的运气。这两个没有被HTML5 看中的属性是innerText和outerText。</p>
<h3 id="innerText-属性"><a href="#innerText-属性" class="headerlink" title="innerText 属性"></a>innerText 属性</h3><p>通过innertText 属性可以操作元素中包含的所有文本内容，包括子文档树中的文本。<br>在通过innerText 读取值时，它会按照由浅入深的顺序，将子文档树中的所有文本拼接起来。<br>在通过innerText 写入值时，结果会删除元素的所有子节点，插入包含相应文本值的文本节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对<code>&lt;div&gt;</code>元素而言，会返回字符串：<br>This is a paragraph with a list following it.<br>Item 1<br>Item 2<br>Item 3</p>
<p>由于不同浏览器处理空白符的方式不同，因此输出的文本可能会也可能不会包含原始HTML 代码中的缩进。<br><code>div.innerText = &quot;Hello world!&quot;;</code><br>执行之后：<code>&lt;div id=&quot;content&quot;&gt;Hello world!&lt;/div&gt;</code></p>
<p>设置innerText属性的同时，也对文本中存在的HTML 语法字符(小于号、大于号、引号及和号)进行了编码。</p>
<p>设置innerText 永远只会生成当前节点的一个子文本节点，而为了确保只生成一个子文本节点，就必须要对文本进行HTML 编码。</p>
<p>利用这一点，可以通过innerText 属性过滤掉HTML 标签。<br><code>div.innerText = div.innerText;</code><br>执行这行代码后，就用原来的文本内容替换了容器元素中的所有内容(包括子节点，因而也就去掉了HTML 标签)。<br>支持innerText 属性的浏览器包括IE4+、Safari 3+、Opera 8+和Chrome。Firefox 虽然不支持innerText，但支持作用类似的textContent 属性。<br>textContent 是DOM Level 3 规定的一个属性，其他支持textContent 属性的浏览器还有IE9+、Safari 3+、Opera 10+和Chrome。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> element.textContent == <span class="string">"string"</span>) ?</div><div class="line">    element.textContent : element.innerText;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInnerText</span>(<span class="params">element, text</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.textContent == <span class="string">"string"</span>)&#123;</div><div class="line">        element.textContent = text;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        element.innerText = text;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，innerText 与textContent 返回的内容并不完全一样。<br>比如，innerText 会忽略行内的样式和脚本，而textContent 则会像返回其他文本一样返回行内的样式和脚本代码。<br>避免跨浏览器兼容问题的最佳途径，就是从不包含行内样式或行内脚本的DOM 子树副本或DOM片段中读取文本。</p>
<h3 id="outerText-属性"><a href="#outerText-属性" class="headerlink" title="outerText 属性"></a>outerText 属性</h3><p>作用范围扩大到了包含调用它的节点之外，outerText 与innerText 基本上没有多大区别。<br>读取文本值时，结果完全一样。<br>在写模式下，outerText 不只是替换调用它的元素的子节点，而是会替换整个元素(包括子节点)。<br>新的文本节点会完全取代调用outerText 的元素。此后，该元素就从文档中被删除，无法访问。<br>支持outerText 属性的浏览器有IE4+、Safari 3+、Opera 8+和Chrome。<br>由于这个属性会导致调用它的元素不存在，因此并不常用。也建议尽可能不要使用这个属性。</p>
<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><ul>
<li>scrollIntoViewIfNeeded(alignCenter)：只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。<br>  如果当前元素在视口中可见，这个方法什么也不做。如果将可选的alignCenter 参数设置为true，则表示尽量将元素显示在视口中部(垂直方向)。Safari 和Chrome 实现了这个方法。</li>
<li>scrollByLines(lineCount)：将元素的内容滚动指定的行高，lineCount 值可以是正值，也可以是负值。Safari 和Chrome 实现了这个方法。</li>
<li>scrollByPages(pageCount)：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。Safari 和Chrome 实现了这个方法。\</li>
</ul>
<p>scrollIntoView()和scrollIntoViewIfNeeded()的作用对象是元素的容器，而scrollByLines()和scrollByPages()影响的则是元素自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将页面主体滚动5 行</span></div><div class="line"><span class="built_in">document</span>.body.scrollByLines(<span class="number">5</span>);</div><div class="line"><span class="comment">//在当前元素不可见的时候，让它进入浏览器的视口</span></div><div class="line"><span class="built_in">document</span>.images[<span class="number">0</span>].scrollIntoViewIfNeeded();</div><div class="line"><span class="comment">//将页面主体往回滚动1 页</span></div><div class="line"><span class="built_in">document</span>.body.scrollByPages(<span class="number">-1</span>);</div></pre></td></tr></table></figure>
<p>由于scrollIntoView()是唯一一个所有浏览器都支持的方法，因此还是这个方法最常用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十一章-1]]></title>
      <url>http://codingme.xyz/2016/10/04/javascript-note-11-1/</url>
      <content type="html"><![CDATA[<h1 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h1><p>众多JavaScript 库中最常用的一项功能，就是根据CSS 选择符选择与某个模式匹配的DOM 元素。<br>实际上，jQuery(www.jquery.com)的核心就是通过CSS 选择符查询DOM文档取得元素的引用，从而抛开了getElementById()和getElementsByTagName()。</p>
<p>Selectors API Level 1 的核心是两个方法：querySelector()和querySelectorAll()。<br>在兼容的浏览器中，可以通过Document 及Element 类型的实例调用它们。<br>目前已完全支持Selectors API Level 1的浏览器有IE 8+、Firefox 3.5+、Safari 3.1+、Chrome 和Opera 10+。</p>
<h2 id="querySelector-方法"><a href="#querySelector-方法" class="headerlink" title="querySelector()方法"></a>querySelector()方法</h2><p>querySelector()方法接收一个CSS 选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得body 元素</span></div><div class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);</div><div class="line"><span class="comment">//取得ID 为"myDiv"的元素</span></div><div class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv"</span>);</div><div class="line"><span class="comment">//取得类为"selected"的第一个元素</span></div><div class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">".selected"</span>);</div><div class="line"><span class="comment">//取得类为"button"的第一个图像元素</span></div><div class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.body.querySelector(<span class="string">"img.button"</span>);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>通过Document 类型调用querySelector()方法时，会在文档元素的范围内查找匹配的元素。<br>而通过Element 类型调用querySelector()方法时，只会在该元素后代元素的范围内查找匹配的元素。<br>如果传入了不被支持的选择符，querySelector()会抛出错误。</p>
<h2 id="querySelectorAll-方法"><a href="#querySelectorAll-方法" class="headerlink" title="querySelectorAll()方法"></a>querySelectorAll()方法</h2><p>接收的参数与querySelector()方法一样，都是一个CSS 选择符，但返回的是所有匹配的元素而不仅仅是一个元素。返回的是一个NodeList 的实例。<br>具体来说，返回的值实际上是带有所有属性和方法的NodeList，而其底层实现则类似于一组元素的<strong>快照</strong>，而非不断对文档进行搜索的动态查询。<br>可以避免使用NodeList 对象通常会引起的大多数性能问题。<br>只要传给querySelectorAll()方法的CSS 选择符有效，该方法都会返回一个NodeList 对象，而不管找到多少匹配的元素。<br>如果没有找到匹配的元素，NodeList 就是空的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得某&lt;div&gt;中的所有&lt;em&gt;元素(类似于getElementsByTagName("em"))</span></div><div class="line"><span class="keyword">var</span> ems = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).querySelectorAll(<span class="string">"em"</span>);</div><div class="line"><span class="comment">//取得类为"selected"的所有元素</span></div><div class="line"><span class="keyword">var</span> selecteds = <span class="built_in">document</span>.querySelectorAll(<span class="string">".selected"</span>);</div><div class="line"><span class="comment">//取得所有&lt;p&gt;元素中的所有&lt;strong&gt;元素</span></div><div class="line"><span class="keyword">var</span> strongs = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p strong"</span>);</div></pre></td></tr></table></figure>
<p>与querySelector()类似，如果传入了浏览器不支持的选择符或者选择符中有语法错误，querySelectorAll()会抛出错误。</p>
<h2 id="matchesSelector-方法"><a href="#matchesSelector-方法" class="headerlink" title="matchesSelector()方法"></a>matchesSelector()方法</h2><p>Selectors API Level 2 规范为Element 类型新增了一个方法matchesSelector()。<br>这个方法接收一个参数，即CSS 选择符，如果调用元素与该选择符匹配，返回true；否则，返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.body.matchesSelector(<span class="string">"body.page1"</span>))&#123;</div><div class="line">    <span class="comment">//true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在取得某个元素引用的情况下，使用这个方法能够方便地检测它是否会被querySelector()或querySelectorAll()方法返回。<br>截至2011 年年中，还没有浏览器支持matchesSelector()方法；<br>不过，也有一些实验性的实现。IE 9+通过msMatchesSelector()支持该方法，Firefox 3.6+通过mozMatchesSelector()支持该方法，Safari 5+和Chrome 通过webkitMatchesSelector()支持该方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchesSelector</span>(<span class="params">element, selector</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (element.matchesSelector)&#123;</div><div class="line">        <span class="keyword">return</span> element.matchesSelector(selector);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.msMatchesSelector)&#123;</div><div class="line">        <span class="keyword">return</span> element.msMatchesSelector(selector);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.mozMatchesSelector)&#123;</div><div class="line">        <span class="keyword">return</span> element.mozMatchesSelector(selector);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.webkitMatchesSelector)&#123;</div><div class="line">        <span class="keyword">return</span> element.webkitMatchesSelector(selector);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Not supported."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (matchesSelector(<span class="built_in">document</span>.body, <span class="string">"body.page1"</span>))&#123;</div><div class="line">    <span class="comment">//执行操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h1><p>对于元素间的空格，IE9 及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。<br>这样，就导致了在使用childNodes 和firstChild 等属性时的行为不一致。<br>为了弥补这一差异，而同时又保持DOM规范不变，Element Traversal 规范(www.w3.org/TR/ElementTraversal/)新定义了一组属性。</p>
<ul>
<li>childElementCount：返回子元素(不包括文本节点和注释)的个数。</li>
<li>firstElementChild：指向第一个子元素；firstChild 的元素版。</li>
<li>lastElementChild：指向最后一个子元素；lastChild 的元素版。</li>
<li>previousElementSibling：指向前一个同辈元素；previousSibling 的元素版。</li>
<li>nextElementSibling：指向后一个同辈元素；nextSibling 的元素版。</li>
</ul>
<p>利用这些元素不必担心空白文本节点，从而可以更方便地查找DOM 元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//原版本</span></div><div class="line"><span class="keyword">var</span> i,</div><div class="line">len,</div><div class="line">child = element.firstChild;</div><div class="line"><span class="keyword">while</span>(child != element.lastChild)&#123;</div><div class="line">    <span class="keyword">if</span> (child.nodeType == <span class="number">1</span>)&#123; <span class="comment">//检查是不是元素</span></div><div class="line">        processChild(child);</div><div class="line">    &#125;</div><div class="line">    child = child.nextSibling;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//而使用Element Traversal 新增的元素，代码会更简洁。</span></div><div class="line"><span class="keyword">var</span> i,</div><div class="line">len,</div><div class="line">child = element.firstElementChild;</div><div class="line"><span class="keyword">while</span>(child != element.lastElementChild)&#123;</div><div class="line">processChild(child); <span class="comment">//已知其是元素</span></div><div class="line">child = child.nextElementSibling;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>支持Element Traversal 规范的浏览器有IE 9+、Firefox 3.5+、Safari 4+、Chrome 和Opera 10+。</p>
<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><p>对于传统HTML 而言，HTML5 是一个叛逆。<br>所有之前的版本对JavaScript 接口的描述都不过三言两语，主要篇幅都用于定义标记，与JavaScript 相关的内容一概交由DOM 规范去定义。</p>
<p>而HTML5 规范则围绕如何使用新增标记定义了大量JavaScript API。其中一些API 与DOM 重叠，定义了浏览器应该支持的DOM扩展。</p>
<h2 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h2><p>HTML5 新增了很多API，致力于简化CSS 类的用法。</p>
<h3 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName()方法"></a>getElementsByClassName()方法</h3><p>是最受人欢迎的一个方法，可以通过document对象及所有HTML 元素调用该方法。<br>这个方法最早出现在JavaScript 库中，是通过既有的DOM 功能实现的，而原生的实现具有极大的性能优势。<br>getElementsByClassName()方法接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。<br>传入多个类名时，类名的先后顺序不重要。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得所有类中包含"username"和"current"的元素，类名的先后顺序无所谓</span></div><div class="line"><span class="keyword">var</span> allCurrentUsernames = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"username current"</span>);</div><div class="line"><span class="comment">//取得ID 为"myDiv"的元素中带有类名"selected"的所有元素</span></div><div class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).getElementsByClassName(<span class="string">"selected"</span>);</div></pre></td></tr></table></figure>
<p>使用这个方法可以更方便地为带有某些类的元素添加事件处理程序，从而不必再局限于使用ID 或标签名。<br>因为返回的对象是NodeList，所以使用这个方法与使用getElementsByTagName()以及其他返回NodeList 的DOM 方法都具有同样的性能问题。<br>支持getElementsByClassName()方法的浏览器有IE 9+、Firefox 3+、Safari 3.1+、Chrome 和Opera 9.5+。</p>
<h3 id="classList-属性"><a href="#classList-属性" class="headerlink" title="classList 属性"></a>classList 属性</h3><p>操作类名时，需要通过className 属性添加、删除和替换类名。<br>因为className 中是一个字符串，所以即使只修改字符串一部分，也必须每次都设置整个字符串的值。<br><code>&lt;div class=&quot;bd user disabled&quot;&gt;...&lt;/div&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除"user"类</span></div><div class="line"><span class="comment">//首先，取得类名字符串并拆分成数组</span></div><div class="line"><span class="keyword">var</span> classNames = div.className.split(<span class="regexp">/\s+/</span>);</div><div class="line"><span class="comment">//找到要删的类名</span></div><div class="line"><span class="keyword">var</span> pos = <span class="number">-1</span>,</div><div class="line">i,</div><div class="line">len;</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>, len=classNames.length; i &lt; len; i++)&#123;</div><div class="line">    <span class="keyword">if</span> (classNames[i] == <span class="string">"user"</span>)&#123;</div><div class="line">        pos = i;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//删除类名</span></div><div class="line">classNames.splice(i,<span class="number">1</span>);</div><div class="line"><span class="comment">//把剩下的类名拼成字符串并重新设置</span></div><div class="line">div.className = classNames.join(<span class="string">" "</span>);</div></pre></td></tr></table></figure>
<p>HTML5 新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList 属性。<br>这个classList 属性是新集合类型DOMTokenList 的实例。<br>DOMTokenList 有一个表示自己包含多少元素的length 属性，而要取得每个元素可以使用item()方法，也可以使用方括号语法。</p>
<p>这个新类型还有不少方法。</p>
<ul>
<li>add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。</li>
<li>contains(value)：表示列表中是否存在给定的值，如果存在则返回true，否则返回false。</li>
<li>remove(value)：从列表中删除给定的字符串。</li>
<li>toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。</li>
</ul>
<p><code>div.classList.remove(&quot;user&quot;);</code><br>以上代码能够确保其他类名不受此次修改的影响。其他方法也能极大地减少类似基本操作的复杂性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除"disabled"类</span></div><div class="line">div.classList.remove(<span class="string">"disabled"</span>);</div><div class="line"><span class="comment">//添加"current"类</span></div><div class="line">div.classList.add(<span class="string">"current"</span>);</div><div class="line"><span class="comment">//切换"user"类</span></div><div class="line">div.classList.toggle(<span class="string">"user"</span>);</div><div class="line"><span class="comment">//确定元素中是否包含既定的类名</span></div><div class="line"><span class="keyword">if</span> (div.classList.contains(<span class="string">"bd"</span>) &amp;&amp; !div.classList.contains(<span class="string">"disabled"</span>))&#123;</div><div class="line"><span class="comment">//执行操作</span></div><div class="line">)</div><div class="line"><span class="comment">//迭代类名</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=div.classList.length; i &lt; len; i++)&#123;</div><div class="line">    doSomething(div.classList[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了classList 属性，除非你需要全部删除所有类名，或者完全重写元素的class 属性，否则也就用不到className 属性了。<br>支持classList 属性的浏览器有Firefox 3.6+和Chrome。</p>
<h2 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h2><p>HTML5 也添加了辅助管理DOM 焦点的功能。<br>document.activeElement 属性，这个属性始终会引用DOM 中当前获得了焦点的元素。</p>
<p>元素获得焦点的方式有页面加载、用户输入(通常是通过按Tab 键)和在代码中调用focus()方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>);</div><div class="line">button.focus();</div><div class="line">alert(<span class="built_in">document</span>.activeElement === button); <span class="comment">//true</span></div><div class="line">button.focus();</div><div class="line">alert(<span class="built_in">document</span>.hasFocus()); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>默认情况下，文档刚刚加载完成时，document.activeElement 中保存的是document.body 元素的引用。<br>文档加载期间，document.activeElement 的值为null。</p>
<p>新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。<br>通过检测文档是否获得了焦点，可以知道用户是不是正在与页面交互。</p>
<p>查询文档获知哪个元素获得了焦点，以及确定文档是否获得了焦点，这两个功能最重要的用途是提高Web 应用的无障碍性。<br>无障碍Web 应用的一个主要标志就是恰当的焦点管理，而确切地知道哪个元素获得了焦点是一个极大的进步，至少我们不用再像过去那样靠猜测了。</p>
<h2 id="HTMLDocument的变化"><a href="#HTMLDocument的变化" class="headerlink" title="HTMLDocument的变化"></a>HTMLDocument的变化</h2><p>HTML5 扩展了HTMLDocument，增加了新的功能。</p>
<h3 id="readyState-属性"><a href="#readyState-属性" class="headerlink" title="readyState 属性"></a>readyState 属性</h3><p>Document 的readyState 属性有两个可能的值：</p>
<ul>
<li>loading，正在加载文档；</li>
<li>complete，已经加载完文档。</li>
</ul>
<p>使用document.readyState 的最恰当方式，就是通过它来实现一个指示文档已经加载完成的指示器。<br>在这个属性得到广泛支持之前，要实现这样一个指示器，必须借助onload 事件处理程序设置一个标签，表明文档已经加载完毕。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">"complete"</span>)&#123;</div><div class="line">    <span class="comment">//执行操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>支持readyState 属性的浏览器有IE4+、Firefox 3.6+、Safari、Chrome 和Opera 9+。</p>
<h3 id="兼容模式"><a href="#兼容模式" class="headerlink" title="兼容模式"></a>兼容模式</h3><p>自从IE6 开始区分渲染页面的模式是标准的还是混杂的，检测页面的兼容模式就成为浏览器的必要功能。<br>IE 为此给document 添加了一个名为compatMode 的属性，这个属性就是为了告诉开发人员浏览器采用了哪种渲染模式。</p>
<p>在标准模式下，document.compatMode 的值等于”CSS1Compat”，而在混杂模式下，document.compatMode 的值等于”BackCompat”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123;</div><div class="line">    alert(<span class="string">"Standards mode"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    alert(<span class="string">"Quirks mode"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后来，陆续实现这个属性的浏览器有Firefox、Safari 3.1+、Opera 和Chrome。最终，HTML5 也把这个属性纳入标准，对其实现做出了明确规定。</p>
<h3 id="head-属性"><a href="#head-属性" class="headerlink" title="head 属性"></a>head 属性</h3><p>HTML5 新增了document.head 属性，引用文档的<code>&lt;head&gt;</code>元素。<br>结合使用这个属性和另一种后备方法。<br><code>var head = document.head || document.getElementsByTagName(&quot;head&quot;)[0];</code><br>如果可用，就使用document.head，否则仍然使用getElementsByTagName()方法。</p>
<h2 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h2><p>charset 属性表示文档中实际使用的字符集，也可以用来指定新字符集。<br>默认情况下，这个属性的值为”UTF-16”，但可以通过<code>&lt;meta&gt;</code>元素、响应头部或直接设置charset 属性修改这个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">document</span>.charset); <span class="comment">//"UTF-16"</span></div><div class="line"><span class="built_in">document</span>.charset = <span class="string">"UTF-8"</span>;</div></pre></td></tr></table></figure>
<p>defaultCharset，表示根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么。<br>如果文档没有使用默认的字符集，那charset 和defaultCharset 属性的值可能会不一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.charset != <span class="built_in">document</span>.defaultCharset)&#123;</div><div class="line">    alert(<span class="string">"Custom character set being used."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这两个属性可以得到文档使用的字符编码的具体信息，也能对字符编码进行准确地控制。<br>运行适当的情况下，可以保证用户正常查看页面或使用应用。</p>
<p>支持document.charset 属性的浏览器有IE 、Firefox 、Safari 、Opera 和Chrome 。<br>支持document.defaultCharset 属性的浏览器有IE、Safari 和Chrome。</p>
<h3 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h3><p>HTML5 规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。<br>可以任意添加、随便命名，只要以data-开头即可。</p>
<p>添加了自定义属性之后，可以通过元素的dataset 属性来访问自定义属性的值。<br>dataset 属性的值是DOMStringMap 的一个实例，也就是一个名值对的映射。<br>在这个映射中，每个data-name 形式的属性都会有一个对应的属性，只不过属性名没有data-前缀(比如，自定义属性是data-myname，那映射中对应的属性就是myname)。<br><code>&lt;div id=&quot;myDiv&quot; data-appId=&quot;12345&quot; data-myname=&quot;Nicholas&quot;&gt;&lt;/div&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//本例中使用的方法仅用于演示</span></div><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="comment">//取得自定义属性的值</span></div><div class="line"><span class="keyword">var</span> appId = div.dataset.appId;</div><div class="line"><span class="keyword">var</span> myName = div.dataset.myname;</div><div class="line"><span class="comment">//设置值</span></div><div class="line">div.dataset.appId = <span class="number">23456</span>;</div><div class="line">div.dataset.myname = <span class="string">"Michael"</span>;</div><div class="line"><span class="comment">//有没有"myname"值呢？</span></div><div class="line"><span class="keyword">if</span> (div.dataset.myname)&#123;</div><div class="line">    alert(<span class="string">"Hello, "</span> + div.dataset.myname);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果需要给元素添加一些不可见的数据以便进行其他处理，那就要用到自定义数据属性。<br>在跟踪链接或混搭应用中，通过自定义数据属性能方便地知道点击来自页面中的哪个部分。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十章-5]]></title>
      <url>http://codingme.xyz/2016/10/04/javascript-note-10-5/</url>
      <content type="html"><![CDATA[<h1 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h1><p>由于浏览器中充斥着隐藏的陷阱和不兼容问题，用JavaScript 代码处理DOM 的某些部分要比处理其他部分更复杂一些。</p>
<h2 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h2><p>动态脚本，指的是在页面加载时不存在，但将来的某一时刻通过修改DOM 动态添加的脚本。<br>创建动态脚本有两种方式：插入外部文件和直接插入JavaScript 代码。</p>
<p>动态加载的外部JavaScript 文件能够立即运行。<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;client.js&quot;&gt;&lt;/script&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.src = <span class="string">"client.js"</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(script);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>在执行最后一行代码把<code>&lt;script&gt;</code>元素添加到页面中之前，是不会下载外部文件的。也可以把这个元素添加到<code>&lt;head&gt;</code>元素中，效果相同。<br>可以使用函数来封装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    script.type = <span class="string">"text/javascript"</span>;</div><div class="line">    script.src = url;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">&#125;</div><div class="line"></div><div class="line">loadScript(<span class="string">"client.js"</span>);</div></pre></td></tr></table></figure>
<p>加载完成后，就可以在页面中的其他地方使用这个脚本了。<br>问题只有一个：怎么知道脚本加载完成呢？</p>
<p>另一种指定JavaScript 代码的方式是行内方式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"hi"</span>);</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>));</div><div class="line"><span class="built_in">document</span>.body.appendChild(script);</div></pre></td></tr></table></figure>
<p>在Firefox、Safari、Chrome 和Opera 中，这些DOM 代码可以正常运行。但在IE 中，则会导致错误。<br>IE 将<code>&lt;script&gt;</code>视为一个特殊的元素，不允许DOM 访问其子节点。<br>不过，可以使用<code>&lt;script&gt;</code>元素的text 属性来指定JavaScript 代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.text = <span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(script);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    script.type = <span class="string">"text/javascript"</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        script.appendChild(<span class="built_in">document</span>.createTextNode(code));</div><div class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">        script.text = code;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">&#125;</div><div class="line"></div><div class="line">loadScriptString(<span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>);</div></pre></td></tr></table></figure>
<p>以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。<br>实际上，这样执行代码与在全局作用域中把相同的字符串传递给eval()是一样的。</p>
<h2 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h2><p>能够把CSS 样式包含到HTML 页面中的元素有两个。其中，<code>&lt;link&gt;</code>元素用于包含来自外部的文件，而<code>&lt;style&gt;</code>元素用于指定嵌入的样式。<br>动态样式是指在页面刚加载时不存在的样式；动态样式是在页面加载完成后动态添加到页面中的。<br><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;</code></p>
<p>用DOM代码则是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</div><div class="line">link.rel = <span class="string">"stylesheet"</span>;</div><div class="line">link.type = <span class="string">"text/css"</span>;</div><div class="line">link.href = <span class="string">"style.css"</span>;</div><div class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">head.appendChild(link);</div></pre></td></tr></table></figure>
<p>需要注意的是，必须将<code>&lt;link&gt;</code>元素添加到<code>&lt;head&gt;</code>而不是<code>&lt;body&gt;</code>元素，才能保证在所有浏览器中的行为一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyles</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</div><div class="line">    link.rel = <span class="string">"stylesheet"</span>;</div><div class="line">    link.type = <span class="string">"text/css"</span>;</div><div class="line">    link.href = url;</div><div class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">    head.appendChild(link);</div><div class="line">&#125;</div><div class="line"></div><div class="line">loadStyles(<span class="string">"styles.css"</span>);</div></pre></td></tr></table></figure>
<p>加载外部样式文件的过程是异步的，也就是加载样式与执行JavaScript 代码的过程没有固定的次序。</p>
<p>另一种定义样式的方式是使用<code>&lt;style&gt;</code>元素来包含嵌入式CSS。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line"><span class="attribute">background-color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</div><div class="line">style.type = <span class="string">"text/css"</span>;</div><div class="line">style.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"body&#123;background-color:red&#125;"</span>));</div><div class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">head.appendChild(style);</div></pre></td></tr></table></figure>
<p>以上代码可以在Firefox、Safari、Chrome 和Opera 中运行，在IE 中则会报错。<br>IE 将<code>&lt;style&gt;</code>视为一个特殊的、与<code>&lt;script&gt;</code>类似的节点，不允许访问其子节点。<br>解决IE 中这个问题的办法，就是访问元素的styleSheet 属性，该属性又有一个cssText 属性，可以接受CSS 代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span>(<span class="params">css</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</div><div class="line">    style.type = <span class="string">"text/css"</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        style.appendChild(<span class="built_in">document</span>.createTextNode(css));</div><div class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">        style.styleSheet.cssText = css;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">    head.appendChild(style);</div><div class="line">&#125;</div><div class="line"></div><div class="line">loadStyleString(<span class="string">"body&#123;background-color:red&#125;"</span>);</div></pre></td></tr></table></figure>
<p>专门针对IE 编写代码，务必小心使用styleSheet.cssText 属性。<br>在重用同一个<code>&lt;style&gt;</code>元素并再次设置这个属性时，有可能会导致浏览器崩溃。<br>将cssText 属性设置为空字符串也可能导致浏览器崩溃。</p>
<h2 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h2><p><code>&lt;table&gt;</code>元素是HTML 中最复杂的结构之一。<br>要想创建表格，一般都必须涉及表示表格行、单元格、表头等方面的标签。<br>由于涉及的标签多，因而使用核心DOM 方法创建和修改表格往往都免不了要编写大量的代码。</p>
<p>例如要创建这个HTML表格。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"100%"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 1,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Cell 2,2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用核心DOM代码的话需要很多代码。<br>为了方便构建表格，HTML DOM 还为<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>和<code>&lt;tr&gt;</code>元素添加了一些属性和方法。<br>使用这些属性和方法，可以极大地减少创建表格所需的代码数量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建table</span></div><div class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">"table"</span>);</div><div class="line">table.border = <span class="number">1</span>;</div><div class="line">table.width = <span class="string">"100%"</span>;</div><div class="line"><span class="comment">//创建tbody</span></div><div class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">"tbody"</span>);</div><div class="line">table.appendChild(tbody);</div><div class="line"><span class="comment">//创建第一行</span></div><div class="line">tbody.insertRow(<span class="number">0</span>);</div><div class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>);</div><div class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 1,1"</span>));</div><div class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>);</div><div class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 2,1"</span>));</div><div class="line"></div><div class="line"><span class="comment">//创建第二行</span></div><div class="line">tbody.insertRow(<span class="number">1</span>);</div><div class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">0</span>);</div><div class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 1,2"</span>));</div><div class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">1</span>);</div><div class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Cell 2,2"</span>));</div><div class="line"><span class="comment">//将表格添加到文档主体中</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(table);</div></pre></td></tr></table></figure>
<h2 id="使用NodeList"><a href="#使用NodeList" class="headerlink" title="使用NodeList"></a>使用NodeList</h2><p>理解NodeList 及其“近亲”NamedNodeMap 和HTMLCollection，是从整体上透彻理解DOM的关键所在。<br>这三个集合都是“动态的”；换句话说，每当文档结构发生变化时，它们都会得到更新。<br>从本质上说，所有NodeList 对象都是在访问DOM文档时实时运行的查询。</p>
<p>一般来说，应该尽量减少访问NodeList 的次数。因为每次访问NodeList，都会运行一次基于文档的查询。<br>所以，可以考虑将从NodeList 中取得的值缓存起来。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十章-4]]></title>
      <url>http://codingme.xyz/2016/10/03/javascript-note-10-4/</url>
      <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><p>可以照字面解释的纯文本内容。<br>纯文本中可以包含转义后的HTML 字符，但不能包含HTML 代码。</p>
<ul>
<li>nodeType 的值为3；</li>
<li>nodeName 的值为”#text”；</li>
<li>nodeValue 的值为节点所包含的文本；</li>
<li>parentNode 是一个Element；</li>
<li>不支持(没有)子节点。</li>
</ul>
<p>可以通过nodeValue 属性或data 属性访问Text 节点中包含的文本，这两个属性中包含的值相同。<br>操作文本方法：</p>
<ul>
<li>appendData(text)：将text 添加到节点的末尾。</li>
<li>deleteData(offset, count)：从offset 指定的位置开始删除count 个字符。</li>
<li>insertData(offset, text)：在offset 指定的位置插入text。</li>
<li>replaceData(offset, count, text)：用text 替换从offset 指定的位置开始到offset+count 为止处的文本。</li>
<li>splitText(offset)：从offset 指定的位置将当前文本节点分成两个文本节点。</li>
<li>substringData(offset, count)：提取从offset 指定的位置开始到offset+count 为止处的字符串。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 没有内容，也就没有文本节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 有空格，因而有一个文本节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 有内容，因而有一个文本节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--想必有换行的也是吧(换行符)--&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>nodeValue 的值为”Hello World!”。可以使用以下代码来访问这些文本子节点。<br><code>var textNode = div.firstChild; //或者div.childNodes[0]</code><br>如果这个文本节点当前存在于文档树中，那么修改文本节点的结果就会立即得到反映。<br>此时的字符串会经过HTML(或XML，取决于文档类型)编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输出结果是"Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message"</span></div><div class="line">div.firstChild.nodeValue = <span class="string">"Some &lt;strong&gt;other&lt;/strong&gt; message"</span>;</div></pre></td></tr></table></figure>
<p>这是在向DOM 文档中插入文本之前，先对其进行HTML 编码的一种有效方式。</p>
<h3 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h3><p>document.createTextNode()。作为参数的文本也将按照HTML 或XML 的格式进行编码。<br><code>var textNode = document.createTextNode(&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;);</code><br>在创建新文本节点的同时，也会为其设置ownerDocument 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">element.className = <span class="string">"message"</span>;</div><div class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</div><div class="line">element.appendChild(textNode);</div><div class="line"><span class="built_in">document</span>.body.appendChild(element);</div></pre></td></tr></table></figure>
<p>可以往同一个元素添加多个文本节点。如果两个文本节点是相邻的同胞节点，那么两个节点中的文本就会连起来显示，中间不会有空格。</p>
<h3 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h3><p>DOM 文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。<br>DOM 文档中出现相邻文本节点的情况也不在少数。<br>所以才有了normalize()，将相邻文本节点合并。<br>结果节点的nodeValue 等于将合并前每个文本节点的nodeValue 值拼接起来的值。<br>浏览器在解析文档时永远不会创建相邻的文本节点。<br>只会作为执行DOM操作的结果出现。<br>在某些情况下，执行normalize()方法会导致IE6 崩溃。不过，在IE6 后来的补丁中，可能已经修复了这个问题(未经证实)。<br>(IE又是你！)</p>
<h3 id="分割文本节点"><a href="#分割文本节点" class="headerlink" title="分割文本节点"></a>分割文本节点</h3><p>splitText(),作用与normalize()相反。。<br>这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割nodeValue 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newNode = element.firstChild.splitText(<span class="number">5</span>);</div><div class="line">alert(element.firstChild.nodeValue); <span class="comment">//"Hello"</span></div><div class="line">alert(newNode.nodeValue); <span class="comment">//" world!"</span></div><div class="line">alert(element.childNodes.length); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>位置5是”Hello”和”world!”之间的空格，因此原来的文本节点将包含字符串”Hello”，而新文本节点将包含文本”world!”(包含空格)。<br><strong>分割文本节点是从文本节点中提取数据的一种常用DOM 解析技术</strong>。</p>
<h2 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h2><p>注释在DOM中是通过Comment 类型来表示的。</p>
<ul>
<li>nodeType 的值为8；</li>
<li>nodeName 的值为”#comment”；</li>
<li>nodeValue 的值是注释的内容；</li>
<li>parentNode 可能是Document 或Element；</li>
<li>不支持(没有)子节点。</li>
</ul>
<p>Comment 类型与Text 类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法。<br>与Text 类型相似，也可以通过nodeValue 或data 属性来取得注释的内容。<br>使用document.createComment()并为其传递注释文本也可以创建注释节点。<br>1.开发人员很少会创建和访问注释节点，因为注释节点对算法鲜有影响。<br>2.浏览器也不会识别位于<code>&lt;/html&gt;</code>标签后面的注释。如果要访问注释节点，一定要保证它们是<code>&lt;html&gt;</code>元素的后代</p>
<h2 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h2><p>CDATASection 类型只针对基于XML 的文档，表示的是CDATA 区域。<br>CDATASection 类型继承自Text 类型，因此拥有除splitText()之外的所有字符串操作方法。</p>
<ul>
<li>nodeType 的值为4；</li>
<li>nodeName 的值为”#cdata-section”；</li>
<li>nodeValue 的值是CDATA 区域中的内容；</li>
<li>parentNode 可能是Document 或Element；</li>
<li>不支持(没有)子节点。</li>
</ul>
<p>CDATA 区域只会出现在XML 文档中，因此多数浏览器都会把CDATA 区域错误地解析为Comment或Element。<br><code>&lt;div id=&quot;myDiv&quot;&gt;&lt;![CDATA[This is some content.]]&gt;&lt;/div&gt;</code><br>这个例子中的<code>&lt;div&gt;</code>元素应该包含一个CDATASection 节点。<br>可是，四大主流浏览器无一能够这样解析它。即使对于有效的XHTML 页面，浏览器也没有正确地支持嵌入的CDATA 区域。</p>
<p>在真正的XML 文档中，可以使用document.createCDataSection()来创建CDATA 区域，只需为其传入节点的内容即可。</p>
<h2 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h2><p>DocumentType 类型在Web 浏览器中并不常用，仅有Firefox、Safari 和Opera 支持它。</p>
<ul>
<li>nodeType 的值为10；</li>
<li>nodeName 的值为doctype 的名称；</li>
<li>nodeValue 的值为null；</li>
<li>parentNode 是Document；</li>
<li>不支持(没有)子节点。</li>
</ul>
<p>DocumentType 对象不能动态创建，而只能通过解析文档代码的方式来创建。<br>支持它的浏览器会把DocumentType 对象保存在document.doctype 中。<br>DocumentType 对象的3 个属性：name、entities 和notations。<br>name 表示文档类型的名称；<br>entities 是由文档类型描述的实体的NamedNodeMap 对象；<br>notations 是由文档类型描述的符号的NamedNodeMap 对象。</p>
<p>通常，浏览器中的文档使用的都是HTML 或XHTML 文档类型，因而entities和notations 都是空列表(列表中的项来自行内文档类型声明)。<br>但不管怎样，只有name 属性是有用的。</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"</span></div><div class="line">"http://www.w3.org/TR/html4/strict.dtd"&gt;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">document</span>.doctype.name); <span class="comment">//"HTML"</span></div></pre></td></tr></table></figure>
<p>IE 及更早版本不支持DocumentType，因此document.doctype 的值始终都等于null。<br>可是，这些浏览器会把文档类型声明错误地解释为注释， 并且为它创建一个注释节点。<br>IE9 会给document.doctype 赋正确的对象，但仍然不支持访问DocumentType 类型。</p>
<h2 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h2><p>只有DocumentFragment 在文档中没有对应的标记。<br>DOM 规定文档片段(document fragment)是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。</p>
<ul>
<li>nodeType 的值为11；</li>
<li>nodeName 的值为”#document-fragment”；</li>
<li>nodeValue 的值为null；</li>
<li>parentNode 的值为null；</li>
<li>子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection 或EntityReference。</li>
</ul>
<p>虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将来可能会添加到文档中的节点。<br><code>var fragment = document.createDocumentFragment();</code><br>文档片段继承了Node 的所有方法，通常用于执行那些针对文档的DOM操作。<br>如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点，也不会从浏览器中再看到该节点。<br>添加到文档片段中的新节点同样也不属于文档树。<br>可以通过appendChild()或insertBefore()将文档片段中内容添加到文档中。<br><code>&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</div><div class="line"><span class="keyword">var</span> li = <span class="literal">null</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</div><div class="line">    li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">    li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item "</span> + (i+<span class="number">1</span>)));</div><div class="line">    fragment.appendChild(li);</div><div class="line">&#125;</div><div class="line">ul.appendChild(fragment);</div></pre></td></tr></table></figure>
<p>如果逐个地添加列表项，将会导致浏览器反复渲染(呈现)新信息。<br>为避免这个问题，可以使用一个文档片段来保存创建的列表项，然后再一次性将它们添加到文档中。<br>最后，文档片段的所有子节点都被删除并转移到了<code>&lt;ul&gt;</code>元素中。</p>
<h2 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h2><p>元素的特性在DOM 中以Attr 类型来表示。</p>
<ul>
<li>nodeType 的值为2；</li>
<li>nodeName 的值是特性的名称；</li>
<li>nodeValue 的值是特性的值；</li>
<li>parentNode 的值为null；</li>
<li>在HTML 中不支持(没有)子节点；</li>
<li>在XML 中子节点可以是Text 或EntityReference。</li>
</ul>
<p>尽管它们也是节点，但特性却不被认为是DOM 文档树的一部分。<br>开发人员最常使用的是getAttribute()、setAttribute()和remveAttribute()方法，很少直接引用特性节点。<br>Attr 对象有3 个属性：name、value 和specified。<br>name 是特性名称(与nodeName 的值相同)，<br>value 是特性的值(与nodeValue 的值相同)，<br>而specified 是一个布尔值，用以区别特性是在代码中指定的，还是默认的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> attr = <span class="built_in">document</span>.createAttribute(<span class="string">"align"</span>);</div><div class="line">attr.value = <span class="string">"left"</span>;</div><div class="line">element.setAttributeNode(attr);</div><div class="line">alert(element.attributes[<span class="string">"align"</span>].value); <span class="comment">//"left"</span></div><div class="line">alert(element.getAttributeNode(<span class="string">"align"</span>).value); <span class="comment">//"left"</span></div><div class="line">alert(element.getAttribute(<span class="string">"align"</span>)); <span class="comment">//"left"</span></div></pre></td></tr></table></figure>
<p>并不建议直接访问特性节点。实际上，使用getAttribute()、setAttribute()和removeAttribute()方法远比操作特性节点更为方便。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十章-3]]></title>
      <url>http://codingme.xyz/2016/10/03/javascript-note-10-3/</url>
      <content type="html"><![CDATA[<h1 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h1><h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><p>Element 类型就要算是Web 编程中最常用的类型了。<br>Element 类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。</p>
<ul>
<li>nodeType 的值为1；</li>
<li>nodeName 的值为元素的标签名；</li>
<li>nodeValue 的值为null；</li>
<li>parentNode 可能是Document 或Element；</li>
<li>其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection 或EntityReference。</li>
</ul>
<p>要访问元素的标签名，可以使用nodeName 属性，也可以使用tagName 属性；<br>这两个属性会返回相同的值(使用后者主要是为了清晰起见)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">alert(div.tagName); <span class="comment">//"DIV"</span></div><div class="line">alert(div.tagName == div.nodeName); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>div.tagName 实际上输出的是”DIV”而非”div”。<br>在HTML 中，标签名始终都以全部大写表示；而在XML(有时候也包括XHTML)中，标签名则始终会与源代码中的保持一致。</p>
<p>假如你不确定自己的脚本将会在HTML 还是XML 文档中执行，最好是在比较之前将标签名转换为相同的大小写形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (element.tagName == <span class="string">"div"</span>)&#123; <span class="comment">//不能这样比较，很容易出错！</span></div><div class="line">    <span class="comment">//在此执行某些操作</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (element.tagName.toLowerCase() == <span class="string">"div"</span>)&#123; <span class="comment">//这样最好(适用于任何文档)</span></div><div class="line">    <span class="comment">//在此执行某些操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以在任何浏览器中通过脚本访问Element 类型的构造函数及原型，包括IE8 及之前版本。</p>
<h3 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h3><p>所有HTML 元素都由HTMLElement 类型表示，不是直接通过这个类型，也是通过它的子类型来表示。<br>HTMLElement 类型直接继承自Element 并添加了一些属性。<br>添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性。</p>
<ul>
<li>id，元素在文档中的唯一标识符。</li>
<li>title，有关元素的附加说明信息，一般通过工具提示条显示出来。</li>
<li>lang，元素内容的语言代码，很少使用。</li>
<li>dir，语言的方向，值为”ltr”(left-to-right，从左至右)或”rtl”(right-to-left，从右至左)，也很少使用。</li>
<li>className，与元素的class 特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为class 是ECMAScript 的保留字。</li>
</ul>
<p>上述这些属性都可以用来取得或修改相应的特性值。<br><code>&lt;div id=&quot;myDiv&quot; class=&quot;bd&quot; title=&quot;Body text&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;/div&gt;</code><br>元素中指定的所有信息，都可以通过JavaScript 代码取得。<br>通过为每个属性赋予新的值，也可以修改对应的每个特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">alert(div.id); <span class="comment">//"myDiv""</span></div><div class="line">alert(div.className); <span class="comment">//"bd"</span></div><div class="line">alert(div.title); <span class="comment">//"Body text"</span></div><div class="line">alert(div.lang); <span class="comment">//"en"</span></div><div class="line">alert(div.dir); <span class="comment">//"ltr"</span></div><div class="line"></div><div class="line">div.id = <span class="string">"someOtherId"</span>;</div><div class="line">div.className = <span class="string">"ft"</span>;</div><div class="line">div.title = <span class="string">"Some other text"</span>;</div><div class="line">div.lang = <span class="string">"fr"</span>;</div><div class="line">div.dir =<span class="string">"rtl"</span>;</div></pre></td></tr></table></figure>
<p>对id 或lang 的修改对用户而言是透明不可见的(假设没有基于它们的值设置的CSS 样式)，<br>而对title 的修改则只会在鼠标移动到这个元素之上时才会显示出来。<br>对dir 的修改会在属性被重写的那一刻，立即影响页面中文本的左、右对齐方式。<br>修改className 时，如果新类关联了与此前不同的CSS 样式，那么就会立即应用新的样式。</p>
<p>有许多HTML元素的与之关联的类型可以通过JavaScript访问，但在IE8 之前的版本中不能通过JavaScript 访问。<br>DIV、BUTTON、H1、H2、H3等等。</p>
<h3 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h3><p>操作特性的DOM方法主要有三个，分别是getAttribute()、setAttribute()和removeAttribute()。<br>这三个方法可以针对任何特性使用，包括那些以HTMLElement 类型属性的形式定义的特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line">alert(div.getAttribute(<span class="string">"id"</span>)); <span class="comment">//"myDiv"</span></div><div class="line">alert(div.getAttribute(<span class="string">"class"</span>)); <span class="comment">//"bd"</span></div><div class="line">alert(div.getAttribute(<span class="string">"title"</span>)); <span class="comment">//"Body text"</span></div><div class="line">alert(div.getAttribute(<span class="string">"lang"</span>)); <span class="comment">//"en"</span></div><div class="line">alert(div.getAttribute(<span class="string">"dir"</span>)); <span class="comment">//"ltr"</span></div></pre></td></tr></table></figure>
<p>传递给getAttribute()的特性名与实际的特性名相同。<br>因此要想得到class 特性值，应该传入”class”而不是”className”，后者只有在通过对象属性访问特性时才用。<br>如果给定名称的特性不存在，getAttribute()返回null。</p>
<p>通过getAttribute()方法也可以取得自定义特性(即标准HTML 语言中没有的特性)的值。<br><code>&lt;div id=&quot;myDiv&quot; my_special_attribute=&quot;hello!&quot;&gt;&lt;/div&gt;</code><br>这个元素包含一个名为<code>my_special_attribute</code> 的自定义特性，它的值是”hello!”。<br><code>var value = div.getAttribute(&quot;my_special_attribute&quot;);</code></p>
<p>特性的名称是不区分大小写的，即”ID”和”id”代表的都是同一个特性。<br>另外也要注意，根据HTML5 规范，自定义特性应该加上data-前缀以便验证。</p>
<p>HTMLElement 也会有5个属性与相应的特性一一对应。不过，只有公认的(非自定义的)特性才会以属性的形式添加到DOM对象中。<br><code>&lt;div id=&quot;myDiv&quot; align=&quot;left&quot; my_special_attribute=&quot;hello!&quot;&gt;&lt;/div&gt;</code><br>因为id 和align 在HTML 中是<code>&lt;div&gt;</code>的公认特性，因此该元素的DOM对象中也将存在对应的属性。<br>不过，自定义特性<code>my_special_attribute</code> 在Safari、Opera、Chrome 及Firefox 中是不存在的；<br>但IE 却会为自定义特性也创建属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(div.id); <span class="comment">//"myDiv"</span></div><div class="line">alert(div.my_special_attribute); <span class="comment">//undefined(IE 除外)</span></div><div class="line">alert(div.align); <span class="comment">//"left"</span></div></pre></td></tr></table></figure>
<p>有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不相同。</p>
<p>第一类特性就是style，用于通过CSS 为元素指定样式。<br>在通过getAttribute()访问时，返回的style 特性值中包含的是CSS 文本，而通过属性来访问它则会返回一个对象。<br>由于style 属性是用于以编程方式访问元素样式的，因此并没有直接映射到style 特性。</p>
<p>第二类与众不同的特性是onclick 这样的事件处理程序。<br>当在元素上使用时，onclick 特性中包含的是JavaScript 代码，如果通过getAttribute()访问，则会返回相应代码的字符串。<br>而在访问onclick 属性时，则会返回一个JavaScript 函数(如果未在元素中指定相应特性，则返回null)。<br>这是因为onclick 及其他事件处理程序属性本身就应该被赋予函数值。</p>
<p>由于存在这些差别，在通过JavaScript 以编程方式操作DOM 时，开发人员经常不使用getAttribute()，而是只使用对象的属性。<br>只有在取得自定义特性值的情况下，才会使用getAttribute()方法。</p>
<p>在IE7 及以前版本中，通过getAttribute()方法访问style 特性或onclick 这样的事件处理特性时，返回的值与属性的值相同。<br>不同IE版本间的不一致性，也是导致开发人员不使用getAttribute()访问HTML特性的一个原因。</p>
<h3 id="设置特性"><a href="#设置特性" class="headerlink" title="设置特性"></a>设置特性</h3><p>setAttribute()，这个方法接受两个参数：要设置的特性名和值。<br>如果特性已经存在，setAttribute()会以指定的值替换现有的值；如果特性不存在，setAttribute()则创建该属性并设置相应的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div.setAttribute(<span class="string">"id"</span>, <span class="string">"someOtherId"</span>);</div><div class="line">div.setAttribute(<span class="string">"class"</span>, <span class="string">"ft"</span>);</div><div class="line">div.setAttribute(<span class="string">"title"</span>, <span class="string">"Some other text"</span>);</div><div class="line">div.setAttribute(<span class="string">"lang"</span>,<span class="string">"fr"</span>);</div><div class="line">div.setAttribute(<span class="string">"dir"</span>, <span class="string">"rtl"</span>);</div></pre></td></tr></table></figure>
<p>通过setAttribute()方法既可以操作HTML 特性也可以操作自定义特性。<br>通过这个方法设置的特性名会被统一转换为小写形式，即”ID”最终会变成”id”。</p>
<p>因为所有特性都是属性，所以直接给属性赋值可以设置特性的值，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">div.id = <span class="string">"someOtherId"</span>;</div><div class="line">div.align = <span class="string">"left"</span>;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">div.mycolor = <span class="string">"red"</span>;</div><div class="line">alert(div.getAttribute(<span class="string">"mycolor"</span>)); <span class="comment">//null(IE 除外)</span></div></pre></td></tr></table></figure>
<p>添加了一个名为mycolor 的属性并将它的值设置为”red”。<br>在大多数浏览器中，这个属性都不会自动变成元素的特性，因此想通过getAttribute()取得同名特性的值，结果会返回null。<br>可是，自定义属性在IE 中会被当作元素的特性，反之亦然。<br>尽管到了IE8 才解决这些问题，但我们还是推荐通过属性来设置特性。</p>
<p>removeAttribute()，用于彻底删除元素的特性。调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性。<br><code>div.removeAttribute(&quot;class&quot;);</code><br>IE6 及以前版本不支持removeAttribute()。</p>
<h3 id="attributes-属性"><a href="#attributes-属性" class="headerlink" title="attributes 属性"></a>attributes 属性</h3><p>Element 类型是使用attributes 属性的唯一一个DOM 节点类型。<br>attributes 属性中包含一个NamedNodeMap，与NodeList 类似，也是一个“动态”的集合。<br>元素的每一个特性都由一个Attr 节点表示，每个节点都保存在NamedNodeMap 对象中。<br>NamedNodeMap 对象拥有下列方法。</p>
<ul>
<li>getNamedItem(name)：返回nodeName 属性等于name 的节点；</li>
<li>removeNamedItem(name)：从列表中移除nodeName 属性等于name 的节点；</li>
<li>setNamedItem(node)：向列表中添加节点，以节点的nodeName 属性为索引；</li>
<li>item(pos)：返回位于数字pos 位置处的节点。</li>
</ul>
<p>要取得元素的id 特性，可以使用以下代码。<br><code>var id = element.attributes.getNamedItem(&quot;id&quot;).nodeValue;</code><br><code>var id = element.attributes[&quot;id&quot;].nodeValue;</code><br>可以使用这种语法来设置特性的值，即先取得特性节点，然后再将其nodeValue 设置为新值。<br><code>element.attributes[&quot;id&quot;].nodeValue = &quot;someOtherId&quot;;</code><br>调用removeNamedItem()方法与在元素上调用removeAttribute()方法的效果相同——直接删除具有给定名称的特性。<br><code>var oldAttr = element.attributes.removeNamedItem(&quot;id&quot;);</code><br>setNamedItem()是一个很不常用的方法，通过这个方法可以为元素添加一个新特性，为此需要为它传入一个特性节点。<br><code>element.attributes.setNamedItem(newAttr);</code></p>
<p>由于attributes 的方法不够方便，因此开发人员更多的会使用getAttribute()、removeAttribute()和setAttribute()方法。<br>如果想要遍历元素的特性，attributes 属性倒是可以派上用场。<br>在需要将DOM 结构序列化为XML 或HTML 字符串时，多数都会涉及遍历元素特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputAttributes</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> pairs = <span class="keyword">new</span> <span class="built_in">Array</span>(),</div><div class="line">    attrName,</div><div class="line">    attrValue,</div><div class="line">    i,</div><div class="line">    len;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>, len=element.attributes.length; i &lt; len; i++)&#123;</div><div class="line">        attrName = element.attributes[i].nodeName;</div><div class="line">        attrValue = element.attributes[i].nodeValue;</div><div class="line">        pairs.push(attrName + <span class="string">"=\""</span> + attrValue + <span class="string">"\""</span>);<span class="comment">//转义表示双引号</span></div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> pairs.join(<span class="string">" "</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>针对attributes 对象中的特性，不同浏览器返回的顺序不同。这些特性在XML 或HTML 代码中出现的先后顺序，不一定与它们出现在attributes 对象中的顺序一致。<br>IE7 及更早的版本会返回HTML 元素中所有可能的特性，包括没有指定的特性。换句话说，返回100 多个特性的情况会很常见。(IE又是你！！)<br>针对IE7 及更早版本中存在的问题，可以对上面的函数加以改进，让它只返回指定的特性。<br>每个特性节点都有一个名为specified 的属性，这个属性的值如果为true，则意味着要么是在HTML 中指定了相应特性，要么是通过setAttribute()方法设置了该特性。<br>在IE 中，所有未设置过的特性的该属性值都为false，而在其他浏览器中根本不会为这类特性生成对应的特性节点(因此，在这些浏览器中，任何特性节点的specified 值始终为true)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputAttributes</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> pairs = <span class="keyword">new</span> <span class="built_in">Array</span>(),</div><div class="line">    attrName,</div><div class="line">    attrValue,</div><div class="line">    i,</div><div class="line">    len;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>, len=element.attributes.length; i &lt; len; i++)&#123;</div><div class="line">        attrName = element.attributes[i].nodeName;</div><div class="line">        attrValue = element.attributes[i].nodeValue;</div><div class="line">        <span class="keyword">if</span> (element.attributes[i].specified) &#123;</div><div class="line">            pairs.push(attrName + <span class="string">"=\""</span> + attrValue + <span class="string">"\""</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> pairs.join(<span class="string">" "</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过改进的函数可以确保即使在IE7 及更早的版本中，也会只返回指定的特性。</p>
<h3 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h3><p>document.createElement()方法只接受一个参数，即要创建元素的标签名。<br>标签名在HTML 文档中不区分大小写，而在XML(包括XHTML)文档中，则是区分。<br><code>var div = document.createElement(&quot;div&quot;);</code><br>在使用createElement()方法创建新元素的同时，也为新元素设置了ownerDocuemnt 属性。<br>还可以操作元素的特性，为它添加更多子节点，以及执行其他操作。<br><code>div.id = &quot;myNewDiv&quot;;</code><br><code>div.className = &quot;box&quot;;</code><br>由于新元素尚未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。<br>要把新元素添加到文档树，可以使用appendChild()、insertBefore()或replaceChild()方法。<br>一旦将元素添加到文档树中，浏览器就会立即呈现该元素。此后，对这个元素所作的任何修改都会实时反映在浏览器中。<br>对于IE，能用createElement()创建完整的元素标签:<code>var div = document.createElement(&quot;&lt;div id=\&quot;myNewDiv\&quot; class=\&quot;box\&quot;&gt;&lt;/div &gt;&quot;);</code><br>这种方式有助于避开在IE7 及更早版本中动态创建元素的某些问题。</p>
<ul>
<li>不能设置动态创建的<code>&lt;iframe&gt;</code>元素的name 特性。</li>
<li>不能通过表单的reset()方法重设动态创建的<code>&lt;input&gt;</code>元素(第13 章将讨论reset()方法)。</li>
<li>动态创建的type 特性值为”reset”的<code>&lt;button&gt;</code>元素重设不了表单。</li>
<li>动态创建的一批name 相同的单选按钮彼此毫无关系。name 值相同的一组单选按钮本来应该用于表示同一选项的不同值，但动态创建的一批这种单选按钮之间却没有这种关系。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (client.browser.ie &amp;&amp; client.browser.ie &lt;=<span class="number">7</span>)&#123;</div><div class="line">    <span class="comment">//创建一个带name 特性的iframe 元素</span></div><div class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"&lt;iframe name=\"myframe\"&gt;&lt;/iframe&gt;"</span>);</div><div class="line">    <span class="comment">//创建input 元素</span></div><div class="line">    <span class="keyword">var</span> input = <span class="built_in">document</span>.createElement(<span class="string">"&lt;input type=\"checkbox\"&gt;"</span>);</div><div class="line">    <span class="comment">//创建button 元素</span></div><div class="line">    <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">"&lt;button type=\"reset\"&gt;&lt;/button&gt;"</span>);</div><div class="line">    <span class="comment">//创建单选按钮</span></div><div class="line">    <span class="keyword">var</span> radio1 = <span class="built_in">document</span>.createElement(<span class="string">"&lt;input type=\"radio\" name=\"choice\" "</span>＋</div><div class="line">    <span class="string">"value=\"1\"&gt;"</span>);</div><div class="line">    <span class="keyword">var</span> radio2 = <span class="built_in">document</span>.createElement(<span class="string">"&lt;input type=\"radio\" name=\"choice\" "</span>＋</div><div class="line">    <span class="string">"value=\"2\"&gt;"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于这样的用法要求使用浏览器检测，因此我们建议只在需要避开IE 及更早版本中上述某个问题的情况下使用。</p>
<h3 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h3><p>元素的childNodes 属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点、注释或处理指令。<br>不同浏览器在看待这些节点方面存在显著的不同。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span>//文本节点1</div><div class="line">    //element节点1</div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span>//文本节点2</div><div class="line">    //element节点2</div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span>//文本节点3</div><div class="line">    //element节点3</div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span>//文本节点4</div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果是IE 来解析这些代码，那么<code>&lt;ul&gt;</code>元素会有3 个子节点，分别是3 个<code>&lt;li&gt;</code>元素。<br>如果是在其他浏览器中，<code>&lt;ul&gt;</code>元素都会有7 个元素，包括3 个<code>&lt;li&gt;</code>元素和4 个文本节点(表示<code>&lt;li&gt;</code>元素之间的空白符)。<br>节点之间的空白符，在firefox、chrome、opera、safari浏览器是文本节点。<br>如果像下面这样将元素间的空白符删除，那么所有浏览器都会返回相同数目的子节点。<br><code>&lt;ul id=&quot;myList&quot;&gt;&lt;li&gt;Item 1&lt;/li&gt;&lt;li&gt;Item 2&lt;/li&gt;&lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt;</code><br><code>&lt;ul&gt;</code>元素在任何浏览器中都会包含3 个子节点。如果需要通过childNodes 属性遍历子节点，那么一定不要忘记浏览器间的这一差别。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=element.childNodes.length; i &lt; len; i++)&#123;</div><div class="line">    <span class="keyword">if</span> (element.childNodes[i].nodeType == <span class="number">1</span>)&#123;</div><div class="line">    <span class="comment">//执行某些操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只在子节点的nodeType 等于1(表示是元素节点)的情况下，才会执行某些操作。</p>
<p>要想取得前面<code>&lt;ul&gt;</code>元素中包含的所有<code>&lt;li&gt;</code>元素，可以使用下列代码。<br><code>var ul = document.getElementById(&quot;myList&quot;);</code><br><code>var items = ul.getElementsByTagName(&quot;li&quot;);</code></p>
<p>这里<code>&lt;ul&gt;</code>的后代中只包含直接子元素。不过，如果它包含更多层次的后代元素，那么各个层次中包含的<code>&lt;li&gt;</code>元素也都会返回。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十章-2]]></title>
      <url>http://codingme.xyz/2016/10/03/javascript-note-10-2/</url>
      <content type="html"><![CDATA[<h1 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h1><h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p>JavaScript 通过Document 类型表示文档。<br>在浏览器中，document 对象是HTMLDocument(继承自Document 类型)的一个实例，表示整个HTML 页面。<br>document 对象是window 对象的一个属性，因此可以将其作为全局对象来访问。<br>Document 节点具有下列特征：</p>
<ul>
<li>nodeType 的值为9；</li>
<li>nodeName 的值为”#document”；</li>
<li>nodeValue 的值为null；</li>
<li>parentNode 的值为null；</li>
<li>ownerDocument 的值为 null；</li>
<li>其子节点可能是一个DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction或Comment。</li>
</ul>
<p>Document 类型可以表示HTML 页面或者其他基于XML 的文档。<br>不过，最常见的应用还是作为HTMLDocument 实例的document 对象。</p>
<h3 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h3><p>Document 节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment，但还有两个内置的访问其子节点的快捷方式。<br>第一个就是documentElement属性，该属性始终指向HTML 页面中的<code>&lt;html&gt;</code>元素。<br>另一个就是通过childNodes 列表访问文档元素，但通过documentElement 属性则能更快捷、更直接地访问该元素。<br><a id="more"></a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个页面在经过浏览器解析后，其文档中只包含一个子节点，即<code>&lt;html&gt;</code>元素。<br>可以通过documentElement 或childNodes 列表来访问这个元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement; <span class="comment">//取得对&lt;html&gt;的引用</span></div><div class="line">alert(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>]); <span class="comment">//true</span></div><div class="line">alert(html === <span class="built_in">document</span>.firstChild); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>作为HTMLDocument 的实例，document 对象还有一个body 属性，直接指向<code>&lt;body&gt;</code>元素。<br>因为开发人员经常要使用这个元素，所以document.body 在JavaScript 代码中出现的频率非常高。<br><code>var body = document.body; //取得对&lt;body&gt;的引用</code><br>所有浏览器都支持document.documentElement 和document.body 属性。</p>
<p>Document 另一个可能的子节点是DocumentType。<br>通常将<code>&lt;!DOCTYPE&gt;</code>标签看成一个与文档其他部分不同的实体，可以通过doctype 属性(在浏览器中是document.doctype)来访问它的信息。<br><code>var doctype = document.doctype; //取得对&lt;!DOCTYPE&gt;的引用</code><br>浏览器对document.doctype 的支持差别很大。</p>
<ul>
<li>IE8 及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当作Comment节点；而document.doctype 的值始终为null。</li>
<li>IE9+及Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点；document.doctype是一个DocumentType 节点，也可以通过document.firstChild 或document.childNodes[0]访问同一个节点。</li>
<li>Safari、Chrome 和Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。document.doctype 是一个DocumentType 节点，但该节点不会出现在document.childNodes 中。</li>
</ul>
<p>由于浏览器对document.doctype 的支持不一致，因此这个属性的用处很有限。<br>从技术上说，出现在<code>&lt;html&gt;</code>元素外部的注释应该算是文档的子节点。<br>然而，不同的浏览器在是否解析这些注释以及能否正确处理它们等方面，也存在很大差异。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--第一条注释 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--第二条注释 --&gt;</span></div></pre></td></tr></table></figure>
<p>看起来这个页面应该有3 个子节点：注释、<code>&lt;html&gt;</code>元素、注释。</p>
<ul>
<li>IE8 及之前版本、Safari 3.1 及更高版本、Opera 和Chrome 只为第一条注释创建节点，不为第二条注释创建节点。结果，第一条注释就会成为document.childNodes 中的第一个子节点。</li>
<li>IE9 及更高版本会将第一条注释创建为document.childNodes 中的一个注释节点，也会将第二条注释创建为document.childNodes 中的注释子节点。</li>
<li>Firefox 以及Safari 3.1 之前的版本会完全忽略这两条注释。</li>
</ul>
<p>浏览器间的这种不一致性也导致了位于<code>&lt;html&gt;</code>元素外部的注释没有什么用处。<br>多数情况下，我们都用不着在document 对象上调用appendChild()、removeChild()和replaceChild()方法，<br>因为文档类型(如果存在的话)是只读的，而且它只能有一个元素子节点(该节点通常早就已经存在了)。</p>
<h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><p>作为HTMLDocument 的一个实例，document 对象还有一些标准的Document 对象所没有的属性。<br>这些属性提供了document 对象所表现的网页的一些信息。<br>其中第一个属性就是title，包含着<code>&lt;title&gt;</code>元素中的文本——显示在浏览器窗口的标题栏或标签页上。<br>修改title 属性的值不会改变<code>&lt;title&gt;</code>元素。</p>
<p>三个属性：URL、domain 和referrer。<br>URL 属性中包含页面完整的URL(即地址栏中显示的URL)，<br>domain 属性中只包含页面的域名，<br>而referrer属性中则保存着链接到当前页面的那个页面的URL。<br>所有这些信息都存在于请求的HTTP 头部，<br>只不过是通过这些属性让我们能够在JavaScrip 中访问它们。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得完整的URL</span></div><div class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.URL;</div><div class="line"><span class="comment">//取得域名</span></div><div class="line"><span class="keyword">var</span> domain = <span class="built_in">document</span>.domain;</div><div class="line"><span class="comment">//取得来源页面的URL</span></div><div class="line"><span class="keyword">var</span> referrer = <span class="built_in">document</span>.referrer;</div></pre></td></tr></table></figure>
<p>在这3 个属性中，只有domain 是可以设置的。<br>但由于安全方面的限制，也并非可以给domain 设置任何值。<br>如果URL 中包含一个子域名，例如p2p.wrox.com，那么就只能将domain 设置为”wrox.com”(URL 中包含”www”，如www.wrox.com 时，也是如此)。不能将这个属性设置为URL 中不包含的域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//假设页面来自p2p.wrox.com 域</span></div><div class="line"><span class="built_in">document</span>.domain = <span class="string">"wrox.com"</span>; <span class="comment">// 成功</span></div><div class="line"><span class="built_in">document</span>.domain = <span class="string">"nczonline.net"</span>; <span class="comment">// 出错！</span></div></pre></td></tr></table></figure>
<p>当页面中包含来自其他子域的框架或内嵌框架时，能够设置document.domain 就非常方便了。<br>由于跨域安全限制， 来自不同子域的页面无法通过JavaScript 通信。<br>而通过将每个页面的document.domain 设置为相同的值，这些页面就可以互相访问对方包含的JavaScript 对象了。</p>
<p>假设有一个页面加载自www.wrox.com，其中包含一个内嵌框架，框架内的页面加载自p2p.wrox.com。<br>由于document.domain 字符串不一样，内外两个页面之间无法相互访问对方的JavaScript 对象。<br>但如果将这两个页面的document.domain 值都设置为”wrox.com”，它们之间就可以通信了。</p>
<p>浏览器对domain 属性还有一个限制，即如果域名一开始是“松散的”(loose)，那么不能将它再设<br>置为“紧绷的”(tight)。换句话说，在将document.domain 设置为”wrox.com”之后，就不能再将其<br>设置回”p2p.wrox.com”，否则将会导致错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//假设页面来自于p2p.wrox.com 域</span></div><div class="line"><span class="built_in">document</span>.domain = <span class="string">"wrox.com"</span>; <span class="comment">//松散的(成功)</span></div><div class="line"><span class="built_in">document</span>.domain = <span class="string">"p2p.wrox.com"</span>; <span class="comment">//紧绷的(出错！)</span></div></pre></td></tr></table></figure>
<p>所有浏览器中都存在这个限制，但IE8 是实现这一限制的最早的IE 版本。(所以IE7、IE6就…)</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>getElementById()，接收一个参数：要取得的元素的ID。<br>如果找到相应的元素则返回该元素，如果不存在带有相应ID 的元素，则返回null。<br>这里的ID 必须与页面中元素的id特性(attribute)严格匹配，包括大小写。<br>IE8 及较低版本不区分ID 的大小写，因此”myDiv”和”mydiv”会被当作相同的元素ID。<br>如果页面中多个元素的ID 值相同，getElementById()只返回文档中第一次出现的元素。</p>
<p>IE7 及较低版本还为此方法添加了一个有意思的“怪癖”：name 特性与给定ID 匹配的表单元素<br>(<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;button&gt;</code>及<code>&lt;select&gt;</code>)也会被该方法返回。<br>如果有哪个表单元素的name 特性等于指定的ID，而且该元素在文档中位于带有给定ID 的元素前面，那么IE 就会返回那个表单元素。<br>为了避免IE 中存在的这个问题，最好的办法是不让表单字段的name 特性与其他元素的ID 相同。</p>
<p>另一个常用于取得元素引用的方法是getElementsByTagName()。<br>这个方法接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的NodeList。<br>在HTML 文档中，这个方法会返回一个HTMLCollection 对象，作为一个“动态”集合，该对象与NodeList 非常类似。<br><code>var images = document.getElementsByTagName(&quot;img&quot;);</code><br>这行代码会将一个HTMLCollection 对象保存在images 变量中。<br>与NodeList 对象类似，可以使用方括号语法或item()方法来访问HTMLCollection 对象中的项。<br>HTMLCollection 对象还有一个方法，叫做namedItem()，使用这个方法可以通过元素的name特性取得集合中的项。<br><code>&lt;img src=&quot;myimage.gif&quot; name=&quot;myImage&quot;&gt;</code><br><code>var myImage = images.namedItem(&quot;myImage&quot;);</code><br>在提供按索引访问项的基础上，HTMLCollection 还支持按名称访问项，这就为我们取得实际想要的元素提供了便利。<br>而且，对命名的项也可以使用方括号语法来访问。<br>对HTMLCollection 而言，我们可以向方括号中传入数值或字符串形式的索引值。<br>在后台，对数值索引就会调用item()，而对字符串索引就会调用namedItem()。</p>
<p>由于IE 将注释(Comment)实现为元素(Element)，因此在IE 中调用getElementsByTagName(“*”)将会返回所有注释节点。</p>
<p>为了最大限度地与既有HTML 页面兼容，传给getElementsByTagName()的标签名是不需要区分大小写的。<br>但对于XML页面而言(包括XHTML)，getElementsByTagName()方法就会区分大小写。</p>
<p>第三个方法，也是只有HTMLDocument 类型才有的方法，是getElementsByName()。<br>这个方法会返回带有给定name 特性的所有元素。<br>最常使用getElementsByName()方法的情况是取得单选按钮；<br>为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的name 特性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Which color do you prefer?<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"red"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorRed"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorRed"</span>&gt;</span>Red<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"green"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorGreen"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorGreen"</span>&gt;</span>Green<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"blue"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorBlue"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorBlue"</span>&gt;</span>Blue<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中所有单选按钮的name 特性值都是”color”，但它们的ID 可以不同。<br>ID 的作用在于将<code>&lt;label&gt;</code>元素应用到每个单选按钮，而name 特性则用以确保三个值中只有一个被发送给浏览器。</p>
<p>getElementsByName()方法也会返回一个HTMLCollectioin。<br>但是，对于这里的单选按钮来说，namedItem()方法则只会取得第一项(因为每一项的name 特性都相同)。<br>(那么 getElementsByTagName() 方法的namedItmen()就不会只取得第一项么？)</p>
<h3 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h3><p>document 对象的一些特殊的集合。这些集合都是HTMLCollection 对象，为访问文档常用的部分提供了快捷方式。</p>
<ul>
<li>document.anchors，包含文档中所有带name 特性的<code>&lt;a&gt;</code>元素；</li>
<li>document.applets，包含文档中所有的<code>&lt;applet&gt;</code>元素，因为不再推荐使用<code>&lt;applet&gt;</code>元素，所以这个集合已经不建议使用了；</li>
<li>document.forms，包含文档中所有的<code>&lt;form&gt;</code>元素，与document.getElementsByTagName(“form”)得到的结果相同；</li>
<li>document.images，包含文档中所有的<code>&lt;img&gt;</code>元素，与document.getElementsByTagName(“img”)得到的结果相同；</li>
<li>document.links，包含文档中所有带href 特性的<code>&lt;a&gt;</code>元素。</li>
</ul>
<p>始终都可以通过HTMLDocument 对象访问到，而且，与HTMLCollection 对象类似，集合中的项也会随着当前文档内容的更新而更新。</p>
<h3 id="DOM-一致性检测"><a href="#DOM-一致性检测" class="headerlink" title="DOM 一致性检测"></a>DOM 一致性检测</h3><p>检测浏览器实现了DOM的哪些部分十分必要。<br>document.implementation 属性就是为此提供相应信息和功能的对象，与浏览器对DOM的实现直接对应。<br>DOM1 级只为document.implementation 规定了一个方法，即hasFeature()。<br>这个方法接受两个参数：要检测的DOM 功能的名称及版本号。<br>如果浏览器支持给定名称和版本的功能，则该方法返回true。<br><code>var hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;, &quot;1.0&quot;);</code><br>尽管使用hasFeature()确实方便，但也有缺点。因为实现者可以自行决定是否与DOM 规范的不同部分保持一致。<br>例如，Safari 2.x 及更早版本会在没有完全实现某些DOM 功能的情况下也返回true。<br>所以在使用DOM 的某些特殊的功能之前，最好除了检测hasFeature()之外，还同时使用能力检测。</p>
<h3 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h3><p>4 个方法：write()、writeln()、open()和close()。<br>write()和writeln()方法都接受一个字符串参数，即要写入到输出流中的文本。<br>后者会在字符串的末尾添加一个换行符(\n)。<br>在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容。<br>还可以使用write()和writeln()方法动态地包含外部资源，例如JavaScript 文件等。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example 3<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="xml"></span></div><div class="line">        document.write("<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">\</span>"<span class="attr">text</span>/<span class="attr">javascript</span>\" <span class="attr">src</span>=<span class="string">\</span>"<span class="attr">file.js</span>\"&gt;</span><span class="xml">" +</span></div><div class="line">        "<span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span>");</div><div class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果在文档加载结束后再调用document.write()，那么输出的内容将会重写整个页面。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example 4<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is some content that you won't get to see because it will be overwritten.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">document</span>.write(<span class="string">"Hello world!"</span>);</div><div class="line">        &#125;;</div><div class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用了window.onload 事件处理程序，等到页面完全加载之后延迟执行函数。<br>函数执行之后，字符串”Hello world!”会重写整个页面内容。</p>
<p>严格型XHTML 文档不支持文档写入。对于那些按照application/xml+xhtml内容类型提供的页面，这两个方法也同样无效。</p>
<p>方法open()和close()分别用于打开和关闭网页的输出流。<br>如果是在页面加载期间使用write()或writeln()方法，则不需要用到这两个方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第十章-1]]></title>
      <url>http://codingme.xyz/2016/10/02/javascript-note-10-1/</url>
      <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>针对HTML 和XML 文档的一个API。<br>脱胎于Netscape 及微软公司创始的DHTML(动态HTML)。<br>已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。</p>
<h1 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h1><p><code>&lt;html&gt;</code>元素称之为文档元素。<br>每个文档只能有一个文档元素。<br>文档元素是文档的最外层元素。<br>在HTML 页面中，文档元素始终都是<code>&lt;html&gt;</code>元素。<br>在XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。<br>标记都可以通过树中的节点来表示：<br>HTML 元素通过元素节点表示，<br>特性(attribute)通过特性节点表示，<br>文档类型通过文档类型节点表示，<br>而注释则通过注释节点表示。<br>总共有12 种节点类型，这些类型都继承自一个基类型。<br><a id="more"></a></p>
<h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><p>DOM1 级定义了一个Node 接口，该接口将由DOM 中的所有节点类型实现。<br>这个Node 接口在JavaScript 中是作为Node 类型实现的；<br>除了IE 之外，在其他所有浏览器中都可以访问到这个类型。<br>JavaScript 中的所有节点类型都继承自Node 类型，因此所有节点类型都共享着相同的基本属性和方法。</p>
<p>每个节点都有一个nodeType 属性，用于表明节点的类型。<br>节点类型由在Node 类型中定义的下列12 个数值常量来表示。</p>
<pre><code>Node.ELEMENT_NODE(1)；
Node.ATTRIBUTE_NODE(2)；
Node.TEXT_NODE(3)；
Node.CDATA_SECTION_NODE(4)；
Node.ENTITY_REFERENCE_NODE(5)；
Node.ENTITY_NODE(6)；
Node.PROCESSING_INSTRUCTION_NODE(7)；
Node.COMMENT_NODE(8)；
Node.DOCUMENT_NODE(9)；
Node.DOCUMENT_TYPE_NODE(10)；
Node.DOCUMENT_FRAGMENT_NODE(11)；
Node.NOTATION_NODE(12)。
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (someNode.nodeType == Node.ELEMENT_NODE)&#123; <span class="comment">//在IE 中无效,IE9以下无法访问Node类型</span></div><div class="line">    alert(<span class="string">"Node is an element."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于IE 没有公开Node 类型的构造函数，因此上面的代码在IE 中会导致错误。<br>为了确保跨浏览器兼容，最好还是将nodeType 属性与数字值进行比较。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123; <span class="comment">//适用于所有浏览器</span></div><div class="line">    alert(<span class="string">"Node is an element."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不是所有节点类型都受到Web 浏览器的支持。<br>开发人员最常用的就是元素和文本节点。</p>
<h3 id="nodeName-和nodeValue-属性"><a href="#nodeName-和nodeValue-属性" class="headerlink" title="nodeName 和nodeValue 属性"></a>nodeName 和nodeValue 属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123;</div><div class="line">    value = someNode.nodeName; <span class="comment">//nodeName 的值是元素的标签名</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于元素节点，nodeName 中保存的始终都是元素的标签名，而nodeValue 的值则始终为null。</p>
<h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><p>节点间的各种关系可以用传统的家族关系来描述，相当于把文档树比喻成家谱。</p>
<p>每个节点都有一个childNodes 属性，其中保存着一个NodeList 对象。<br>NodeList 是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。<br>注意：虽然可以通过方括号语法来访问NodeList 的值，而且这个对象也有length 属性，但它并不是Array 的实例。<br>NodeList 对象的独特之处在于，它实际上是基于DOM 结构动态执行查询的结果，因此DOM结构的变化能够自动反映在NodeList 对象中。<br>有这么个说法：NodeList 是有生命、有呼吸的对象，而不是在我们第一次访问它们的某个瞬间拍摄下来的一张快照。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> count = someNode.childNodes.length;</div></pre></td></tr></table></figure>
<p>无论使用方括号还是使用item()方法都没有问题，但使用方括号语法看起来与访问数组相似，因此颇受一些开发人员的青睐。<br>length 属性表示的是访问NodeList 的那一刻，其中包含的节点数量。<br>对arguments 对象使用Array.prototype.slice()方法可以将其转换为数组。而采用同样的方法，也可以将NodeList 对象转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在IE8 及之前版本中无效</span></div><div class="line"><span class="keyword">var</span> arrayOfNodes = <span class="built_in">Array</span>.prototype.slice.call(someNode.childNodes,<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>IE8 及更早版本将NodeList实现为一个COM 对象，而我们不能像使用JScript 对象那样使用这种对象，<br>因此上面的代码会导致错误。<br>要想在IE 中将NodeList 转换为数组，必须手动枚举所有成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToArray</span>(<span class="params">nodes</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> array = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        array = <span class="built_in">Array</span>.prototype.slice.call(nodes, <span class="number">0</span>); <span class="comment">//针对非IE 浏览器</span></div><div class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        array = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=nodes.length; i &lt; len; i++)&#123;</div><div class="line">        array.push(nodes[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个节点都有一个parentNode 属性，该属性指向文档树中的父节点。<br>包含在childNodes 列表中的所有节点都具有相同的父节点，因此它们的parentNode 属性都指向同一个节点。<br>包含在childNodes 列表中的每个节点相互之间都是同胞节点。<br>通过使用列表中每个节点的previousSibling和nextSibling 属性，可以访问同一列表中的其他节点。<br>列表中第一个节点的previousSibling 属性值为null，<br>而列表中最后一个节点的nextSibling 属性的值同样也为null<br>如果列表中只有一个节点，那么该节点的nextSibling 和previousSibling 都为null。<br>父节点的firstChild 和lastChild属性分别指向其childNodes 列表中的第一个和最后一个节点。<br>在只有一个子节点的情况下，firstChild 和lastChild 指向同一个节点。如果没有子节点，那么firstChild 和lastChild 的值均为null。<br>hasChildNodes()这个方法在节点包含一或多个子节点的情况下返回true；这是比查询childNodes列表的length 属性更简单的方法。<br>所有节点都有的最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点。</p>
<h3 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h3><p>因为<strong>关系指针都是只读的</strong>，所以DOM 提供了一些操作节点的方法。<br>1.appendChild():用于向childNodes 列表的末尾添加一个节点。<br>更新完成后，appendChild()返回新增的节点。<br>如果传入到appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。</p>
<p>2.insertBefore()方法：把节点放在childNodes 列表中某个特定的位置上，而不是放在末尾。<br>这个方法接受两个参数：要插入的节点和作为参照的节点。<br>插入节点后，被插入的节点会变成参照节点的前一个同胞节点(previousSibling)，同时被方法返回。<br>如果参照节点是null，则insertBefore()与appendChild()执行相同的操作。</p>
<p>3.replaceChild()方法接受的两个参数：要插入的节点和要替换的节点。<br>要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。<br>从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。</p>
<p>4.removeChild()方法：只想移除而非替换节点，可以使用这个方法。接受一个参数，即要移除的节点。<br>通过removeChild()移除的节点仍然为文档所有，只不过在文档中已经没有了自己的位置。</p>
<p>四个方法操作的都是某个节点的子节点，也就是说，要使用这几个方法必须先取得父节点(使用parentNode 属性)。<br>另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>有两个方法是所有类型的节点都有的。</p>
<ol>
<li><p>cloneNode()，用于创建调用这个方法的节点的一个完全相同的副本。<br> cloneNode()方法接受一个布尔值参数，表示是否执行深复制。<br> 在参数为true的情况下，执行深复制，也就是复制节点及其整个子节点树；<br> 在参数为false 的情况下，执行浅复制，即只复制节点本身。<br> 复制后返回的节点副本属于文档所有，但并没有为它指定父节点。<br> 因此，这个节点副本就成为了一个“孤儿”，除非通过appendChild()、insertBefore()或replaceChild()将它添加到文档中。</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> deepList = myList.cloneNode(<span class="literal">true</span>);</div><div class="line">alert(deepList.childNodes.length); <span class="comment">//3(IE &lt; 9)或7(其他浏览器)</span></div><div class="line"><span class="keyword">var</span> shallowList = myList.cloneNode(<span class="literal">false</span>);</div><div class="line">alert(shallowList.childNodes.length); <span class="comment">//0</span></div></pre></td></tr></table></figure>
<p> deepList.childNodes.length 中的差异主要是因为IE8 及更早版本与其他浏览器处理空白字符的方式不一样。<br> IE9 之前的版本不会为空白符创建节点。<br> cloneNode()方法不会复制添加到DOM 节点中的JavaScript 属性，例如事件处理程序等。<br> 这个方法只复制特性、(在明确指定的情况下也复制)子节点，其他一切都不会复制。<br> IE 在此存在一个bug，即它会复制事件处理程序，所以建议在复制之前最好先移除事件处理程序。</p>
</li>
<li>normalize()，这个方法唯一的作用就是处理文档树中的文本节点。<br> 由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。<br> 当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。<br> 如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第九章-2]]></title>
      <url>http://codingme.xyz/2016/10/02/javascript-note-9-2/</url>
      <content type="html"><![CDATA[<h1 id="用户代理字符串检测技术"><a href="#用户代理字符串检测技术" class="headerlink" title="用户代理字符串检测技术"></a>用户代理字符串检测技术</h1><p>首先要确定的往往是你需要多么具体的浏览器信息。<br>一般情况下，知道呈现引擎和最低限度的版本就足以决定正确的操作方法了。<br>不推荐的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (isIE6 || isIE7) &#123; <span class="comment">//不推荐!!!</span></div><div class="line"><span class="comment">//代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种代码其实是很脆弱的，因为它要依据特定的版本来决定做什么。<br>如果是IE8 怎么办呢？只要IE 有新版本出来，就必须更新这些代码。</p>
<p>使用这类代码可以避免：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (ieVer &gt;=<span class="number">6</span>)&#123;</div><div class="line"><span class="comment">//代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="识别呈现引擎"><a href="#识别呈现引擎" class="headerlink" title="识别呈现引擎"></a>识别呈现引擎</h2><p>主要检测五大呈现引擎：IE、Gecko、WebKit、KHTML 和Opera。<br>使用模块增强模式来封装检测脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> client = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> engine = &#123;</div><div class="line">        <span class="comment">//呈现引擎</span></div><div class="line">        ie: <span class="number">0</span>,</div><div class="line">        gecko: <span class="number">0</span>,</div><div class="line">        webkit: <span class="number">0</span>,</div><div class="line">        khtml: <span class="number">0</span>,</div><div class="line">        opera: <span class="number">0</span>,</div><div class="line">        <span class="comment">//具体的版本号</span></div><div class="line">        ver: <span class="literal">null</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//在此检测呈现引擎、平台和设备</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        engine : engine</div><div class="line">    &#125;;</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="keyword">if</span> (client.engine.ie) &#123; <span class="comment">//如果是IE，client.ie 的值应该大于0</span></div><div class="line">    <span class="comment">//针对IE 的代码</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (client.engine.gecko &gt; <span class="number">1.5</span>)&#123;</div><div class="line">    <span class="keyword">if</span> (client.engine.ver == <span class="string">"1.8.1"</span>)&#123;</div><div class="line">        <span class="comment">//针对这个版本执行某些操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>声明了一个名为client 的全局变量，用于保存相关信息。<br>匿名函数内部定义了一个局部变量engine，它是一个包含默认设置的对象字面量。<br>每个呈现引擎都对应着一个属性，属性的值默认为0。<br>如果检测到了哪个呈现引擎，那么就以浮点数值形式将该引擎的版本号写入相应的属性。<br>而呈现引擎的完整版本(是一个字符串)，则被写入ver 属性。<br>在检测到一个呈现引擎之后，其client.engine 中对应的属性将被设置为一个大于0 的值，该值可以转换成布尔值true。<br>鉴于每个属性都包含一个浮点数值，因此有可能丢失某些版本信息。例如，将字符串”1.8.1”传入parseFloat()后会得到数值1.8。<br>不过，在必要的时候可以检测ver 属性，该属性中会保存完整的版本信息。</p>
<p>要正确地识别呈现引擎，关键是检测顺序要正确。</p>
<ol>
<li>首先要检测 Opera。检测什么 opera …已经没人用的浏览器有什么好检测的…</li>
<li><p>放在第二位检测的呈现引擎是WebKit。<br> WebKit 的用户代理字符串中包含”Gecko”和”KHTML”这两个子字符串，所以如果首先检测它们，很可能会得出错误的结论。<br> WebKit 的用户代理字符串中的”AppleWebKit”是独一无二的，因此检测这个字符串最合适。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ua = navigator.userAgent;</div><div class="line"><span class="keyword">if</span> (<span class="regexp">/AppleWebKit\/(\S+)/</span>.test(ua))&#123;</div><div class="line">    engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">    engine.webkit = <span class="built_in">parseFloat</span>(engine.ver);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 首先将用户代理字符串保存在变量ua 中。然后通过正则表达式来测试其中是否包含字符串”AppleWebKit”，并使用捕获组来取得版本号。<br> 由于实际的版本号中可能会包含数字、小数点和字母，所以捕获组中使用了表示非空格的特殊字符(\S)。<br> 用户代理字符串中的版本号与下一部分的分隔符是一个空格，因此这个模式可以保证捕获所有版本信息。</p>
</li>
<li><p>测试呈现引擎KHTML。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ua = navigator.userAgent;</div><div class="line">……</div><div class="line"><span class="keyword">if</span> (<span class="regexp">/KHTML\/(\S+)/</span>.test(ua) || <span class="regexp">/Konqueror\/([^;]+)/</span>.test(ua))&#123;</div><div class="line">    engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">    engine.khtml = <span class="built_in">parseFloat</span>(engine.ver);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 由于KHTML 的版本号与后继的标记之间有一个空格，因此仍然要使用特殊的非空格字符来取得与版本有关的所有字符。<br> 将字符串形式的版本信息保存在engine.ver 中，将浮点数值形式的版本保存在engin.khtml 中。<br> 如果KHTML 不在用户代理字符串中，那么就要匹配Konqueror后跟一个斜杠，再后跟不包含分号的所有字符。</p>
</li>
<li><p>测试检测 Gecko。<br> 在用户代理字符串中，Gecko的版本号不会出现在字符串”Gecko”的后面，而是会出现在字符串”rv:”的后面。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ua = navigator.userAgent;</div><div class="line">……</div><div class="line"><span class="keyword">if</span> (<span class="regexp">/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/</span>.test(ua))&#123;</div><div class="line">    engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">    engine.gecko = <span class="built_in">parseFloat</span>(engine.ver);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> Gecko 的版本号位于字符串”rv:”与一个闭括号之间，因此为了提取出这个版本号，正则表达式要查找所有不是闭括号的字符，还要查找字符串”Gecko/“后跟8 个数字。</p>
</li>
<li><p>检测呈现引擎 IE。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ua = navigator.userAgent;</div><div class="line">……</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/MSIE ([^;]+)/</span>.test(ua))&#123;</div><div class="line">    engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">    engine.ie = <span class="built_in">parseFloat</span>(engine.ver);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在正则表达式中使用取反的字符类来取得不是分号的所有字符。<br> IE 通常会保证以标准浮点数值形式给出其版本号，但有时候也不一定。<br> 因此，取反的字符类[^;]可以确保取得多个小数点以及任何可能的字符。</p>
</li>
</ol>
<h2 id="识别浏览器"><a href="#识别浏览器" class="headerlink" title="识别浏览器"></a>识别浏览器</h2><p>苹果公司的Safari 浏览器和谷歌公司的Chrome 浏览器都使用WebKit 作为呈现引擎，但它们的JavaScript 引擎却不一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> client = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> engine = &#123;</div><div class="line">            ……</div><div class="line">        &#125;;</div><div class="line">    <span class="keyword">var</span> browser = &#123;</div><div class="line">        <span class="comment">//浏览器</span></div><div class="line">        ie: <span class="number">0</span>,</div><div class="line">        firefox: <span class="number">0</span>,</div><div class="line">        safari: <span class="number">0</span>,</div><div class="line">        konq: <span class="number">0</span>,</div><div class="line">        opera: <span class="number">0</span>,</div><div class="line">        chrome: <span class="number">0</span>,</div><div class="line">        <span class="comment">//具体的版本</span></div><div class="line">        ver: <span class="literal">null</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//在此检测呈现引擎、平台和设备</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        engine: engine,</div><div class="line">        browser: browser</div><div class="line">    &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>代码中又添加了私有变量browser，用于保存每个主要浏览器的属性。<br>与engine 变量一样，除了当前使用的浏览器，其他属性的值将保持为0；<br>如果是当前使用的浏览器，则这个属性中保存的是浮点数值形式的版本号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">……</div><div class="line"><span class="comment">//确定是Chrome 还是Safari</span></div><div class="line"><span class="keyword">if</span> (<span class="regexp">/Chrome\/(\S+)/</span>.test(ua))&#123;</div><div class="line">    browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">    browser.chrome = <span class="built_in">parseFloat</span>(browser.ver);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/Version\/(\S+)/</span>.test(ua))&#123;</div><div class="line">    browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">    browser.safari = <span class="built_in">parseFloat</span>(browser.ver);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//近似地确定版本号</span></div><div class="line">    <span class="keyword">var</span> safariVersion = <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (engine.webkit &lt; <span class="number">100</span>)&#123;</div><div class="line">        safariVersion = <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine.webkit &lt; <span class="number">312</span>)&#123;</div><div class="line">        safariVersion = <span class="number">1.2</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine.webkit &lt; <span class="number">412</span>)&#123;</div><div class="line">        safariVersion = <span class="number">1.3</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        safariVersion = <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    browser.safari = browser.ver = safariVersion;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/KHTML\/(\S+)/</span>.test(ua) || <span class="regexp">/Konqueror\/([^;]+)/</span>.test(ua))&#123;</div><div class="line">    engine.ver = browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">    engine.khtml = browser.konq = <span class="built_in">parseFloat</span>(engine.ver);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/</span>.test(ua))&#123;</div><div class="line">    engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">    engine.gecko = <span class="built_in">parseFloat</span>(engine.ver);</div><div class="line"><span class="comment">//确定是不是Firefox</span></div><div class="line"><span class="keyword">if</span> (<span class="regexp">/Firefox\/(\S+)/</span>.test(ua))&#123;</div><div class="line">    browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">    browser.firefox = <span class="built_in">parseFloat</span>(browser.ver);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/MSIE ([^;]+)/</span>.test(ua))&#123;</div><div class="line">    engine.ver = browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">    engine.ie = browser.ie = <span class="built_in">parseFloat</span>(engine.ver);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后就能针对浏览器编写代码了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (client.engine.webkit) &#123; <span class="comment">//if it’s WebKit</span></div><div class="line">    <span class="keyword">if</span> (client.browser.chrome)&#123;</div><div class="line">        <span class="comment">//执行针对Chrome 的代码</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (client.browser.safari)&#123;</div><div class="line">        <span class="comment">//执行针对Safari 的代码</span></div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (client.engine.gecko)&#123;</div><div class="line">    <span class="keyword">if</span> (client.browser.firefox)&#123;</div><div class="line">        <span class="comment">//执行针对Firefox 的代码</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//执行针对其他Gecko 浏览器的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="识别平台"><a href="#识别平台" class="headerlink" title="识别平台"></a>识别平台</h2><p>一样的老套路。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">……</div><div class="line">    <span class="keyword">var</span> system = &#123;</div><div class="line">        win: <span class="literal">false</span>,</div><div class="line">        mac: <span class="literal">false</span>,</div><div class="line">        x11: <span class="literal">false</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        engine: engine,</div><div class="line">        browser: browser,</div><div class="line">        system: system</div><div class="line">    &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>确定平台时，检测navigator.platform 要比检测用户代理字符串更简单，后者在不同浏览器中会给出不同的平台信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = navigator.platform;</div><div class="line">system.win = p.indexOf(<span class="string">"Win"</span>) == <span class="number">0</span>;</div><div class="line">system.mac = p.indexOf(<span class="string">"Mac"</span>) == <span class="number">0</span>;</div><div class="line">system.x11 = (p.indexOf(<span class="string">"X11"</span>) == <span class="number">0</span>) || (p.indexOf(<span class="string">"Linux"</span>) == <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>检测Unix 时，则同时检查了字符串”X11”和”Linux”。</p>
<h2 id="识别Windows-操作系统"><a href="#识别Windows-操作系统" class="headerlink" title="识别Windows 操作系统"></a>识别Windows 操作系统</h2><p>(话说浏览器JavaScript为啥需要识别到哪个Windows系统这么细..)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (system.win)&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="regexp">/Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/</span>.test(ua))&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">RegExp</span>[<span class="string">"$1"</span>] == <span class="string">"NT"</span>)&#123;</div><div class="line">            <span class="keyword">switch</span>(<span class="built_in">RegExp</span>[<span class="string">"$2"</span>])&#123;</div><div class="line">                <span class="keyword">case</span> <span class="string">"5.0"</span>:</div><div class="line">                system.win = <span class="string">"2000"</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="string">"5.1"</span>:</div><div class="line">                system.win = <span class="string">"XP"</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="string">"6.0"</span>:</div><div class="line">                system.win = <span class="string">"Vista"</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> <span class="string">"6.1"</span>:</div><div class="line">                system.win = <span class="string">"7"</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                system.win = <span class="string">"NT"</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">RegExp</span>[<span class="string">"$1"</span>] == <span class="string">"9x"</span>)&#123;</div><div class="line">            system.win = <span class="string">"ME"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            system.win = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (client.system.win)&#123;</div><div class="line">    <span class="keyword">if</span> (client.system.win == <span class="string">"XP"</span>) &#123;</div><div class="line">        <span class="comment">//说明是XP</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (client.system.win == <span class="string">"Vista"</span>)&#123;</div><div class="line">        <span class="comment">//说明是Vista</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="识别移动设备"><a href="#识别移动设备" class="headerlink" title="识别移动设备"></a>识别移动设备</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">……</div><div class="line"><span class="keyword">var</span> system = &#123;</div><div class="line">    win: <span class="literal">false</span>,</div><div class="line">    mac: <span class="literal">false</span>,</div><div class="line">    x11: <span class="literal">false</span>,</div><div class="line">    <span class="comment">//移动设备</span></div><div class="line">    iphone: <span class="literal">false</span>,</div><div class="line">    ipod: <span class="literal">false</span>,</div><div class="line">    ipad: <span class="literal">false</span>,</div><div class="line">    ios: <span class="literal">false</span>,</div><div class="line">    android: <span class="literal">false</span>,</div><div class="line">    nokiaN: <span class="literal">false</span>,</div><div class="line">    winMobile: <span class="literal">false</span></div><div class="line">&#125;;</div><div class="line">……</div><div class="line"></div><div class="line">system.iphone = ua.indexOf(<span class="string">"iPhone"</span>) &gt; <span class="number">-1</span>;</div><div class="line">system.ipod = ua.indexOf(<span class="string">"iPod"</span>) &gt; <span class="number">-1</span>;</div><div class="line">system.ipod = ua.indexOf(<span class="string">"iPad"</span>) &gt; <span class="number">-1</span>;</div><div class="line"></div><div class="line"><span class="comment">//检测iOS 版本</span></div><div class="line"><span class="keyword">if</span> (system.mac &amp;&amp; ua.indexOf(<span class="string">"Mobile"</span>) &gt; <span class="number">-1</span>)&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="regexp">/CPU (?:iPhone )?OS (\d+_\d+)/</span>.test(ua))&#123;</div><div class="line">        system.ios = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>.$<span class="number">1.</span>replace(<span class="string">"_"</span>, <span class="string">"."</span>));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        system.ios = <span class="number">2</span>; <span class="comment">//不能真正检测出来，所以只能猜测</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//检测Android 版本</span></div><div class="line"><span class="keyword">if</span> (<span class="regexp">/Android (\d+\.\d+)/</span>.test(ua))&#123;</div><div class="line">    system.android = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (client.engine.webkit)&#123;</div><div class="line">    <span class="keyword">if</span> (client.system. iOS)&#123;</div><div class="line">        <span class="comment">//iOS 手机的内容</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (client.system.android)&#123;</div><div class="line">        <span class="comment">//Android 手机的内容</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (client.system.nokiaN)&#123;</div><div class="line">        <span class="comment">//诺基亚手机的内容</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="识别游戏系统"><a href="#识别游戏系统" class="headerlink" title="识别游戏系统"></a>识别游戏系统</h2><p>Wii 中的浏览器实际上是定制版的Opera：<code>Opera/9.10 (Nintendo Wii;U; ; 1621; en)</code><br>PS3 中的浏览器：<code>Mozilla/5.0 (PLAYSTATION 3; 2.00)</code></p>
<p><code>system.wii = ua.indexOf(&quot;Wii&quot;) &gt; -1;</code><br><code>system.ps = /playstation/i.test(ua);</code></p>
<h1 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h1><p>用户代理检测是客户端检测的最后一个选择。只要可能，都应该优先采用能力检测和怪癖检测。<br>用户代理检测一般适用于下列情形。</p>
<ul>
<li>不能直接准确地使用能力检测或怪癖检测。例如，某些浏览器实现了为将来功能预留的存根(stub)函数。</li>
<li>同一款浏览器在不同平台下具备不同的能力。这时候，可能就有必要确定浏览器位于哪个平台下。</li>
<li>为了跟踪分析等目的需要知道确切的浏览器。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第九章-1]]></title>
      <url>http://codingme.xyz/2016/09/30/javascript-note-9-1/</url>
      <content type="html"><![CDATA[<h1 id="客户端检测"><a href="#客户端检测" class="headerlink" title="客户端检测"></a>客户端检测</h1><p>面对普遍存在的不一致性问题，开发人员要么采取迁就各方的“最小公分母”策略，<br>要么(也是更常见的)就得利用各种客户端检测方法，来突破或者规避种种局限性。<br>迄今为止，客户端检测仍然是Web 开发领域中一个饱受争议的话题。<br>在现实当中，浏览器之间的差异以及不同浏览器的“怪癖”(quirk)，多得简直不胜枚举。<br>因此，客户端检测除了是一种补救措施之外，更是一种行之有效的开发策略。</p>
<p>但不到万不得已，就不要使用客户端检测。<br>只要能找到更通用的方法，就应该优先采用更通用的方法。<br>一言以蔽之，先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案。</p>
<h1 id="能力检测"><a href="#能力检测" class="headerlink" title="能力检测"></a>能力检测</h1><p>(又称特性检测)。能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。<br>不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (object.propertyInQuestion)&#123;</div><div class="line">    <span class="comment">//使用object.propertyInQuestion</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举例来说，IE5.0 之前的版本不支持document.getElementById()这个DOM 方法。<br>尽管可以使用非标准的document.all 属性实现相同的目的，<br>但IE 的早期版本中确实不存在document.getElementById()。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElement</span>(<span class="params">id</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.getElementById)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.all)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.all[id];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No way to retrieve element!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>要理解能力检测，首先必须理解两个重要的概念。<br>第一个概念就是先检测达成目的的最常用的特性。先检测最常用的特性可以保证代码最优化，因为在多数情况下都可以避免测试多个条件。<br>第二个重要的概念就是必须测试实际要用到的特性。一个特性存在，不一定意味着另一个特性也存在。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWindowWidth</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.all)&#123; <span class="comment">//假设是IE</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.documentElement.clientWidth; <span class="comment">//错误的用法！！！</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.innerWidth;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>document.all 存在也不一定表示浏览器就是IE。</p>
<h2 id="更可靠的能力检测"><a href="#更可靠的能力检测" class="headerlink" title="更可靠的能力检测"></a>更可靠的能力检测</h2><p>利用类型转换来确定某个对象成员是否存在，但这样你还是不知道该成员是不是你想要的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不要这样做！这不是能力检测——只检测了是否存在相应的方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSortable</span>(<span class="params">object</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> !!object.sort;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数通过检测对象是否存在sort()方法，来确定对象是否支持排序。<br>问题是，任何包含sort属性的对象也会返回true。<br><code>var result = isSortable({ sort: true });</code><br>检测某个属性是否存在并不能确定对象是否支持排序。更好的方式是检测sort 是不是一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这样更好：检查sort 是不是函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSortable</span>(<span class="params">object</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object.sort == <span class="string">"function"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的typeof 操作符用于确定sort 的确是一个函数，因此可以调用它对数据进行排序。<br>在可能的情况下，要尽量使用typeof 进行能力检测。特别是，宿主对象没有义务让typeof 返回合理的值。</p>
<p>最令人发指的事儿就发生在IE 中。大多数浏览器在检测到document.createElement()存在时，都会返回true。<br>在IE8 及之前版本中，这个函数返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasCreateElement</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">document</span>.createElement == <span class="string">"function"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DOM对象是宿主对象，IE 及更早版本中的宿主对象是通过COM 而非JScript 实现的。<br>因此，document.createElement()函数确实是一个COM 对象，所以typeof 才会返回”object”。<br>IE9 纠正了这个问题，对所有DOM 方法都返回”function”。<br>关于typeof 的行为不标准，IE 中还可以举出例子来。ActiveX 对象(只有IE 支持)与其他对象的行<br>为差异很大。例如，不使用typeof 测试某个属性会导致错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在IE 中会导致错误</span></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHttp"</span>);</div><div class="line"><span class="keyword">if</span> (xhr.open)&#123; <span class="comment">//这里会发生错误</span></div><div class="line">    <span class="comment">//执行操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像这样直接把函数作为属性访问会导致JavaScript 错误。<br>使用typeof 操作符会更靠谱一点，但IE对typeof xhr.open 会返回”unknown”。<br>这就意味着，在浏览器环境下测试任何对象的某个特性是否存在，要使用下面这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作者：Peter Michaux</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHostMethod</span>(<span class="params">object, property</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> object[property];</div><div class="line">    <span class="keyword">return</span> t==<span class="string">'function'</span> ||</div><div class="line">    (!!(t==<span class="string">'object'</span> &amp;&amp; object[property])) ||</div><div class="line">    t==<span class="string">'unknown'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">result = isHostMethod(xhr, <span class="string">"open"</span>); <span class="comment">//true</span></div><div class="line">result = isHostMethod(xhr, <span class="string">"foo"</span>); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>目前使用isHostMethod()方法还是比较可靠的，因为它考虑到了浏览器的怪异行为。<br>不过也要注意，宿主对象没有义务保持目前的实现方式不变，也不一定会模仿已有宿主对象的行为。</p>
<p>所以，这个函数——以及其他类似函数，都不能百分之百地保证永远可靠。<br><strong>作为开发人员，必须对自己要使用某个功能的风险作出理性的估计。</strong></p>
<h2 id="能力检测，不是浏览器检测"><a href="#能力检测，不是浏览器检测" class="headerlink" title="能力检测，不是浏览器检测"></a>能力检测，不是浏览器检测</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误！还不够具体</span></div><div class="line"><span class="keyword">var</span> isFirefox = !!(navigator.vendor &amp;&amp; navigator.vendorSub);</div><div class="line"><span class="comment">//错误！假设过头了</span></div><div class="line"><span class="keyword">var</span> isIE = !!(<span class="built_in">document</span>.all &amp;&amp; <span class="built_in">document</span>.uniqueID);</div></pre></td></tr></table></figure>
<p>这两行代码代表了对能力检测的典型误用。<br>以前，确实可以通过检测navigator.vendor 和navigator.vendorSub 来确定Firefox 浏览器。<br>但是，Safari 也依葫芦画瓢地实现了相同的属性。<br>于是，这段代码就会导致人们作出错误的判断。<br>为检测IE，代码测试了document.all 和document.uniqueID。<br>这就相当于假设IE 将来的版本中仍然会继续存在这两个属性，同时还假设其他浏览器都不会实现这两个属性。<br>最后，这两个检测都使用了双逻辑非操作符来得到布尔值(比先存储后访问的效果更好)。<br>实际上，根据浏览器不同将能力组合起来是更可取的方式。<br>如果你知道自己的应用程序需要使用某些特定的浏览器特性，那么最好是一次性检测所有相关特性，而不要分别检测。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//确定浏览器是否支持Netscape 风格的插件</span></div><div class="line"><span class="keyword">var</span> hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);</div><div class="line"><span class="comment">//确定浏览器是否具有DOM1 级规定的能力</span></div><div class="line"><span class="keyword">var</span> hasDOM1 = !!(<span class="built_in">document</span>.getElementById &amp;&amp; <span class="built_in">document</span>.createElement &amp;&amp;</div><div class="line"><span class="built_in">document</span>.getElementsByTagName);</div></pre></td></tr></table></figure>
<p>一个检测浏览器是否支持Netscapte 风格的插件；另一个检测浏览器是否具备DOM1 级所规定的能力。<br>得到的布尔值可以在以后继续使用，从而节省重新检测能力的时间。<br><strong>在实际开发中，应该将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。</strong></p>
<h1 id="怪癖检测"><a href="#怪癖检测" class="headerlink" title="怪癖检测"></a>怪癖检测</h1><p>怪癖检测(quirks detection)的目标是识别浏览器的特殊行为。<br>怪癖检测是想要知道浏览器存在什么缺陷(“怪癖”也就是bug)。<br>例如，IE8 及更早版本中存在一个bug，<br>即如果某个实例属性与[[Enumerable]]标记为false 的某个原型属性同名，<br>那么该实例属性将不会出现在fon-in 循环当中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hasDontEnumQuirk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o = &#123; toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o)&#123;</div><div class="line">        <span class="keyword">if</span> (prop == <span class="string">"toString"</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>通过一个匿名函数来测试该“怪癖”，函数中创建了一个带有toString()方法的对象。<br>在正确的ECMAScript 实现中，toString 应该在for-in 循环中作为属性返回。</p>
<h1 id="用户代理检测"><a href="#用户代理检测" class="headerlink" title="用户代理检测"></a>用户代理检测</h1><p>争议最大的一种客户端检测技术。<br>用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。<br>用户代理字符串是作为响应首部发送的，而且该字符串可以通过JavaScript 的navigator.userAgent 属性访问。<br>在服务器端，通过检测用户代理字符串来确定用户使用的浏览器是一种常用而且广为接受的做法。<br>而在客户端，用户代理检测一般被当作一种万不得已才用的做法，其优先级排在能力检测和(或)怪癖检测之后。</p>
<p>争议：电子欺骗(spoofing)。所谓电子欺骗，就是指浏览器通过在自己的用户代理字符串加入一些错误或误导性信息，来达到欺骗服务器的目的。</p>
<h2 id="用户代理字符串的历史"><a href="#用户代理字符串的历史" class="headerlink" title="用户代理字符串的历史"></a>用户代理字符串的历史</h2><p>HTTP 规范(包括1.0 和1.1 版)明确规定，浏览器应该发送简短的用户代理字符串，指明浏览器的名称和版本号。<br>描述：“产品标识符常用于通信应用程序标识自身，由软件名和版本组成。<br>使用产品标识符的大多数领域也允许列出作为应用程序主要部分的子产品，由空格分隔。<br>按照惯例，产品要按照相应的重要程度依次列出，以便标识应用程序。”</p>
<ol>
<li><strong>早期的浏览器</strong><br> 美国NCSA的世界上第一款Web 浏览器Mosaic。它的用户代理字符串:<code>Mosaic/0.9</code><br> 后面网景公司开发的Netscapse Navigator2 具有的用户代理字符串：<code>Mozilla/版本号 [语言] (平台; 加密类型)</code><br> Netscape 在坚持将产品名和版本号作为用户代理字符串开头的基础上，又在后面依次添加了<br> 语言、<br> 平台、<br> 加密类型,可能的值有U(128 位加密)、I(40 位加密)和N(未加密)。<br> 典型的Netscape Navigator 2 的用户代理字符串：<code>Mozilla/2.02 [fr] (WinNT; I)</code><br> 浏览器是Netscape Navigator 2.02，为法语国家编译，运行在Windows NT 平台下，加密类型为40 位。</li>
<li><strong>Netscape Navigator 3 和Internet Explorer 3</strong><br> 1996 年，Netscape Navigator 3 发布，格式变成<code>Mozilla/版本号 (平台; 加密类型 [; 操作系统或CPU 说明])</code><br> Windows 系统下的用户代理字符串：<code>Mozilla/3.0 (Win95; U)</code><br> 之后微软发布 IE3,用户代理字符串决定兼容 Netscape 形式:<code>Mozilla/2.0 (compatible; MSIE 版本号; 操作系统)</code><br> 如<code>Mozilla/2.0 (compatible; MSIE 3.02; Windows 95)</code><br> 于是 IE 成功将自己标识成 Mozilla,伪装成 Netscape Navigator。因为违反了浏览器标识惯例招致许多批评。<br> 另外一个有趣的地方是标识符Mozilla 2.0(而不是3.0)。毕竟，当时的主流版本是3.0，改成3.0 应该对微软更有利才对。<br> 但真正的谜底到现在还没有揭开——但很可能只是人为疏忽所致。</li>
<li><strong>Netscape Communicator 4 和IE4～IE8</strong><br> 1997 年8 月，Netscapte Communicator 4 发布。<code>Mozilla/4.0 (Win98; I)</code><br> 发布补丁时，子版本号也会相应提高<code>Mozilla/4.79 (Win98; I)</code><br> 微软在发布Internet Explorer 4 时，顺便将用户代理字符串修改<code>Mozilla/4.0 (compatible; MSIE 4.0; Windows 98)</code><br> 两者的一致性仅限于这一个版本。<br> 此后，IE 的版本一直到7<code>Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)</code><br> 而IE8 的用户代理字符串中添加了呈现[Render]引擎(Trident)的版本号：<code>Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)</code><br> 这个新增的Trident 记号是为了让开发人员知道IE8 是不是在兼容模式下运行。<br> 如果是，则MSIE 的版本号会变成7，但Trident 及版本号还会留在用户代码字符串中。<br> IE9 对字符串格式做了一点调整。Mozilla 版本号增加到了5.0，而Trident 的版本号也升到了5.0。<br> <code>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)</code><br> 如果IE9 运行在兼容模式下，字符串中的Mozilla 版本号和MSIE 版本号会恢复旧的值，但Trident的版本号仍然是5.0。<br> <code>Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/5.0)</code></li>
<li><strong>Gecko</strong><br> Gecko 是Firefox 的呈现[Render]引擎。<br> 当初的是作为通用Mozilla 浏览器的一部分开发的。<br> 第一个采用Gecko 引擎的浏览器是Netscape 6。<br> Netscape 6改的用户代理字符串，加星号的非必需。<pre><code>Mozilla/Mozilla 版本号 (平台; 加密类型; 操作系统或CPU; 语言; *预先发行版本)
Gecko/*Gecko 版本号 *应用程序或产品/ *应用程序或产品版本号
</code></pre> 例子<pre><code>Windows XP 下的Netscape 6.21：
Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:0.9.4) Gecko/20011128 Netscape6/6.2.1
Linux 下的SeaMonkey 1.1a：
Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1b2) Gecko/20060823 SeaMonkey/1.1a
Windows XP 下的Firefox 2.0.0.11：
Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11
Mac OS X 下的Camino 1.5.1：
Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en; rv:1.8.1.6) Gecko/20070809 Camino/1.5.1
</code></pre> 之后的 Mozilla Firefox 4 发布，用户代理字符串变成：<code>Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox 4.0.1</code></li>
<li><strong>WebKit</strong><br> 2003 年，Apple 公司宣布要发布自己的Web 浏览器，名字定为Safari。<br> Safari 的呈现[Render]引擎叫WebKit，是Linux 平台中 Konqueror 浏览器的呈现[Render]引擎KHTML 的一个分支。<br> 之后WebKit 独立出来成为了一个开源项目，专注于呈现[Render]引擎的开发。<br> 这款新浏览器和呈现引擎的开发人员也遇到了与Internet Explorer 3.0 类似的问题：<br> 如何确保这款浏览器不被流行的站点拒之门外？<br> 向用户代理字符串中放入足够多的信息，以便站点能够信任它与其他流行的浏览器是兼容的。<br> 于是 WebKit 的用户代理字符串就变成了:<pre><code>Mozilla/5.0 (平台; 加密类型; 操作系统或CPU; 语言) AppleWebKit/AppleWebKit 版本号
(KHTML, like Gecko) Safari/Safari 版本号
</code></pre> 实例:<pre><code>Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/124 (KHTML, like Gecko)
Safari/125.1
</code></pre> 出于兼容性的考虑，有关人员很快就决定了将Safari 标识为Mozilla。<br> 至今，基于WebKit 的所有浏览器都将自己标识为Mozilla 5.0，与基于Gecko 的浏览器完全一样。<br> Safari 3.0 发布时<pre><code>Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/522.15.5 (KHTML, like
Gecko) Version/3.0.3 Safari/522.15.5
</code></pre></li>
<li><strong>Konqueror</strong><br> 与KDE Linux 集成的Konqueror，是一款基于KHTML 开源呈现引擎的浏览器。<br> <code>Mozilla/5.0 (compatible; Konqueror/ 版本号; 操作系统或CPU )</code><br> 到了3.2版本，将自己标识为KHTML<br> <code>Mozilla/5.0 (compatible; Konqueror/ 版本号; 操作系统或CPU) KHTML/ KHTML 版本号 (like Gecko)</code><br> 例子：<br> <code>Mozilla/5.0 (compatible; Konqueror/3.5; SunOS) KHTML/3.5.0 (like Gecko)</code><br> 其中 Konqueror 与 KHTML 版本号比较一致，即使有差别也比较小(不像 Safari )</li>
<li><strong>Chrome</strong><br> 谷歌公司的Chrome 浏览器以WebKit 作为呈现[Render]引擎，但使用了不同的JavaScript 引擎。<br> Chrome 0.2的用户代理字符串:<pre><code>Mozilla/5.0 ( 平台; 加密类型; 操作系统或CPU; 语言) AppleWebKit/AppleWebKit 版本号 (KHTML,
like Gecko) Chrome/ Chrome 版本号 Safari/ Safari 版本
</code></pre> Chrome 7的完整用户代理字符串：<pre><code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7 (KHTML,
like Gecko) Chrome/7.0.517.44 Safari/534.7
</code></pre> 现在windows10 x64 系统下的 Chrome 53 x64的完整用户代理字符串：<br> <code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36</code></li>
<li>opera<br> 已经完全没有市场份额，GG。</li>
<li><p>iOS 和Android<br> 移动操作系统iOS 和 Android 默认的浏览器都基于WebKit，而且都像它们的桌面版一样，共享相同的基本用户代理字符串格式。<br> iOS:</p>
<pre><code>Mozilla/5.0 (平台; 加密类型; 操作系统或CPU like Mac OS X; 语言)
AppleWebKit/AppleWebKit 版本号 (KHTML, like Gecko) Version/浏览器版本号
Mobile/移动版本号 Safari/Safari 版本号
</code></pre><p> 例子：</p>
<pre><code>Mozilla/5.0 (iPhone; U; CPU iPhone OS 3_0 like Mac OS X; en-us)
AppleWebKit/528.18 (KHTML, like Gecko) Version/4.0 Mobile/7A341 Safari/528.16
</code></pre><p> Android:</p>
<pre><code>Mozilla/5.0 (Linux; U; Android 2.2; en-us; Nexus One Build/FRF91)
AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1
</code></pre></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第八章-2]]></title>
      <url>http://codingme.xyz/2016/09/30/javascript-note-8-2/</url>
      <content type="html"><![CDATA[<h1 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h1><p>location 是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。<br>location 对象是很特别的一个对象，因为它既是window 对象的属性，也是document 对象的属性。</p>
<p>window.location 和document.location 引用的是同一个对象。<br>location 对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL 解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。</p>
<pre><code>hash &quot;#contents&quot; 返回URL中的hash(#号后跟零或多个字符)，如果URL中不包含散列，则返回空字符串
host &quot;www.wrox.com:80&quot; 返回服务器名称和端口号(如果有)
hostname &quot;www.wrox.com&quot; 返回不带端口号的服务器名称
href &quot;http:/www.wrox.com&quot; 返回当前加载页面的完整URL。而location对象的
toString()方法也返回这个值
pathname &quot;/WileyCDA/&quot; 返回URL中的目录和(或)文件名
port &quot;8080&quot; 返回URL中指定的端口号。如果URL中不包含端口号，则
这个属性返回空字符串
protocol &quot;http:&quot; 返回页面使用的协议。通常是http:或https:
search &quot;?q=JavaScript&quot; 返回URL的查询字符串。这个字符串以问号开头
</code></pre><a id="more"></a>
<h2 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h2><p>尽管location.search 返回从问号到URL 末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。<br>为此，可以创建一个函数，用以解析查询字符串，然后返回包含所有参数的一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//取得查询字符串并去掉开头的问号</span></div><div class="line">    <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</div><div class="line">    <span class="comment">//保存数据的对象</span></div><div class="line">    args = &#123;&#125;,</div><div class="line">    <span class="comment">//取得每一项</span></div><div class="line">    items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</div><div class="line">    item = <span class="literal">null</span>,</div><div class="line">    name = <span class="literal">null</span>,</div><div class="line">    value = <span class="literal">null</span>,</div><div class="line">    <span class="comment">//在for 循环中使用</span></div><div class="line">    i = <span class="number">0</span>,</div><div class="line">    len = items.length;</div><div class="line">    <span class="comment">//逐个将每一项添加到args 对象中</span></div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">        item = items[i].split(<span class="string">"="</span>);</div><div class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</div><div class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</div><div class="line">        <span class="keyword">if</span> (name.length) &#123;</div><div class="line">            args[name] = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> args;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//假设查询字符串是?q=JavaScript&amp;num=10</span></div><div class="line"><span class="keyword">var</span> args = getQueryStringArgs();</div><div class="line">alert(args[<span class="string">"q"</span>]); <span class="comment">//"JavaScript"</span></div><div class="line">alert(args[<span class="string">"num"</span>]); <span class="comment">//"10"</span></div></pre></td></tr></table></figure>
<h2 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h2><p>使用location 对象可以通过很多方式来改变浏览器的位置。<br>最常用的方式，就是使用assign()方法并为其传递一个URL。<br><code>location.assign(&quot;http://www.wrox.com&quot;);</code><br>这样就可以立即打开新URL 并在浏览器的历史记录中生成一条记录。<br>如果是将location.href或window.location 设置为一个URL 值，也会以该值调用assign()方法。<br>最常用的是设置location.href 属性。<br>修改location 对象的其他属性也可以改变当前加载的页面。<br>每次修改location 的属性(hash 除外)，页面都会以新URL 重新加载。</p>
<p>当通过上述任何一种方式修改URL 之后，浏览器的历史记录中就会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。<br>要禁用这种行为，可以使用replace()方法。<br>只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。<br>在调用replace()方法之后，用户不能回到前一个页面。</p>
<p>与位置有关的最后一个方法是reload()，作用是重新加载当前显示的页面。<br>如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。<br>也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。<br>如果要强制从服务器重新加载，则需要为该方法传递参数true。</p>
<h2 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h2><p>最早由Netscape Navigator 2.0 引入的navigator 对象，现在已经成为识别客户端浏览器的事实标准。<br>其他浏览器也通过其他方式提供了相同或相似的信息(例如，IE 中的window.clientInformation和Opera 中的window.opera)，<br>但navigator 对象却是所有支持JavaScript 的浏览器所共有的。<br>每个浏览器中的navigator 对象也都有一套自己的属性。不同浏览器版本有不同支持。</p>
<h3 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h3><p>对于非IE 浏览器，可以使用plugins 数组来达到这个目的。<br>数组每一项都包含：</p>
<ul>
<li>name：插件的名字。</li>
<li>description：插件的描述。</li>
<li>filename：插件的文件名。</li>
<li>length：插件所处理的MIME 类型数量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//检测插件(在IE 中无效)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    name = name.toLowerCase();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; navigator.plugins.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span> (navigator. plugins [i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//检测Flash</span></div><div class="line">alert(hasPlugin(<span class="string">"Flash"</span>));</div><div class="line"><span class="comment">//检测QuickTime</span></div><div class="line">alert(hasPlugin(<span class="string">"QuickTime"</span>));</div></pre></td></tr></table></figure>
<p>每个插件对象本身也是一个MimeType 对象的数组，这些对象可以通过方括号语法来访问。<br>每个MimeType 对象有4 个属性：包含MIME 类型描述的description、回指插件对象的enabledPlugin、<br>表示与MIME 类型对应的文件扩展名的字符串suffixes(以逗号分隔)和表示完整MIME 类型字符串的type。</p>
<p>检测IE 中的插件比较麻烦，因为IE 不支持Netscape 式的插件。<br>在IE 中检测插件的唯一方式就是使用专有的ActiveXObject 类型，并尝试创建一个特定插件的实例。<br>IE 是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。<br>例如，Flash 的标识符是ShockwaveFlash.ShockwaveFlash。<br>知道唯一标识符之后，就可以编写函数来检测IE 中是否安装相应插件了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//检测IE 中的插件</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">new</span> ActiveXObject(name);</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//检测Flash</span></div><div class="line">alert(hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>));</div><div class="line"><span class="comment">//检测QuickTime</span></div><div class="line">alert(hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>));</div></pre></td></tr></table></figure>
<p>鉴于检测这两种插件的方法差别太大，因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//检测所有浏览器中的Flash</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFlash</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result = hasPlugin(<span class="string">"Flash"</span>);</div><div class="line">    <span class="keyword">if</span> (!result)&#123;</div><div class="line">        result = hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">//检测所有浏览器中的QuickTime</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasQuickTime</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result = hasPlugin(<span class="string">"QuickTime"</span>);</div><div class="line">    <span class="keyword">if</span> (!result)&#123;</div><div class="line">        result = hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">//检测Flash</span></div><div class="line">alert(hasFlash());</div><div class="line"><span class="comment">//检测QuickTime</span></div><div class="line">alert(hasQuickTime());</div></pre></td></tr></table></figure>
<p>尝试使用不针对IE 的插件检测方法。<br>如果返回了false(在IE 中会这样)，那么再使用针对IE 的插件检测方法。</p>
<p>plugins 集合有一个名叫refresh()的方法，用于刷新plugins 以反映最新安装的插件。<br>这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果将这个值设置为true，则会重新加载包含插件的所有页面；<br>否则，只更新plugins集合，不重新加载页面。</p>
<h3 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h3><p>navigator 对象新增了registerContentHandler()和registerProtocolHandler()方法(这两个方法是在HTML5 中定义的)。<br>这两个方法可以让一个站点指明它可以处理特定类型的信息。<br>随着RSS 阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。</p>
<p>registerContentHandler()方法接收三个参数：要处理的MIME 类型、可以处理该MIME类型的页面的URL 以及应用程序的名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">navigator.registerContentHandler(<span class="string">"application/rss+xml"</span>,</div><div class="line"><span class="string">"http://www.somereader.com?feed=%s"</span>, <span class="string">"Some Reader"</span>);</div></pre></td></tr></table></figure>
<p>第一个参数是RSS 源的MIME 类型。第二个参数是应该接收RSS 源URL 的URL，其中的%s 表示RSS 源URL，由浏览器自动插入。<br>当下一次请求RSS 源时，浏览器就会打开指定的URL，而相应的Web 应用程序将以适当方式来处理该请求。</p>
<p>registerProtocolHandler()方法，它也接收三个参数：要处理的协议(例如，mailto 或ftp)、处理该协议的页面的URL 和应用程序的名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">navigator.registerProtocolHandler(<span class="string">"mailto"</span>,</div><div class="line"><span class="string">"http://www.somemailclient.com?cmd=%s"</span>, <span class="string">"Some Mail Client"</span>);</div></pre></td></tr></table></figure>
<p>这个例子注册了一个mailto 协议的处理程序，该程序指向一个基于Web 的电子邮件客户端。同样，<br>第二个参数仍然是处理相应请求的URL，而%s 则表示原始的请求。</p>
<h1 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h1><p>JavaScript 中有几个对象在编程中用处不大，而screen 对象就是其中之一。<br>screen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。<br>这些信息经常集中出现在测定客户端能力的站点跟踪工具中，但通常不会用于影响功能。<br>有时候也可能会用到其中的信息来调整浏览器窗口大小，使其占据屏幕的可用空间。<br>例如：<code>window.resizeTo(screen.availWidth, screen.availHeight);</code><br>许多浏览器都会禁用调整浏览器窗口大小的能力，因此上面这行代码不一定在所有环境下都有效。</p>
<p>涉及移动设备的屏幕大小时，情况有点不一样。<br>运行iOS 的设备始终会像是把设备竖着拿在手里一样，因此返回的值是768×1024。<br>而Android 设备则会相应调用screen.width 和screen.height 的值。</p>
<h1 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h1><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。<br>因为history 是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history 对象与特定的window 对象关联。<br>出于安全方面的考虑，开发人员无法得知用户浏览过的URL。<br>不过，借由用户访问过的页面列表，同样可以在不知道实际URL 的情况下实现后退和前进。<br>使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//后退一页</span></div><div class="line">history.go(<span class="number">-1</span>);</div><div class="line"><span class="comment">//前进一页</span></div><div class="line">history.go(<span class="number">1</span>);</div><div class="line"><span class="comment">//前进两页</span></div><div class="line">history.go(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//跳转到最近的wrox.com 页面</span></div><div class="line">history.go(<span class="string">"wrox.com"</span>);</div><div class="line"><span class="comment">//跳转到最近的nczonline.net 页面</span></div><div class="line">history.go(<span class="string">"nczonline.net"</span>);</div></pre></td></tr></table></figure>
<p>还可以使用两个简写方法back()和forward()来代替go()。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//后退一页</span></div><div class="line">history.back();</div><div class="line"><span class="comment">//前进一页</span></div><div class="line">history.forward();</div></pre></td></tr></table></figure>
<p>history 对象还有一个length 属性，保存着历史记录的数量。<br>对于加载到窗口、标签页或框架中的第一个页面而言，history.length 等于0。<br>(所以类似百度这种网站，弹出“是否设为主页”的这种判断是不是利用length 等于0?)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (history.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="comment">//这应该是用户打开窗口后的第一个页面</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当页面的URL 改变时，就会生成一条历史记录。<br>在IE8 及更高版本、Opera、Firefox、Safari 3 及更高版本以及Chrome 中，<br>这里所说的改变包括URL 中hash 的变化(因此，设置location.hash 会在这些浏览器中生成一条新的历史记录)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第八章-1]]></title>
      <url>http://codingme.xyz/2016/09/29/javascript-note-8-1/</url>
      <content type="html"><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>ECMAScript 是 JavaScript 的核心，但如果要在 Web 中使用 JavaScript ，那么 BOM(浏览器对象模型)则无疑才是真正的核心。</p>
<h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><p>它表示浏览器的一个实例。<br>它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。<br>这意味着在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象，因此有权访问parseInt() 等方法。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>由于 window 对象同时扮演着 ECMAScript中 Global 对象的角色，因此所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line">alert(<span class="built_in">window</span>.age); <span class="comment">//29</span></div><div class="line">sayAge(); <span class="comment">//29</span></div><div class="line"><span class="built_in">window</span>.sayAge(); <span class="comment">//29</span></div></pre></td></tr></table></figure>
<p>由于 sayAge() 存在于全局作用域中，因此 this.age 被映射到 window.age 。<br>定义全局变量与在 window 对象上直接定义属性还是有一点差别：全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</div><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="comment">//在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 false</span></div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.age;</div><div class="line"><span class="comment">//在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 true</span></div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.color; <span class="comment">//returns true</span></div><div class="line">alert(<span class="built_in">window</span>.age); <span class="comment">//29</span></div><div class="line">alert(<span class="built_in">window</span>.color); <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>使用 var 语句添加的 window (全局)属性有一个名为 [[Configurable]] 的特性，这个特性的值被设置为 false ，因此这样定义的属性不可以通过 delete 操作符删除。</p>
<p>尝试访问未声明的变量会抛出错误，但是通过查询 window 对象，可以知道某个可能未声明的变量是否存在。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里会抛出错误，因为 oldValue 未定义</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue;</div><div class="line"><span class="comment">//这里不会抛出错误，因为这是一次属性查询</span></div><div class="line"><span class="comment">//newValue 的值是 undefined</span></div><div class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue;</div></pre></td></tr></table></figure>
<p>很多全局 JavaScript 对象(如 location 和 navigator )实际上都是 window对象的属性。</p>
<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面中包含框架，则每个框架都拥有自己的 window 对象，并且保存在 frames 集合中。<br>在 frames集合中，可以通过数值索引(从 0 开始，从左至右，从上到下)或者框架名称来访问相应的 window 对象。<br>每个 window 对象都有一个 name 属性，其中包含框架的名称。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"160,*"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"yetanotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上代码创建了一个框架集，其中一个框架居上，两个框架居下。<br>对这个例子而言，可以通过window.frames[0] 或者 window.frames[“topFrame”] 来引用上方的框架。<br>不过，恐怕你最好使用 top 而非 window 来引用这些框架(例如，通过 top.frames[0] )。<br>top 对象始终指向最高(最外)层的框架，也就是浏览器窗口。</p>
<p>访问框架的方式例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.frames[<span class="number">0</span>];</div><div class="line"><span class="built_in">window</span>.frames[<span class="string">"topFrame"</span>];</div><div class="line">top.frames[<span class="number">0</span>];</div><div class="line">top.frames[<span class="string">"topFrame"</span>];</div><div class="line">frames[<span class="number">0</span>];</div><div class="line">frames[<span class="string">"topFrame"</span>];</div></pre></td></tr></table></figure>
<p>与 top 相对的另一个 window 对象是 parent 。顾名思义， parent (父)对象始终指向当前框架的直接上层框架。<br>在某些情况下， parent 有可能等于 top ；但在没有框架的情况下， parent 一定等于 top (此时它们都等于 window )。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"100,*"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframeset.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"red.htm"</span> <span class="attr">name</span>=<span class="string">"redFrame"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"blue.htm"</span> <span class="attr">name</span>=<span class="string">"blueFrame"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个框架集中的一个框架包含了另一个框架集。浏览器在加载完第一个框架集以后，会继续将第二个框架集加载到 rightFrame 中。<br>如果代码位于 redFrame (或 blueFrame )中，那么 parent 对象指向的就是 rightFrame 。<br>如果代码位于 topFrame 中，则 parent 指向的是 top ，因为 topFrame 的直接上层框架就是最外层框架。</p>
<p>除非<strong>最高层窗口</strong>是通过 window.open() 打开的，否则<strong>其 window 对象的 name 属性</strong>不会包含任何值。</p>
<p>self 对象它始终指向 window ；实际上， self 和 window 对象可以互换使用。<br>引入 self 对象的目的只是为了与 top 和 parent 对象对应起来，因此它不格外包含其他值。</p>
<p>所有这些对象都是 window 对象的属性，可以通过 window.parent 、 window.top 等形式来访问。<br>同时，这也意味着可以将不同层次的 window 对象连缀起来，例如 window.parent.parent.frames[0] 。</p>
<p>在使用框架的情况下，浏览器中会存在多个Global 对象。在每个框架中定义的全局变量会自动成为框架中window 对象的属性。<br>由于每个window 对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。<br>例如，top.Object 并不等于top.frames[0].Object。这个问题会影响到对跨框架传递的对象使用 instanceof 操作符。</p>
<h3 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h3><p>IE、Safari、Opera 和Chrome 都提供了screenLeft 和screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。<br>用来确定和修改window 对象位置的属性和方法有很多。<br>Firefox 则在 screenX 和screenY 属性中提供相同的窗口位置信息，Safari 和 Chrome 也同时支持这两个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</div><div class="line"><span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</div><div class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</div><div class="line"><span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</div></pre></td></tr></table></figure>
<p>这个例子运用二元操作符首先确定screenLeft 和screenTop 属性是否存在，<br>如果是(在IE、Safari、Opera 和Chrome 中)，则取得这两个属性的值。<br>如果不存在(在Firefox 中)，则取得screenX和 screenY 的值。<br>在使用这些值的过程中，还必须注意一些小问题。</p>
<p>在IE、Opera 中，screenLeft 和screenTop 中保存的是从屏幕左边和上边到由window 对象表示的页面可见区域的距离。<br>如果window 对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y 轴坐标为0，那么screenTop 的值就是<strong>位于页面可见区域上方的浏览器工具栏的像素高度</strong>。<br>在Chrome、Firefox 和Safari 中，screenY 或screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y 轴坐标为0 时返回0。</p>
<p>Firefox、Safari 和Chrome 始终返回页面中每个框架的top.screenX 和top.screenY 值。<br>即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用screenX 和screenY 每次也都会返回相同的值。<br>而IE 和Opera 则会给出框架相对于屏幕边界的精确坐标值。</p>
<p>最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值。然而，使用moveTo()和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将窗口移动到屏幕左上角</span></div><div class="line"><span class="built_in">window</span>.moveTo(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line"><span class="comment">//将窗向下移动100 像素</span></div><div class="line"><span class="built_in">window</span>.moveBy(<span class="number">0</span>,<span class="number">100</span>);</div><div class="line"><span class="comment">//将窗口移动到(200,300)</span></div><div class="line"><span class="built_in">window</span>.moveTo(<span class="number">200</span>,<span class="number">300</span>);</div><div class="line"><span class="comment">//将窗口向左移动50 像素</span></div><div class="line"><span class="built_in">window</span>.moveBy(<span class="number">-50</span>,<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>需要注意的是，这两个方法可能会被浏览器禁用；而且，在Opera 和IE 7(及更高版本)中默认就是禁用的。<br>另外，这两个方法都不适用于框架，只能对最外层的window 对象使用。</p>
<h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>IE9+、Firefox、Safari、Opera 和Chrome 均提供了4 个属性：innerWidth、innerHeight、outerWidth 和outerHeight。<br>在IE9+、Safari 和Firefox中，outerWidth 和outerHeight 返回浏览器窗口本身的尺寸(无论是从最外层的window 对象还是从某个框架访问)。<br>而innerWidth 和innerHeight则表示该容器中页面视图区的大小(减去边框宽度)。<br>在Chrome 中，outerWidth、outerHeight 与innerWidth、innerHeight 返回相同的值，即视口(viewport)大小而非浏览器窗口大小。</p>
<p>在IE、Firefox、Safari、Opera 和Chrome 中，document.documentElement.clientWidth 和document.documentElement.clientHeight 中保存了页面视口的信息。<br>在IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过document.body.clientWidth 和document.body.clientHeight 取得相同信息。<br>而对于混杂模式下的Chrome，则无论通过document.documentElement还是document.body 中的clientWidth 和clientHeight 属性，都可以取得视口的大小。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</div><div class="line">pageHeight = <span class="built_in">window</span>.innerHeight;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123;</div><div class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</div><div class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth;</div><div class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先将window.innerWidth 和window.innerHeight 的值分别赋给了pageWidth 和pageHeight。<br>然后检查pageWidth 中保存的是不是一个数值；如果不是，则通过检查document.compatMode 来确定页面是否处于标准模式。<br>如果是，则分别使用document.documentElement.clientWidth 和document.documentElement.clientHeight 的值。<br>否则，就使用document.body.clientWidth 和document.body.clientHeight 的值。</p>
<p>对于移动设备，window.innerWidth 和window.innerHeight 保存着可见视口，也就是屏幕上可见页面区域的大小。<br>在其他移动浏览器中，document.documentElement 度量的是布局视口，即渲染后页面的实际大小(与可见视口不同，可见视口只是整个页面中的一小部分)。</p>
<p>使用resizeTo()和resizeBy()方法可以调整浏览器窗口的大小。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调整到100×100</span></div><div class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line"><span class="comment">//调整到200×150</span></div><div class="line"><span class="built_in">window</span>.resizeBy(<span class="number">100</span>, <span class="number">50</span>);</div><div class="line"><span class="comment">//调整到 300×300</span></div><div class="line"><span class="built_in">window</span>.resizeTo(<span class="number">300</span>, <span class="number">300</span>);</div></pre></td></tr></table></figure>
<p>这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用；在Opera和 IE7(及更高版本)中默认就是禁用的。<br>另外，这两个方法同样不适用于框架，而只能对最外层的window 对象使用。</p>
<h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><p>window.open()方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。<br>接收4 个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。<br>通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//等同于&lt;a href="http://www.wrox.com" target="topFrame"&gt;&lt;/a&gt;</span></div><div class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>, <span class="string">"topFrame"</span>);</div></pre></td></tr></table></figure>
<p>如果有一个名叫”topFrame”的窗口或者框架，就会在该窗口或框架加载这个URL；否则，就会创建一个新窗口并将其命名为”topFrame”。<br>此外，第二个参数也可以是下列任何一个特殊的窗口名称：_self、_parent、_top 或_blank。</p>
<h4 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h4><p>如果给window.open()传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。<br>如果没有传入第三个参数，那么就会打开一个带有全部默认设置(工具栏、地址栏和状态栏等)的新浏览器窗口(或者打开一个新标签页——根据浏览器设置)。<br>在不打开新窗口的情况下，会忽略第三个参数。<br>第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。</p>
<pre><code>fullscreen yes或no 表示浏览器窗口是否最大化。仅限IE
height 数值 表示新窗口的高度。不能小于100
left 数值 表示新窗口的左坐标。不能是负值
location yes或no 表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。
如果设置为no，地址栏可能会隐藏，也可能会被禁用(取决于浏览器)
menubar yes或no 表示是否在浏览器窗口中显示菜单栏。默认值为no
resizable yes或no 表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no
scrollbars yes或no 表示如果内容在视口中显示不下，是否允许滚动。默认值为no
status yes或no 表示是否在浏览器窗口中显示状态栏。默认值为no
toolbar yes或no 表示是否在浏览器窗口中显示工具栏。默认值为no
top 数值 表示新窗口的上坐标。不能是负值
width 数值 表示新窗口的宽度。不能小于100
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"wroxWindow"</span>,</div><div class="line"><span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</div></pre></td></tr></table></figure>
<p>这行代码会打开一个新的可以调整大小的窗口，窗口初始大小为400×400 像素，并且距屏幕上沿和左边各10 像素。</p>
<p><strong>window.open()方法会返回一个指向新窗口的引用</strong>。引用的对象与其他window 对象大致相似，但我们可以对其进行更多控制。<br>有些浏览器在默认情况下可能不允许我们针对主浏览器窗口调整大小或移动位置，但却允许我们针对通过window.open()创建的窗口调整大小或移动位置。<br>通过这个返回的对象，可以像操作其他窗口一样操作新打开的窗口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"wroxWindow"</span>,</div><div class="line"><span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</div><div class="line"><span class="comment">//调整大小</span></div><div class="line">wroxWin.resizeTo(<span class="number">500</span>,<span class="number">500</span>);</div><div class="line"><span class="comment">//移动位置</span></div><div class="line">wroxWin.moveTo(<span class="number">100</span>,<span class="number">100</span>);</div><div class="line"></div><div class="line">wroxWin.close();</div></pre></td></tr></table></figure>
<p>但是，这个方法仅适用于通过window.open()打开的弹出窗口。对于浏览器的主窗口，如果没有得到用户的允许是不能关闭它的。<br>弹出窗口倒是可以调用top.close()在不经用户允许的情况下关闭自己。<br>弹出窗口关闭之后，窗口的引用仍然还在，但除了检测其closed 属性之外，已经没有其他用处了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wroxWin.close();</div><div class="line">alert(wroxWin.closed); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>新创建的window 对象有一个opener 属性，其中保存着打开它的原始窗口对象。<br>这个属性只在弹出窗口中的最外层window 对象(top)中有定义，而且指向调用window.open()的窗口或框架。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"wroxWindow"</span>,</div><div class="line"><span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</div><div class="line">alert(wroxWin.opener == <span class="built_in">window</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。<br>窗口并不跟踪记录它们打开的弹出窗口，因此我们只能在必要的时候自己来手动实现跟踪。</p>
<p>有些浏览器(如IE8 和Chrome)会在独立的进程中运行每个标签页。<br>当一个标签页打开另一个标签页时，如果两个window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。<br>在Chrome中，将新创建的标签页的opener 属性设置为null，即表示在单独的进程中运行新标签页。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com/"</span>,<span class="string">"wroxWindow"</span>,</div><div class="line"><span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</div><div class="line">wroxWin.opener = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>将opener 属性设置为null 就是告诉浏览器新创建的标签页不需要与打开它的标签页通信，因此可以在独立的进程中运行。<br>标签页之间的联系一旦切断，将没有办法恢复。</p>
<h4 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h4><p>曾经有一段时间，广告商在网上使用弹出窗口达到了肆无忌惮的程度。<br>浏览器为此施加了许多限制。<br>比如IE6 对弹出窗口施加了多方面的安全限制，包括不允许在屏幕之外创建弹出窗口、不允许将弹出窗口移动到屏幕以外、不允许关闭状态栏等。<br>IE7 则增加了更多的安全限制，如不允许关闭地址栏、默认情况下不允许移动弹出窗口或调整其大小。<br>等等等等。</p>
<p>此外，有的浏览器只根据用户操作来创建弹出窗口。这样一来，在页面尚未加载完成时调用window.open()的语句根本不会执行。<br>换句话说，只能通过单击或者击键来打开弹出窗口。(哦！所以现在带有广告的网盘之类的网站都在网页上覆盖上一层可点击的区域，一旦点击了就会弹出窗口；如果是以前早就全部自己弹出了，这都是安全限制改善的原因)</p>
<p>对于那些不是用户有意打开的弹出窗口，Chrome 采取了不同的处理方式。它不会像其他浏览器那样简单地屏蔽这些弹出窗口，而是只显示它们的标题栏，并把它们放在浏览器窗口的右下角。<br>在打开计算机硬盘中的网页时，IE 会解除对弹出窗口的某些限制。但是在服务器上执行这些代码会受到对弹出窗口的限制。</p>
<h4 id="弹出窗口屏蔽程序"><a href="#弹出窗口屏蔽程序" class="headerlink" title="弹出窗口屏蔽程序"></a>弹出窗口屏蔽程序</h4><p>大多数浏览器都内置有弹出窗口屏蔽程序，没有的也可以自己装工具。<br>结果就是用户可以将绝大多数不想看到弹出窗口屏蔽掉。<br>在弹出窗口被屏蔽时，就应该考虑两种可能性。如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么window.open()很可能会返回null。<br>此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</div><div class="line"><span class="keyword">if</span> (wroxWin == <span class="literal">null</span>)&#123;</div><div class="line">    alert(<span class="string">"The popup was blocked!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是浏览器扩展或其他程序阻止的弹出窗口，那么window.open()通常会抛出一个错误。<br>因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对window.open()的调用封装在一个try-catch 块中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</div><div class="line">    <span class="keyword">if</span> (wroxWin == <span class="literal">null</span>)&#123;</div><div class="line">        blocked = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">    blocked = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (blocked)&#123;</div><div class="line">    alert(<span class="string">"The popup was blocked!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检测弹出窗口是否被屏蔽只是一方面，它并不会阻止浏览器显示与被屏蔽的弹出窗口有关的消息。</p>
<h3 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h3><p><strong>JavaScript 是单线程语言</strong>，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。<br>前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。(也就是指setTimeout()和setTimeInterval()这两种吧)</p>
<p>超时调用需要使用window 对象的setTimeout()方法。<br>接受两个参数：要执行的代码和以毫秒表示的时间(即在执行代码前需要等待多少毫秒)。<br>第一个参数可以是一个包含JavaScript 代码的字符串(就和在eval()函数中使用的字符串一样)，也可以是一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不建议传递字符串！</span></div><div class="line">setTimeout(<span class="string">"alert('Hello world!') "</span>, <span class="number">1000</span>);</div><div class="line"><span class="comment">//推荐的调用方式</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"Hello world!"</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。<br>第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。<br>JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。<br>为了控制要执行的代码，就有一个JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。<br>setTimeout()的第二个参数告诉JavaScript 再过多长时间把当前任务添加到队列中。<br>如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</p>
<p>调用setTimeout()之后，该方法会返回一个数值ID，表示超时调用。<br>这个超时调用ID 是计划执行代码的唯一标识符，可以通过它来取消超时调用。</p>
<p>要取消尚未执行的超时调用计划，可以调用clearTimeout()方法并将相应的超时调用ID 作为参数传递给它。<br>只要是在指定的时间尚未过去之前调用clearTimeout()，就可以完全取消超时调用。</p>
<p>超时调用的代码都是在全局作用域中执行的，因此函数中this 的值在非严格模式下指向window 对象，在严格模式下是undefined。</p>
<p>设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同。<br>调用setInterval()方法同样也会返回一个间歇调用ID，该ID 可用于在将来某个时刻取消间歇调用。<br>取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面卸载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*使用setInterval()方法*/</span></div><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    num++;</div><div class="line">    <span class="comment">//如果执行次数达到了max 设定的值，则取消后续尚未执行的调用</span></div><div class="line">    <span class="keyword">if</span> (num == max) &#123;</div><div class="line">        clearInterval(intervalId);</div><div class="line">        alert(<span class="string">"Done"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">intervalId = setInterval(incrementNumber, <span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="comment">/*使用setTimeout()方法*/</span></div><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    num++;</div><div class="line">    <span class="comment">//如果执行次数未达到max 设定的值，则设置另一次超时调用</span></div><div class="line">    <span class="keyword">if</span> (num &lt; max) &#123;</div><div class="line">        setTimeout(incrementNumber, <span class="number">500</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        alert(<span class="string">"Done"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">setTimeout(incrementNumber, <span class="number">500</span>);</div></pre></td></tr></table></figure>
<p>可见，在使用超时调用时，没有必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自行停止。<br>一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，<strong>很少使用真正的间歇调用</strong>，原因是<strong>后一个间歇调用可能会在前一个间歇调用结束之前启动</strong>。<br>而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。</p>
<h3 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h3><p>浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。<br>系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。<br>它们的外观由操作系统及(或)浏览器设置决定，而不是由CSS 决定。<br>此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。</p>
<ol>
<li>alert()方法，这个方法接受一个字符串并将其显示给用户。<br> 通常使用alert()生成的“警告”对话框向用户显示一些他们无法控制的消息，例如错误消息。而用户只能在看完消息后关闭对话框。</li>
<li><p>confirm()方法主要区别在于“确认”对话框除了显示OK 按钮外，还会显示一个Cancel(“取消”)按钮，两个按钮可以让用户决定是否执行给定的操作。<br> 为了确定用户是单击了OK 还是Cancel，可以检查confirm()方法返回的布尔值：true 表示单击了OK，false 表示单击了Cancel 或单击了右上角的X 按钮。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (confirm(<span class="string">"Are you sure?"</span>)) &#123;</div><div class="line">    alert(<span class="string">"I'm so glad you're sure! "</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    alert(<span class="string">"I'm sorry to hear you're not sure. "</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>prompt()方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值(可以是一个空字符串)。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = prompt(<span class="string">"What is your name? "</span>, <span class="string">""</span>);</div><div class="line"><span class="keyword">if</span> (result !== <span class="literal">null</span>) &#123;</div><div class="line">    alert(<span class="string">"Welcome, "</span> + result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>由于不涉及HTML、CSS 或JavaScript，因此它们是增强Web 应用程序的一种便捷方式。<br>除了上述三种对话框之外，Google Chrome 浏览器还引入了一种新特性。<br>如果当前脚本在执行过程中会打开两个或多个对话框，那么从第二个对话框开始，每个对话框中都会显示一个复选框，以便用户阻止后续的对话框显示，除非用户刷新页面。<br>如果用户勾选了其中的复选框，并且关闭了对话框，那么除非用户刷新页面，所有后续的系统对话框(包括警告框、确认框和提示框)都会被屏蔽。<br>这个新特性出现以后，IE9 和Firefox 4 也实现了它。</p>
<p>还有两个可以通过JavaScript 打开的对话框，即“查找”和“打印”。<br>在JavaScript 中可以通过window 对象的find()和print()方法打开它们。<br>这两个方法同样不会就用户在对话框中的操作给出任何信息，因此它们的用处有限。<br>另外，既然这两个对话框是异步显示的，那么Chrome 的对话框计数器就不会将它们计算在内，<br>所以它们也不会受用户禁用后续对话框显示的影响。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式，治疗强迫症]]></title>
      <url>http://codingme.xyz/2016/09/27/regex/</url>
      <content type="html"><![CDATA[<h1 id="治疗用药方"><a href="#治疗用药方" class="headerlink" title="治疗用药方"></a>治疗用药方</h1><p>中文字符： <code>[\u4e00-\u9fa5]</code><br>中文标点符号(似乎有遗漏)：<code>[\u3002\uff1b\uff0c\uff1a\u201c\u201d\uff08\uff09\u3001\uff1f\u300a\u300b]</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第七章-2]]></title>
      <url>http://codingme.xyz/2016/09/27/javascript-note-7-2/</url>
      <content type="html"><![CDATA[<h1 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h1><p>严格来讲， JavaScript 中没有私有成员的概念；所有对象属性都是公有的。<br>不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> sum = num1 + num2;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数内部，有 3 个私有变量： num1 、 num2 和 sum 。<br>在函数内部可以访问这几个变量，但在函数外部则不能访问它们。<br>如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。<br>而利用这一点，就可以创建用于访问私有变量的公有方法。</p>
<p>把有权访问私有变量和私有函数的公有方法称为<strong>特权方法(privileged method)</strong>。<br>有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法:<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//私有变量和私有函数</span></div><div class="line"><span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//特权方法</span></div><div class="line"><span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    privateVariable++;</div><div class="line">    <span class="keyword">return</span> privateFunction();</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个模式在构造函数内部定义了所有私有变量和函数。<br>然后，又继续创建了能够访问这些私有成员的特权方法。<br>能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。<br>创建 MyObject 的实例后，除了使用 publicMethod() 这一个途径外，<br>没有任何办法可以直接访问 privateVariable 和 privateFunction() 。</p>
<p>利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</div><div class="line">alert(person.getName()); <span class="comment">//"Nicholas"</span></div><div class="line">person.setName(<span class="string">"Greg"</span>);</div><div class="line">alert(person.getName()); <span class="comment">//"Greg"</span></div></pre></td></tr></table></figure>
<p>这里有个小小的疑问：在没有具体声明标识符来执行变量声明的情况下，”Nicholas”是作为哪个变量的属性值？默认使用私有变量 name 么？</p>
<p>在构造函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。<br>第 6 章曾经讨论过，构造函数模式的缺点是针对每个实例都会创建同样一组新方法，<br>而使用静态私有变量来实现特权方法就可以避免这个问题。</p>
<h2 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h2><p>通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//私有变量和私有函数</span></div><div class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//公有/特权方法</span></div><div class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        privateVariable++;</div><div class="line">        <span class="keyword">return</span> privateFunction();</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>公有方法是在原型上定义的，这一点体现了典型的原型模式。<br>这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。<br>函数声明只能创建局部函数，但那并不是我们想要的。<br>出于同样的原因，也没有在声明 MyObject 时使用 var 关键字。<br>因此， MyObject 就成了一个全局变量，能够在私有作用域之外被访问到。<br>但也要知道，在严格模式下给未经声明的变量赋值会导致错误。<br>这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。<br>由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。<br>而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。</p>
<p>以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。<br>到底是使用实例变量，还是静态私有变量，最终还是要视具体需求而定。</p>
<p>多查找作用域链中的一个层次，就会在一定程度上影响查找速度。<br>而这正是使用闭包和私有变量的一个显明的不足之处。</p>
<h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>道格拉斯所说的模块模式(module pattern)则是为单例创建私有变量和特权方法。<br>所谓<strong>单例(singleton)</strong>，指的就是<strong>只有一个实例的对象</strong>。<br>按照惯例，JavaScript 是以对象字面量的方式来创建单例对象的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = &#123;</div><div class="line">    name : value,</div><div class="line">    method : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//这里是方法的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//私有变量和私有函数</span></div><div class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//特权/公有方法和属性</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        publicProperty: <span class="literal">true</span>,</div><div class="line">        publicMethod : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            privateVariable++;</div><div class="line">            <span class="keyword">return</span> privateFunction();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。<br>然后，将一个对象字面量作为函数的值返回。<br>返回的对象字面量中只包含可以公开的属性和方法。<br>由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。<br>从本质上来讲，这个对象字面量定义的是单例的公共接口。<br>这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//私有变量和函数</span></div><div class="line">    <span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    components.push(<span class="keyword">new</span> BaseComponent());</div><div class="line"></div><div class="line">    <span class="comment">//公共</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        getComponentCount : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> components.length;</div><div class="line">        &#125;,</div><div class="line">        registerComponent : <span class="function"><span class="keyword">function</span>(<span class="params">component</span>)</span>&#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">"object"</span>)&#123;</div><div class="line">                components.push(component);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>在 Web 应用程序中，经常需要使用一个单例来管理应用程序级的信息。<br>这个简单的例子创建了一个用于管理组件的 application 对象。<br>在创建这个对象的过程中，首先声明了一个私有的 components数组，并向数组中添加了一个 BaseComponent 的新实例<br>(在这里不需要关心 BaseComponent 的代码，只是用它来展示初始化操作)。<br>而返回对象的 getComponentCount() 和 registerComponent() 方法，都是有权访问数组 components 的特权方法。<br>前者只是返回已注册的组件数目，后者用于注册新组件。</p>
<p>如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。<br>以这种模式创建的每个单例都是 Object 的实例，因为最终要通过一个对象字面量来表示它。<br>事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。<br>因此，也就没有什么必要使用 instanceof 操作符来检查其对象类型了。</p>
<h2 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h2><p>有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。<br>这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和(或)方法对其加以增强的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//私有变量和私有函数</span></div><div class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建对象</span></div><div class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</div><div class="line">    <span class="comment">//添加特权/公有属性和方法</span></div><div class="line">    object.publicProperty = <span class="literal">true</span>;</div><div class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        privateVariable++;</div><div class="line">        <span class="keyword">return</span> privateFunction();</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//返回这个对象</span></div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>如果前面演示模块模式的例子中的 application 对象必须是 BaseComponent 的实例，那么:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//私有变量和函数</span></div><div class="line">    <span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    components.push(<span class="keyword">new</span> BaseComponent());</div><div class="line">    <span class="comment">//创建 application 的一个局部副本</span></div><div class="line">    <span class="keyword">var</span> app = <span class="keyword">new</span> BaseComponent();</div><div class="line">    <span class="comment">//公共接口</span></div><div class="line">    app.getComponentCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> components.length;</div><div class="line">    &#125;;</div><div class="line">    app.registerComponent = <span class="function"><span class="keyword">function</span>(<span class="params">component</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> component == <span class="string">"object"</span>)&#123;</div><div class="line">            components.push(component);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//返回这个副本</span></div><div class="line">    <span class="keyword">return</span> app;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>主要的不同之处在于命名变量 app 的创建过程，因为它必须是 BaseComponent 的实例。这个实例实际上是 application 对象的局部变量版。<br>此后，我们又为 app 对象添加了能够访问私有变量的公有方法。最后一步是返回 app 对象，结果仍然是将它赋值给全局变量 application 。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[记录：利用 Livereload 实现 Hexo 博客自动刷新页面]]></title>
      <url>http://codingme.xyz/2016/09/26/hexo-tool-livereload/</url>
      <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>一开始是因为使用了新的 IDE ： Visual Studio Code ，装上了 markdownlint 插件。<br>然后为了符合规则，修改原本的 .md 文件。<br><code>hexo s</code>命令会监控文件，每次修改完保存，刷新页面就能看到所修改的新内容。<br>为了看修改完符合规则后，文章页面实际的表现效果有没有出错，在使用了<code>hexo s</code>命令后还得手动刷新页面。<br>每修改完想确认一次就得刷新一次， F5 又不是真的氪合金做的，而且一直手动刷新也麻烦；浏览器定时刷新也不准确。</p>
<p>为了第一驱动力：懒惰，于是就去寻找跟 Hexo 和自动刷新有关的内容。</p>
<h1 id="第一次尝试："><a href="#第一次尝试：" class="headerlink" title="第一次尝试："></a>第一次尝试：</h1><p>找到关于 Livereload 的介绍和教程，但是可能是因为 Hexo 和 Livereload 都有更新的缘故，原本推荐的 Hexo 的插件并不好使。<br>本地端通过 npm 安装的 Livereload 哪怕运行了，浏览器的 Livereload 插件并不能正常检测连接上。<br><a id="more"></a></p>
<h1 id="第二次尝试："><a href="#第二次尝试：" class="headerlink" title="第二次尝试："></a>第二次尝试：</h1><p>于是避开了 Livereload ,想看看还有没有别的软件和方法，还真有。<br>BrowserSync ，看上去比 Livereload 更新的样子，也许能好使。<br>装上插件，装上软件，成功运行，好像还能成功自动刷新了，看样子好使了？<br>然而还是不行……</p>
<p>问题一：好像还是出在 Hexo 的插件上。似乎是因为久未更新，存在不少 BUG 。<br>似乎只要 .md 文件内容稍微到达几千中文，就会有不能成功使用的问题。<br>问题二：似乎和我所使用的 NEXT 主题有兼容问题。<br>(无法自己插入脚本，导致自动刷新功能根本无法使用，能使用的页面貌似只有“归档”和“标签”这种索引页面，“文章”页面就完全不行)</p>
<p>于是只好作罢。</p>
<h1 id="成功的第三次尝试："><a href="#成功的第三次尝试：" class="headerlink" title="成功的第三次尝试："></a>成功的第三次尝试：</h1><p>不甘心就此作罢，回顾失败的步骤，发现 Livereload 虽然挺简陋，但是 Windows 版本还是有出了一个本地端的 Alpha 安装版本。<br>尝试使用这个 Alpha 版，安装运行后， Livereload 的浏览器插件竟然意外的能连接上了。(并没有掺合 Hexo 的旧插件)</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>我的安装操作：</p>
<ol>
<li>安装 Livereload 的 Windows 版本。</li>
<li>Chrome 安装 Livereload 的扩展插件。</li>
<li>运行 Windows 版本的 Livereload,文件夹 folders 把 Hexo 博客本地的 source 文件夹添加上。</li>
<li>使用 VS Code 设置自动保存还有保存延时。</li>
</ol>
<p>我的使用：</p>
<ol>
<li><code>hexo s</code>， chrome 打开<code>localhost:4000</code>本地 Hexo 页面再进入要刷新的子页面。</li>
<li>打开 Windows 的 Livereload 本地端(source 文件夹已经添加过)。</li>
<li>点击 Chrome 的 Livereload 插件，将当前页面标签连接上本地端。</li>
<li>使用 VS Code 编辑 source/_posts 文件夹里的 .md 文件。</li>
</ol>
<p>效果：</p>
<p>每次自动保存完，连接上的页面就会自动刷新。达到了一开始想要实现的目的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第七章-1]]></title>
      <url>http://codingme.xyz/2016/09/25/javascript-note-7-1/</url>
      <content type="html"><![CDATA[<h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><p>定义函数的两种方式：</p>
<ol>
<li>函数声明,重要特征：函数声明提升(function declaration hoisting)<br> <code>function functionName(arg0,arg1){}</code></li>
<li>函数表达式(也叫做匿名函数[因为没标识符]，有时候也叫 lambda 拉姆达函数)<br> <code>var functionName = function(arg0,arg1){}</code></li>
</ol>
<p>理解函数提升：<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不要这样做！</span></div><div class="line"><span class="keyword">if</span>(condition)&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"Hi!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"Yo!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这在 ECMAScript 中属于无效语法， JavaScript 引擎会尝试修正错误，将其转换为合理的状态。<br>但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略 condition ；<br>Firefox 会在 condition 为 true 时返回第一个声明。<br>因此这种使用方式很危险，不应该这样写。</p>
<p>但如果使用函数表达式就没有什么问题了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//可以这样做</span></div><div class="line"><span class="keyword">var</span> sayHi;</div><div class="line"><span class="keyword">if</span>(condition)&#123;</div><div class="line">    sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"Hi!"</span>);</div><div class="line">    &#125;;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"Yo!"</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在把函数当成值来使用的情况下，都可以使用匿名函数。不过，这并不是匿名函数唯一的用途。</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherFactorial = factorial;</div><div class="line">factorial = <span class="literal">null</span>;</div><div class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">//出错！</span></div></pre></td></tr></table></figure>
<p>虽然 factorial()函数是保存在 anotherFactorial 中，但是由于 factorial 已经不再是函数, anotherFactorial() 中又调用了 factorial() ，从而导致错误。</p>
<p>解决方法是使用<code>arguments.callee</code>，它是一个指向正在执行的函数的指针，因此可以用它代替实现对函数的递归调用。<br><strong>递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名——函数名可能会发生变化。</strong><br>但在严格模式下，不能通过脚本访问 arguments.callee ，访问这个属性会导致错误。<br>不过，可以使用命名函数表达式来达成相同的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * f(num<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>匿名函数和闭包这两个概念。<br>闭包是指<strong>有权访问另一个函数作用域中的变量的函数</strong>。<br>创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
<p>后台的每个执行环境都有一个表示变量的对象——<strong>变量对象</strong>。<br>无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。<br>一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)。<br>但是，闭包的情况又有所不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> compare = createComparisonFunction(<span class="string">"name"</span>);</div><div class="line"><span class="keyword">var</span> result = compare(&#123; name: <span class="string">"Nicholas"</span> &#125;, &#123; name: <span class="string">"Greg"</span> &#125;);</div></pre></td></tr></table></figure>
<p>在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中。<br>使用 arguments 和其他命名参数的值来初始化函数的<strong>活动对象(activation object)</strong>。<br>更为重要的是， createComparisonFunction() 函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。<br>换句话说，当 createComparisonFunction() 函数返回后，<strong>其执行环境的作用域链</strong>会被销毁，但它的活动对象(作用域)仍然会留在内存中；直到匿名函数被销毁后， createComparisonFunction() 的活动对象才会被销毁。<br>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。 但是，当函数返回了一个闭包时，这个函数的<strong>作用域(scope)(为什么说作用域而不是说活动对象？)</strong>将会一直在内存中保存到闭包不存在为止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建函数</span></div><div class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">"name"</span>);</div><div class="line"><span class="comment">//调用函数</span></div><div class="line"><span class="keyword">var</span> result = compareNames(&#123; name: <span class="string">"Nicholas"</span> &#125;, &#123; name: <span class="string">"Greg"</span> &#125;);</div><div class="line"><span class="comment">//解除对匿名函数的引用(以便释放内存)</span></div><div class="line">compareNames = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>当 createComparisonFunction() 函数返回后，其执行环境的作用域链会被销毁，<br>但它的活动对象仍然会留在内存中；直到匿名函数被销毁后， createComparisonFunction() 的活动对象才会被销毁。</p>
<p>闭包要谨慎使用：由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。<br>过度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包。<br>虽然像 V8 等优化后的 JavaScript 引擎会尝试回收被闭包占用的内存，但请大家还是要慎重使用闭包。</p>
<h2 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h2><p>作用域链对闭包的副作用：即闭包只能取得包含函数中任何变量的最后一个值。<br>别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回一个函数数组。实际上，每个函数都返回 10。<br>因为每个函数的作用域链中都保存着 createFunctions() 函数的活动对象，所以它们引用的都是同一个变量 i 。<br>当 createFunctions() 函数返回后，变量 i 的值是 10，此时每个函数都引用着保存变量 i 的同一个变量对象，<br>所以在每个函数内部 i 的值都是 10。</p>
<p>但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="keyword">return</span> num;</div><div class="line">            &#125;;</div><div class="line">        &#125;(i);<span class="comment">//在调用每个匿名函数时，我们传入了变量 i 。</span></div><div class="line">        <span class="comment">//由于函数参数是按值传递的，所以就会将变量 i 的当前值复制给参数 num 。</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关于-this-对象"><a href="#关于-this-对象" class="headerlink" title="关于 this 对象"></a>关于 this 对象</h3><p>在闭包中使用 this 对象也可能会导致一些问题。<br>this 对象是在运行时基于函数的执行环境绑定的。<br>在全局函数中， this 等于 window ，而当函数被作为某个对象的方法调用时， this 等于那个对象。<br>不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    name : <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()()); <span class="comment">//"The Window"(在非严格模式下)</span></div></pre></td></tr></table></figure>
<p>为什么匿名函数没有取得其包含作用域(或外部作用域)的 this 对象呢？</p>
<p>每个函数在被调用时都会自动取得两个特殊变量： this 和 arguments 。<br>内部函数在搜索 this 和 arguments 时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。<br>修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    name : <span class="string">"My Object"</span>,</div><div class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> that.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()()); <span class="comment">//"My Object"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>例子1：调用 Object 的方法 getNameFunc ，返回匿名函数 function () {return:this.name}，存入内存并立刻调用这一函数，形成闭包。此时相当于在 window 的环境下调用函数，而不是在 Object 的环境下调用方法。此时 this 指向的是 window 对象。返回之前声明的 window.name 。<br>例子2：调用 Object 的方法 getNameFunc ，此时 this 为 Object ，将 this 赋给变量 that ，此时 this 指向 Object ，也就是将 Object 的引用赋给变量 that 。返回匿名函数 function () {return:that.name}，该匿名函数和 that 绑定在同一作用域， that 不释放，形成闭包。再如同例子1，立刻调用此匿名函数，自然 that.name 就是 Object.name ，返回之。<br>作者：岳逢楽<br>链接：<a href="https://www.zhihu.com/question/21172721/answer/17413362/" target="_blank" rel="external">https://www.zhihu.com/question/21172721/answer/17413362/</a></p>
</blockquote>
<p>arguments 也存在同样的问题。如果想访问作用域中的 arguments 对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。</p>
<p> this 的值可能会意外地改变的特殊情况其他例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    name : <span class="string">"My Object"</span>,</div><div class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">object.getName(); <span class="comment">//"My Object"</span></div><div class="line">(object.getName)(); <span class="comment">//"My Object"</span></div><div class="line">(object.getName = object.getName)(); <span class="comment">//"The Window"，在非严格模式下</span></div></pre></td></tr></table></figure>
<p>第一行代码跟平常一样调用了 object.getName() ，返回的是 “My Object” ，因为 this.name 就是 object.name 。<br>第二行代码在调用这个方法前先给它加上了括号。虽然加上括号之后，就好像只是在引用一个函数，但 this 的值得到了维持，<br>因为 object.getName 和 (object.getName) 的定义是相同的。<br>第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。<br>因为这个赋值表达式的值是函数本身，所以 this 的值不能得到维持，结果就返回了 “The Window” 。</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>闭包在 IE 的这些版本中会导致一些特殊的问题。<br>具体来说，如果闭包的作用域链中保存着一个 HTML 元素，那么就意味着该元素将无法被销毁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">unction assignHandler()&#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</div><div class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(element.id);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码创建了一个作为 element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。<br>由于匿名函数保存了一个对 assignHandler() 的活动对象的引用，因此就会导致无法减少 element 的引用数。<br>只要匿名函数存在， element 的引用数至少也是 1，因此它所占用的内存就永远不会被回收。</p>
<p>解决方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</div><div class="line">    <span class="keyword">var</span> id = element.id;</div><div class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(id);</div><div class="line">    &#125;;</div><div class="line">    element = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过把 element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。<br>但仅仅做到这一步，还是不能解决内存泄漏的问题。<br>必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着 element 。<br>即使闭包不直接引用 element ，包含函数的活动对象中也仍然会保存一个引用。<br>因此，有必要把 element 变量设置为 null 。这样就能够解除对 DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。</p>
<h1 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++)&#123;</div><div class="line">        alert(i);</div><div class="line">    &#125;</div><div class="line">    alert(i); <span class="comment">//计数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Java 、 C++等语言中，变量 i 只会在 for 循环的语句块中有定义，循环一旦结束，变量 i 就会被销毁。<br>可是在 JavaScript 中，变量 i 是定义在 ouputNumbers() 的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++)&#123;</div><div class="line">        alert(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> i; <span class="comment">// 重新声明变量</span></div><div class="line">    alert(i); <span class="comment">//计数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然重新声明了变量，但是最后的<code>alert(i);</code>还是能正确的输出出来。<br>JavaScript 从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见(不过，它会执行后续声明中的变量初始化)。<br>即后续声明<code>var i;</code>等于看不见，除非是<code>var i=9;</code>这样的变量初始化。</p>
<p>匿名函数可以用来模仿块级作用域并避免这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//这里是块级作用域</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。<br>而紧随其后的另一对圆括号会立即调用这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">5</span>;</div><div class="line">outputNumbers(count);</div></pre></td></tr></table></figure>
<p>这里初始化了变量 count ，将其值设置为 5。当然，这里的变量是没有必要的，因为可以把值直接传给函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> someFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//这里是块级作用域</span></div><div class="line">&#125;;</div><div class="line">someFunction();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//这里是块级作用域</span></div><div class="line">&#125;(); <span class="comment">//出错！</span></div></pre></td></tr></table></figure>
<p>语法错误是因为 JavaScript 将 function 关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。<br>然而，函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式，只要像下面这样给它加上一对圆括号即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//这里是块级作用域</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++)&#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">    alert(i); <span class="comment">//导致一个错误！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 for 循环外部插入了一个私有作用域。在匿名函数中定义的任何变量，都会在执行结束时被销毁。<br>因此，变量 i 只能在循环中使用，使用后即被销毁。<br>而在私有作用域中能够访问变量 count ，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的所有变量。</p>
<p>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。</p>
<p>一般来说，我们都应该尽量少向全局作用域中添加变量和函数。<br>在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。<br>而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">    <span class="keyword">if</span> (now.getMonth() == <span class="number">0</span> &amp;&amp; now.getDate() == <span class="number">1</span>)&#123;</div><div class="line">        alert(<span class="string">"Happy new year!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第六章-3]]></title>
      <url>http://codingme.xyz/2016/09/22/javascript-note-6-3/</url>
      <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>许多 OO 语言都支持两种继承方式：接口继承和实现继承。<br>接口继承只继承方法签名，而实现继承则继承实际的方法。<br>由于函数没有签名，在 ECMAScript 中无法实现接口继承。<br>ECMAScript 只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>ECMAScript 将原型链作为实现继承的主要方法。<br>基本思想:利用原型让一个引用类型继承另一个引用类型的属性和方法。<br><a id="more"></a><br>基本模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//继承了 SuperType</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue()); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>SuperType 和 SubType 主要区别是 SubType 继承了 SuperType ，<br>而继承是通过创建 SuperType 的实例，并将该实例赋给 SubType.prototype 实现的。<br>实现的本质是重写原型对象，代之以一个新类型的实例。<br>原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。<br>新原型不仅具有作为一个 SuperType 的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了 SuperType 的原型。</p>
<p>instance 指向 SubType 的原型 ，<br>SubType 的原型又指向 SuperType 的原型 。<br>getSuperValue() 方法仍然还在 SuperType.prototype 中，<br>但 property 则位于 SubType.prototype(SuperType 实例) 中。<br>instance.constructor 现在指向的是 SuperType ，<br>这是因为原来 SubType.prototype 中的 constructor 被重写了的缘故(现在的 SubType.prototype 即 SuperType 实例，其原型 SuperType 的 constructor 指向 SuperType 构造函数)。</p>
<p>通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。<br>调用 instance.getSuperValue() 会经历三个搜索步骤：<br>1)搜索实例；<br>2)搜索 SubType.prototype ；<br>3)搜索 SuperType.prototype ，最后一步才会找到该方法。</p>
<h3 id="别忘记默认的原型"><a href="#别忘记默认的原型" class="headerlink" title="别忘记默认的原型"></a>别忘记默认的原型</h3><p>前面例子中展示的原型链还少一环。所有引用类型默认都继承了 Object ，而这个继承也是通过原型链实现的。<br>有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype 。<br>这也正是所有自定义类型都会继承 toString() 、 valueOf() 等默认方法的根本原因。<br>SubType 继承了 SuperType ，而 SuperType 继承了 Object 。当调用 instance.toString()时，实际上调用的是保存在 Object.prototype 中的那个方法。</p>
<h3 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><p>可以通过两种方式来确定原型和实例之间的关系。<br>1.使用 instanceof 操作符。用这个操作符来测试<strong>实例</strong>与原型链中出现过的<strong>构造函数</strong>，结果就会返回 true 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">//true</span></div><div class="line">alert(instance <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>2.使用 isPrototypeOf() 方法。同样，只要是原型链中出现过的<strong>原型</strong>，都可以说是该原型链所派生的<strong>实例的原型</strong>，因此 isPrototypeOf() 方法也会返回 true 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></div><div class="line">alert(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></div><div class="line">alert(SubType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h3 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h3><p>给原型添加方法的代码一定要放在替换原型的语句之后。<br>在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//继承了 SuperType</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line"><span class="comment">// 使用字面量添加新方法，会导致上一行代码无效</span></div><div class="line">SubType.prototype = &#123;</div><div class="line">    getSubValue : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">    &#125;,</div><div class="line">    someOtherMethod : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在的原型包含的是一个 Object 的实例，而非 SuperType 的实例，<br>因此我们设想中的原型链已经被切断—— SubType 和 SuperType 之间已经没有关系了。</p>
<h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>1.最主要的问题来自包含引用类型值的原型。<br>包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。<br>在通过原型来实现继承时，原型实际上会变成另一个类型的实例。<br>于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</p>
<p>2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。<br>应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
<p>因此，实践中很少会单独使用原型链。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><p>在解决<strong>原型中包含引用类型值</strong>所带来问题的过程中，开发人员开始使用一种叫做<strong>借用构造函数</strong>(constructor stealing)的技术(有时候也叫做<strong>伪造对象</strong>或<strong>经典继承</strong>)。<br>基本思想：即在子类型构造函数的内部调用超类型构造函数。<br>函数只不过是在特定环境中执行代码的对象，因此通过使用 apply() 和 call() 方法也可以在(将来)新创建的对象上执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">// 继承了 SuperType</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></div></pre></td></tr></table></figure>
<p>“借调”了超类型的构造函数。通过使用 call() 方法(或 apply() 方法也可以)，<br>我们实际上是在(未来将要)新创建的 SubType 实例的环境下调用了 SuperType 构造函数。</p>
<p>结果， SubType 的每个实例就都会具有自己的 colors 属性的副本了。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//继承了 SuperType ，同时还传递了参数</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</div><div class="line">    <span class="comment">//实例属性</span></div><div class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.name); <span class="comment">//"Nicholas";</span></div><div class="line">alert(instance.age); <span class="comment">//29</span></div></pre></td></tr></table></figure>
<h3 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h3><p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，(于是就有了一个接一个的函数实例)<br>因此函数复用就无从谈起了。<br>而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。<br>考虑到这些问题，借用构造函数的技术也是很少单独使用的。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承(combination inheritance)，有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。<br>思路：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//继承属性</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>, name);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//继承方法</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></div><div class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></div><div class="line">instance1.sayAge(); <span class="comment">//29</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</div><div class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></div><div class="line">instance2.sayName(); <span class="comment">//"Greg";</span></div><div class="line">instance2.sayAge(); <span class="comment">//27</span></div></pre></td></tr></table></figure>
<p>在这个例子中 SubType 利用 call()/apply() 方法调用 SuperType 构造函数，继承了 SuperType 构造函数的属性(color),并传入 name 参数，<br>又定义了它自己的属性 age 。之后将 SuperType 的实例赋值给 SubType 的原型实现了继承方法，然后又在该新原型上定义了方法 sayAge() 。<br>这样一来，就可以让两个不同的 SubType 实例既分别拥有自己属性——包括 colors 属性，又可以使用相同的方法了。</p>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。<br>而且， instanceof 和 isPrototypeOf() 也能够用于识别基于组合继承创建的对象。</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>道格拉斯·克罗克福德在 2006年写了一篇文章，题为 Prototypal Inheritance in JavaScript (JavaScript 中的原型式继承)。<br>想法：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">        F.prototype = o;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 object() 函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。<br>从本质上讲， object() 对传入其中的对象执行了一次浅复制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    name: <span class="string">"Nicholas"</span>,</div><div class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson = object(person);</div><div class="line">anotherPerson.name = <span class="string">"Greg"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</div><div class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</div><div class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</div><div class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></div></pre></td></tr></table></figure>
<p>这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。<br>如果有这么一个对象的话，可以把它传递给 object() 函数，然后再根据具体需求对得到的对象加以修改即可。<br>在这个例子中，可以作为另一个对象基础的是 person 对象，<br>于是我们把它传入到 object() 函数中，然后该函数就会返回一个新对象。<br>这个新对象将 person 作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。<br>这意味着 person.friends 不仅属于 person 所有，而且也会被 anotherPerson 以及 yetAnotherPerson 共享。<br>实际上，这就相当于又创建了 person (实例)对象的两个副本。</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>ECMAScript 5 通过新增 Object.create() 方法规范化了原型式继承。<br>这个方法接收两个参数：一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。<br>在传入一个参数的情况下， Object.create() 与 object() 方法的行为相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    name: <span class="string">"Nicholas"</span>,</div><div class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</div><div class="line">anotherPerson.name = <span class="string">"Greg"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</div><div class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</div><div class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</div><div class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></div></pre></td></tr></table></figure>
<p>Object.create() 方法的第二个参数与 Object.defineProperties() 方法的第二个参数格式相同：<br>每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    name: <span class="string">"Nicholas"</span>,</div><div class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</div><div class="line">    name: &#123;</div><div class="line">        value: <span class="string">"Greg"</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name); <span class="comment">//"Greg"</span></div></pre></td></tr></table></figure>
<p>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。<br>不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。<br>思路:与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，<br>该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></div><div class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//以某种方式来增强这个对象</span></div><div class="line">        alert(<span class="string">"hi"</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">name: <span class="string">"Nicholas"</span>,</div><div class="line">friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></div></pre></td></tr></table></figure>
<p>这个例子中的代码基于 person 返回了一个新对象—— anotherPerson 。<br>新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi() 方法。<br>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。<br>前面示范继承模式时使用的 object() 函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。<br>组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：<br>一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。<br>子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。<br>基本思路:不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。<br>本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></div><div class="line">    prototype.constructor = subType; <span class="comment">//增强对象</span></div><div class="line">    subType.prototype = prototype; <span class="comment">//指定对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一步是创建超类型原型的一个副本。<br>第二步是为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性。<br>最后一步，将新创建的对象(即副本)赋值给子类型的原型。</p>
<p>原版：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">    SuperType.call(<span class="keyword">this</span>, name); <span class="comment">// 第二次调用 SuperType()</span></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 第一次调用 SuperType()</span></div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用寄生式组合继承的版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">    SuperType.call(<span class="keyword">this</span>, name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样就只需要调用一次 SuperType 构造函数，避免了在 SubType.prototype 上面创建不必要的、多余的属性。<br>与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf() 。<br>开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。<br>YUI 的 YAHOO.lang.extend() 方法采用了寄生组合继承，从而让这种模式首次出现在了一个应用非常广泛的 JavaScript 库中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第六章-2]]></title>
      <url>http://codingme.xyz/2016/09/20/javascript-note-6-2/</url>
      <content type="html"><![CDATA[<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：<br>使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。<br>考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决<strong>对象识别的问题(即怎样知道一个对象的类型)</strong>。<br>随着 JavaScript 的发展，又一个新模式出现了。</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>构造函数可用来创建特定类型的对象。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。<br>此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>与工厂模式的 createPerson() 的不同之处：</p>
<ol>
<li>没有显式地创建对象；</li>
<li>直接将属性和方法赋给了 this 对象；</li>
<li>没有 return 语句。</li>
</ol>
<p>函数名 Person 使用的是大写字母 P 。<br>按照惯例，<strong>构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</strong></p>
<p>要创建 Person 的新实例，必须使用 new 操作符。会经历以下 4个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象)；</li>
<li>执行构造函数中的代码(为这个新对象添加属性)；</li>
<li>返回新对象。</li>
</ol>
<p>在前面例子的最后， person1 和 person2 分别保存着 Person 的一个不同的实例。<br>这两个对象都有一个 constructor (构造函数)属性，该属性指向 Person 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对象的 constructor 属性最初是用来标识对象类型的。</span></div><div class="line">alert(person1.constructor == Person); <span class="comment">//true</span></div><div class="line">alert(person2.constructor == Person); <span class="comment">//true</span></div><div class="line"></div><div class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。<br>以这种方式定义的构造函数是定义在 Global 对象(在浏览器中是 window 对象)中的。</p>
<h3 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h3><p>造函数与其他函数的唯一区别，就在于调用它们的方式不同。<br>任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当作构造函数使用</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">person.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line"><span class="comment">// 作为普通函数调用</span></div><div class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>); <span class="comment">// 添加到 window</span></div><div class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//"Greg"</span></div><div class="line"><span class="comment">// 在另一个对象的作用域中调用</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</div><div class="line">o.sayName(); <span class="comment">//"Kristen"</span></div></pre></td></tr></table></figure>
<p>当在全局作用域中调用一个函数时， this 对象总是指向 Global 对象(在浏览器中就是 window 对象)。<br>因此，在调用完函数之后，可以通过 window 对象来调用 sayName() 方法，并且还返回了 “Greg” 。</p>
<h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>使用构造函数的主要问题，就是<strong>每个方法都要在每个实例上重新创建一遍</strong>。<br>person1 和 person2 都有一个名为 sayName() 的方法，但那两个方法不是同一个 Function 的实例。<br>ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(this.name)"</span>); <span class="comment">//  与声明函数在逻辑上是等价的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以这种方式创建函数，会导致不同的作用域链和标识符解析，<br>但创建 Function 新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的。<br><code>alert(person1.sayName == person2.sayName); //false</code><br>创建两个完成同样任务的 Function 实例的确没有必要；<br>况且有 this 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。<br>因此，大可通过把函数定义转移到构造函数外部来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。<br>而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，<br>于是我们这个自定义的引用类型就丝毫没有封装性可言了。<br>于是就有了原型模式。</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>我们创建的每个函数都有一个 prototype (原型)属性，<br>这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<br>如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。<br>使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。<br>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。<br>但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。</p>
<h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。<br>在默认情况下，所有原型对象都会自动获得一个 constructor(构造函数)属性，这个属性包含一个指向 prototype 属性所在函数的指针。<br>Person.prototype. constructor 指向 Person 。<br>而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。<br>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则都是从 Object 继承而来的。<br>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针(内部属性)，指向构造函数的原型对象。<br>ECMA-262 第 5 版中管这个指针叫 [[Prototype]] 。<br>虽然在脚本中没有标准的方式访问 [[Prototype]] ，但 Firefox 、 Safari 和 Chrome 在每个对象上都支持一个属性<code>__proto__</code> ；而在其他实现中，这个属性对脚本则是完全不可见的。</p>
<p>新构造函数 Person.prototype 属性-&gt; Person Prototype 原型对象<br>Person.prototype(原型对象).constructor 属性 -&gt;  构造函数 Person<br>person1 、 person2(实例). [[Prototype]] -&gt; Person Prototype</p>
<p>虽然这两个实例都不包含属性和方法，但我们却可以调用 person1.sayName() 。这是通过查找对象属性的过程来实现的。<br>查找对象属性：每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。<br>搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；<br>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。<br>如果在原型对象中找到了这个属性，则返回该属性的值。<br>在我们调用 person1.sayName() 的时候，会先后执行两次搜索。<br>首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。”<br>然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。”<br>于是，它就读取那个保存在原型对象中的函数。<br>要点：原型最初只包含 constructor 属性，而该属性也是共享的，因此可以通过对象实例访问。<br>但是不能通过对象实例重写原型中的值。<br>要重新从对象实例中访问原型对象的属性的话，可以使用 delete 删除对象实例屏蔽的同名属性。</p>
<p>虽然在所有实现中都无法访问到 [[Prototype]] ，但可以通过 isPrototypeOf() 方法来确定对象之间是否存在这种关系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Person.prototype.isPrototypeOf(person1)); <span class="comment">//true</span></div><div class="line">alert(Person.prototype.isPrototypeOf(person2)); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h4 id="Object-getPrototypeOf-ECMAScript5"><a href="#Object-getPrototypeOf-ECMAScript5" class="headerlink" title="Object.getPrototypeOf()(ECMAScript5)"></a>Object.getPrototypeOf()(ECMAScript5)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span></div><div class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>使用 Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在利用原型实现继承的情况下是非常重要的。</p>
<h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h4><p>使用 hasOwnProperty() 方法可以检测一个属性是存在于实例中，还是存在于原型中。(是从 Object 继承来的)<br>如果来自实例则为 true ，来自原型则为 false 。</p>
<h4 id="Object-getOwnPropertyDescriptor-ECMAScript5"><a href="#Object-getOwnPropertyDescriptor-ECMAScript5" class="headerlink" title="Object.getOwnPropertyDescriptor()(ECMAScript5)"></a>Object.getOwnPropertyDescriptor()(ECMAScript5)</h4><p>ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法只能用于实例属性，<br>要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor() 方法。</p>
<h3 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 in 操作符</h3><p>使用 in 操作符的两种方式：<br>单独使用和在 for-in 循环中使用。</p>
<p><strong>1.</strong>在单独使用时， in 操作符会在通过对象能够访问给定属性时返回 true ，无论该属性存在于实例中还是原型中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">person1.name = <span class="string">"Greg"</span>;</div><div class="line">alert(person1.name); <span class="comment">//"Greg" ——来自实例</span></div><div class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//true</span></div><div class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">//true</span></div><div class="line">alert(person2.name); <span class="comment">//"Nicholas" ——来自原型</span></div><div class="line">alert(person2.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//false</span></div><div class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person2); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>两者可结合写成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</div><div class="line">&#125;</div><div class="line">person.name = <span class="string">"Greg"</span>;</div><div class="line">alert(hasPrototypeProperty(person, <span class="string">"name"</span>)); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>即使原型中仍然有 name 属性，但由于现在实例中也有了这个属性，因此原型中的 name 属性就用不到了。所以返回 false 。</p>
<p><strong>2.</strong>在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的(enumerated)属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。<br>屏蔽了原型中不可枚举属性(即将[[Enumerable]] 标记为 false 的属性)的实例属性也会在 for-in 循环中返回，<br>因为根据规定，所有开发人员定义的属性都是可枚举的——只有在 IE8 及更早版本中例外。<br>IE 的 BUG :<br>IE 早期版本的实现中存在一个 bug ，即屏蔽不可枚举属性的实例属性不会出现在 for-in 循环中。<br>该 bug 会影响默认不可枚举的所有属性和方法，包括： hasOwnProperty() 、 propertyIsEnumerable() 、 toLocaleString() 、 toString() 和 valueOf() 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"My Object"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o)&#123;</div><div class="line">    <span class="keyword">if</span> (prop == <span class="string">"toString"</span>)&#123;</div><div class="line">        alert(<span class="string">"Found toString"</span>); <span class="comment">//在 IE 中不会显示</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ECMAScript 5 也将 constructor 和 prototype 属性的 [[Enumerable]] 特性设置为 false ，但并不是所有浏览器都照此实现。</p>
<h4 id="Object-keys-ECMAScript5"><a href="#Object-keys-ECMAScript5" class="headerlink" title="Object.keys()(ECMAScript5)"></a>Object.keys()(ECMAScript5)</h4><p>要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 Object.keys() 方法。<br>这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。<br>如果是通过实例调用，则 Object.keys()返回的数组只包含实例属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</div><div class="line">alert(keys); <span class="comment">//"name,age,job,sayName"</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">p1.name = <span class="string">"Rob"</span>;</div><div class="line">p1.age = <span class="number">31</span>;</div><div class="line"><span class="keyword">var</span> p1keys = <span class="built_in">Object</span>.keys(p1);</div><div class="line">alert(p1keys); <span class="comment">//"name,age"</span></div></pre></td></tr></table></figure>
<p>如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames()方法。(同样是 ECMAScript5 )</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype);</div><div class="line">alert(keys); <span class="comment">//"constructor,name,age,job,sayName"</span></div></pre></td></tr></table></figure>
<h3 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h3><p>用一个包含所有属性和方法的对象字面量来重写整个原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">    name : <span class="string">"Nicholas"</span>,</div><div class="line">    age : <span class="number">29</span>,</div><div class="line">    job: <span class="string">"Software Engineer"</span>,</div><div class="line">    sayName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>例子的最终结果相同，但有一个例外： constructor 属性不再指向 Person 了。<br>我们在这里使用的语法，本质上完全重写了默认的 prototype 对象，<br>因此 constructor 属性也就变成了新对象的 constructor 属性(指向 Object 构造函数)，不再指向 Person 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line">alert(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert(friend <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line">alert(friend.constructor == Person); <span class="comment">//false</span></div><div class="line">alert(friend.constructor == <span class="built_in">Object</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>如果 constructor 的值真的很重要，可以特意将它设置回适当的值。<br><code>constructor : Person,</code><br>注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true 。<br>默认情况下，原生的 constructor 属性是不可枚举的。<br>如果使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty() 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 重设构造函数，只适用于 ECMAScript 5  兼容的浏览器</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</div><div class="line">    enumerable: <span class="literal">false</span>,</div><div class="line">    value: Person</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来<br>——即使是先创建了实例后修改原型也照样如此。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"hi"</span>);</div><div class="line">&#125;;</div><div class="line">friend.sayHi(); <span class="comment">//"hi"(没有问题！)</span></div></pre></td></tr></table></figure>
<p>原因可以归结为实例与原型之间的松散连接关系。当我们调用 person.sayHi()时，首先会在实例中搜索名为 sayHi 的属性，<br>在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，<br>因此就可以在原型中找到新的 sayHi 属性并返回保存在那里的函数。</p>
<p>如果是重写整个原型对象，那么情况就不一样了。调用构造函数时会为实例添加一个指向最初原型的[[Prototype]] 指针，<br>而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。<br><strong>实例中的指针仅指向原型，而不指向构造函数。</strong><br>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。</p>
<h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。<br>所有原生引用类型( Object 、 Array 、 String ，等等)都在其构造函数的原型上定义了方法。</p>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。<br>可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。<br><strong>尽管可以这样做，但不推荐在产品化的程序中修改原生对象的原型。当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。</strong><br><strong>这样做也可能会意外地重写原生方法。</strong></p>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><ol>
<li>省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。</li>
<li>最大问题是由其共享的本性所导致的。<br> 原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。<br> 对于那些包含基本值的属性倒也说得过去，毕竟，通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。<br> 然而，对于包含引用类型值的属性来说，问题就比较突出了。<br> 实例一般都是要有属于自己的全部属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。</li>
</ol>
<h2 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h2><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。<br>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。<br>结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。<br>另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span> : Person,</div><div class="line">    sayName : function()&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p>
<h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>动态原型模式致力于解决 有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时的困惑。<br>它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型(仅在必要的情况下)，又保持了同时使用构造函数和原型的优点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="comment">//属性</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line"></div><div class="line">    <span class="comment">// 方法</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</div><div class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="keyword">this</span>.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<p>这里只在 sayName() 方法不存在的情况下，才会将它添加到原型中。这<br>段代码只会在初次调用构造函数时才会执行。<br>此后，原型已经完成初始化，不需要再做什么修改了。这里对原型所做的修改，能够立即在所有实例中得到反映。<br>对于采用这种模式创建的对象，还可以使用 instanceof 操作符确定它的类型。</p>
<p>使用动态原型模式时，不能使用对象字面量重写原型。否则会切断现有实例与新原型之间的联系。</p>
<h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><p>在前述的几种模式都不适用的情况下，可以使用寄生(parasitic)构造函数模式。<br>基本思想：<br>创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；<br>但从表面上看，这个函数又很像是典型的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName(); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。<br>返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。<br>为此，不能依赖 instanceof 操作符来确定对象类型。<br>(所以面对的问题也是一样的：对象识别问题、函数实例化问题)<br>所以建议在可以使用其他模式的情况下，不要使用这种模式。</p>
<p>使用示例：<br>可以在特殊的情况下用来为对象创建构造函数。<br>假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//创建数组</span></div><div class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    <span class="comment">//添加值</span></div><div class="line">    values.push.apply(values, <span class="built_in">arguments</span>);</div><div class="line">    <span class="comment">//添加方法</span></div><div class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//返回数组</span></div><div class="line">    <span class="keyword">return</span> values;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</div><div class="line">alert(colors.toPipedString()); <span class="comment">//"red|blue|green"</span></div></pre></td></tr></table></figure>
<h2 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h2><p>道格拉斯·克罗克福德(Douglas Crockford)发明了 JavaScript 中的稳妥对象(durable objects)这个概念。<br>指的是没有公共属性，而且其方法也不引用 this 的对象。<br>稳妥对象最适合在一些安全的环境中(这些环境中会禁止使用 this 和 new )，或者在防止数据被其他应用程序(如 Mashup 程序)改动时使用。</p>
<p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：<br>一是新创建对象的实例方法不引用 this ；<br>二是不使用 new 操作符调用构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="comment">//创建要返回的对象</span></div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line">    <span class="comment">//可以在这里定义私有变量和函数</span></div><div class="line">    <span class="comment">//公共变量：</span></div><div class="line">    <span class="comment">//this.name = name;</span></div><div class="line">    <span class="comment">//私有变量：</span></div><div class="line">    <span class="comment">//var name = name;</span></div><div class="line">    <span class="comment">//一般来说加下划线的变量为私有变量,这是常规都比较遵守的一种代码规范。</span></div><div class="line">    <span class="comment">//var _name = name;</span></div><div class="line"></div><div class="line">    <span class="comment">//添加方法</span></div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//返回对象</span></div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName(); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>变量 friend 中保存的是一个稳妥对象，除了使用 sayName() 方法之外，没有其他办法访问 name 的值。</p>
<p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有意义。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第六章-1]]></title>
      <url>http://codingme.xyz/2016/09/20/javascript-note-6-1/</url>
      <content type="html"><![CDATA[<h1 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h1><p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”<br>严格来讲，这就相当于说对象是一组没有特定顺序的值。<br>对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。<br>我们可以把 ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。<br>每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员定义的类型。</p>
<p>创建自定义对象最简单方式就是创建一个 Object 的实例，然后再为它添加属性和方法。<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"Nicholas"</span>;</div><div class="line">person.age = <span class="number">29</span>;</div><div class="line">person.job = <span class="string">"Software Engineer"</span>;</div><div class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*早期 JavaScript 开发人员经常用这种模式创建新对象，</span></div><div class="line">几年后，对象字面量成为创建这种对象的首选模式。</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">name: <span class="string">"Nicholas"</span>,</div><div class="line">age: <span class="number">29</span>,</div><div class="line">job: <span class="string">"Software Engineer"</span>,</div><div class="line">sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些属性在创建时都带有一些特征值(characteristic)， JavaScript 通过这些特征值来定义它们的行为。</p>
<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><p>ECMAScript 中有两种属性：数据属性和访问器属性。</p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的特性。</p>
<ol>
<li>[[Configurable]] ：(能否被配置)<br> 表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。<br> 像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true 。</li>
<li>[[Enumerable]] ：(能否被枚举)<br> 表示能否通过 for-in 循环返回属性。<br> 像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true 。</li>
<li>[[Writable]] ：(能否被修改)<br> 表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，<br> 它们的这个特性默认值为 true 。</li>
<li>[[Value]] ：(数据值)<br> 包含这个属性的数据值。读取属性值的时候，从这个位置读；<br> 写入属性值的时候，把新值保存在这个位置。<br> 这个特性的默认值为 undefined 。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    name: <span class="string">"Nicholas"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里创建了一个名为 name 的属性，为它指定的值是 “Nicholas” 。<br>也就是说， [[Value]] 特性将被设置为 “Nicholas” ，而对这个值的任何修改都将反映在这个位置。<br>要修改属性默认的特性，必须使用 ECMAScript 5 的 Object.defineProperty() 方法。<br>这个方法接收三个参数：<strong>属性所在的对象</strong>、<strong>属性的名字</strong>和<strong>一个描述符对象</strong>。<br>其中，描述符(descriptor)对象的属性必须是： configurable 、 enumerable 、 writable 和 value 。<br>设置其中的一或多个值，可以修改对应的特性值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">这个例子创建了一个名为 name 的属性，它的值 "Nicholas" 是只读的。这个属性的值是不可修改</div><div class="line">的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导</div><div class="line">致抛出错误。</div><div class="line">*/</div><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">    writable: <span class="literal">false</span>,</div><div class="line">    value: <span class="string">"Nicholas"</span></div><div class="line">&#125;);</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div><div class="line">person.name = <span class="string">"Greg"</span>;</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>可以多次调用 Object.defineProperty() 方法修改同一个属性，但在把 configurable 特性设置为 false 之后就会有限制了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">    configurable: <span class="literal">false</span>,</div><div class="line">    value: <span class="string">"Nicholas"</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//抛出错误</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">    configurable: <span class="literal">true</span>,</div><div class="line">    value: <span class="string">"Nicholas"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在调用 Object.defineProperty() 方法时，<br>如果不指定， configurable 、 enumerable 和 writable 特性的默认值都是 false 。<br>多数情况下，可能都没有必要利用 Object.defineProperty()方法提供的这些高级功能。</p>
<p>IE 的 BUG ： IE8 是第一个实现 Object.defineProperty() 方法的浏览器版本。<br>然而由于实现不彻底，建议不要在 IE8 中使用 Object.defineProperty()方法。</p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数(不过，这两个函数都不是必需的)。<br>在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；<br>在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。<br>访问器属性有如下 4 个特性。</p>
<ol>
<li>[[Configurable]] ：<br> 表示能否通过 delete 删除属性从而重新定义属性，<br> 能否修改属性的特性，或者能否把属性修改为数据属性。<br> 对于直接在对象上定义的属性，这个特性的默认值为 true 。</li>
<li>[[Enumerable]] ：<br> 表示能否通过 for-in 循环返回属性。<br> 对于直接在对象上定义的属性，这个特性的默认值为 true 。</li>
<li>[[Get]] ：<br> 在读取属性时调用的函数。默认值为 undefined 。</li>
<li>[[Set]] ：<br> 在写入属性时调用的函数。默认值为 undefined 。</li>
</ol>
<p>访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    _year: <span class="number">2004</span>,</div><div class="line">    edition: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">            <span class="keyword">this</span>._year = newValue;</div><div class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。<br>setter 函数通过计算来确定正确的版本。因此，把 year 属性修改为 2005 会导致 _year 变成 2005，而 edition 变为 2。<br>这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。</p>
<p>不一定非要同时指定 getter 和 setter 。只指定 getter 意味着属性是不能写，尝试写入属性会被忽略。<br>在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。<br>类似地，只指定 setter 函数的属性也不能读，否则在非严格模式下会返回 undefined ，而在严格模式下会抛出错误。<br>支持 ECMAScript 5 的这个方法的浏览器有 IE9+(IE8 只是部分实现)、 Firefox 4+ 、 Safari 5+ 、 Opera 12+和 Chrome 。<br>在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：<br><code>__defineGetter__()</code> 和 <code>__defineSetter__()</code>。<br>这两个方法最初是由 Firefox 引入的，后来 Safari 3 、 Chrome 1和 Opera 9.5 也给出了相同的实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    _year: <span class="number">2004</span>,</div><div class="line">    edition: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 定义访问器的旧有方法</span></div><div class="line">book.__defineGetter__(<span class="string">"year"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">&#125;);</div><div class="line">book.__defineSetter__(<span class="string">"year"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">        <span class="keyword">this</span>._year = newValue;</div><div class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>在 不 支 持 Object.defineProperty() 方 法 的 浏 览 器 中 不 能 修 改 [[Configurable]] 和[[Enumerable]] 。</p>
<h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>支持 Object.defineProperties() 方法的浏览器有 IE9+ 、 Firefox 4+ 、 Safari 5+ 、 Opera 12+和 Chrome 。<br>由于为对象定义多个属性的可能性很大， ECMAScript 5 又定义了一个 Object.defineProperties() 方法。<br>利用这个方法可以通过描述符一次定义多个属性。<br>这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</div><div class="line">    _year: &#123;</div><div class="line">        value: <span class="number">2004</span></div><div class="line">    &#125;,</div><div class="line">    edition: &#123;</div><div class="line">        value: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    year: &#123;</div><div class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">        &#125;,</div><div class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</div><div class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">                <span class="keyword">this</span>._year = newValue;</div><div class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法，可以取得给定属性的描述<br>符。<br>这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。<br>返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable 、 enumerable 、 get 和 set ；<br>如果是数据属性，这个对象的属性有 configurable 、 enumerable 、 writable 和 value 。<br>在 JavaScript 中，可以针对任何对象——包括 DOM 和 BOM 对象，使用 Object.getOwnPropertyDescriptor() 方法。<br>支持这个方法的浏览器有 IE9+、 Firefox 4+ 、 Safari 5+ 、 Opera 12+和 Chrome 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</div><div class="line">alert(descriptor.value); <span class="comment">//2004</span></div><div class="line">alert(descriptor.configurable); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>对于数据属性 _year ， value 等于最初的值， configurable 是 false ，而 get 等于 undefined 。<br>对于访问器属性 year ， value 等于 undefined ， enumerable 是 false ，而 get 是一个指向 getter 函数的指针。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第五章-5]]></title>
      <url>http://codingme.xyz/2016/09/20/javascript-note-5-5/</url>
      <content type="html"><![CDATA[<h1 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h1><p>内置对象的定义是：“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。”<br>开发人员不必显式地实例化内置对象，因为它们已经实例化了。<br>大多数内置对象，例如 Object 、 Array 和 String 。<br>ECMA-262 还定义了两个单体内置对象： Global 和 Math 。</p>
<h2 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h2><p>Global (全局)对象可以说是 ECMAScript 中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。<br>ECMAScript 中的 Global 对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。<br>换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。<br><strong>事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。</strong></p>
<p>诸如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat() ，实际上全都是 Global 对象的方法。<br>除此之外， Global 对象还包含其他一些方法。</p>
<a id="more"></a>
<h3 id="URI-编码方法"><a href="#URI-编码方法" class="headerlink" title="URI 编码方法"></a>URI 编码方法</h3><p>encodeURI() 和 encodeURIComponent() 方法。<br>这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。</p>
<p>encodeURI() 主要用于整个 URI(例如，<a href="http://www.wrox.com/illegalvalue.htm/" target="_blank" rel="external">http://www.wrox.com/illegalvalue.htm/</a>)，<br>而 encode-URIComponent() 主要用于对 URI 中的某一段(例如前面 URI 中的 illegal value.htm )进行编码。</p>
<p>主要区别在于， encodeURI() 不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；<br>而 encodeURIComponent() 则会对它发现的任何非标准字符进行编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> uri = <span class="string">"http://www.wrox.com/illegal value.htm#start"</span>;</div><div class="line"><span class="comment">//"http://www.wrox.com/illegal%20value.htm#start"</span></div><div class="line">alert(<span class="built_in">encodeURI</span>(uri));</div><div class="line"><span class="comment">//"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span></div><div class="line">alert(<span class="built_in">encodeURIComponent</span>(uri));</div></pre></td></tr></table></figure>
<p>一般来说，我们使用 encodeURIComponent() 方法的时候要比使用 encodeURI() 更多，<br>因为在实践中更常见的是对查询字符串参数而不是对基础 URI 进行编码。</p>
<p>与 encodeURI() 和 encodeURIComponent() 方法对应的两个方法分别是 decodeURI() 和 decodeURIComponent() 。<br>decodeURI() 只能对使用 encodeURI() 替换的字符进行解码。<br>例如，它可将 <code>%20</code> 替换成一个空格，但不会对 <code>%23</code> 作任何处理，因为 <code>%23</code> 表示井字号( # )，而井字号不是使用 encodeURI() 替换的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> uri = <span class="string">"http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start"</span>;</div><div class="line"><span class="comment">//http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start</span></div><div class="line">alert(<span class="built_in">decodeURI</span>(uri));</div><div class="line"><span class="comment">//http://www.wrox.com/illegal value.htm#start</span></div><div class="line">alert(<span class="built_in">decodeURIComponent</span>(uri));</div></pre></td></tr></table></figure>
<p>URI 方法 encodeURI() 、 encodeURIComponent() 、 decodeURI() 和 decodeURIComponent() 用于替代已经被 ECMA-262 第3版废弃的 escape() 和 unescape()方法。<br>URI 方法能够编码所有 Unicode 字符，而原来的方法只能正确地编码 ASCII 字符。<br>因此在开发实践中，特别是在产品级的代码中，一定要使用 URI 方法，不要使用 escape()和 unescape() 方法。</p>
<h3 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval() 方法"></a>eval() 方法</h3><p>大概是整个 ECMAScript 语言中最强大的一个方法： eval() 。<br>eval()方法就像是一个完整的 ECMAScript 解析器，<br>它只接受一个参数，即要执行的 ECMAScript (或 JavaScript)字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"alert('hi')"</span>);</div><div class="line"><span class="comment">//等价于</span></div><div class="line">alert(<span class="string">"hi"</span>);</div></pre></td></tr></table></figure>
<p>当解析器发现代码中调用 eval() 方法时，它会将传入的参数当作实际的 ECMAScript 语句来解析，然后把执行结果插入到原位置。<br>通过 eval() 执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。<br>这意味着通过 eval() 执行的代码可以引用在包含环境中定义的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">eval</span>(<span class="string">"alert(msg)"</span>); <span class="comment">//"hello world"</span></div><div class="line"></div><div class="line"><span class="built_in">eval</span>(<span class="string">"function sayHi() &#123; alert('hi'); &#125;"</span>);</div><div class="line">sayHi();</div><div class="line"></div><div class="line"><span class="built_in">eval</span>(<span class="string">"var msg = 'hello world'; "</span>);</div><div class="line">alert(msg); <span class="comment">//"hello world"</span></div></pre></td></tr></table></figure>
<p>在 eval() 中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；<br>它们只在 eval() 执行的时候创建。<br>严格模式下，在外部访问不到 eval() 中创建的任何变量或函数,为 eval 赋值也会导致错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="built_in">eval</span> = <span class="string">"hi"</span>; <span class="comment">//causes error</span></div></pre></td></tr></table></figure>
<p>要点：能够解释代码字符串的能力非常强大，但也非常危险。因此在使用 eval() 时必须极为谨慎，<br>特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码(即所谓的代码注入)。</p>
<h3 id="Global-对象的属性"><a href="#Global-对象的属性" class="headerlink" title="Global 对象的属性"></a>Global 对象的属性</h3><pre><code>undefined   Date            NaN
RegExp      Infinity        Error
Object      EvalError       Array
RangeError  Function        ReferenceError
Boolean     SyntaxError     String
TypeError   Number          URIError
</code></pre><p>ECMAScript 5 明确禁止给 undefined 、 NaN 和 Infinity 赋值，这样做即使在非严格模式下也会导致错误。</p>
<h3 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h3><p>ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。<br>因此，在全局作用域中声明的所有变量和函数，就都成为了 window 对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="built_in">window</span>.color);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.sayColor(); <span class="comment">//"red"</span></div></pre></td></tr></table></figure>
<p>JavaScript 中的 window 对象除了扮演 ECMAScript 规定的 Global 对象的角色外，还承担了很多别的任务。</p>
<p>另一种取得 Global 对象的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<h2 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h2><h3 id="Math-对象的属性"><a href="#Math-对象的属性" class="headerlink" title="Math 对象的属性"></a>Math 对象的属性</h3><pre><code>属性          说明
Math.E          自然对数的底数，即常量 e 的值
Math.LN10       10的自然对数
Math.LN2        2的自然对数
Math.LOG2E      以2为底 e 的对数
Math.LOG10E     以10为底 e 的对数
Math.PI         π的值
Math.SQRT1_2    1/2的平方根(即2的平方根的倒数)
Math.SQRT2      2的平方根
</code></pre><h3 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min() 和 max() 方法"></a>min() 和 max() 方法</h3><p>这两个方法经常用于避免多余的循环和在 if 语句中确定一组数的最大值。<br>要找到数组中的最大或最小值，可以像下面这样使用 apply() 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</div><div class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</div></pre></td></tr></table></figure>
<h3 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h3><p>Math.ceil() 执行向上舍入，即它总是将数值向上舍入为最接近的整数；<br>Math.floor() 执行向下舍入，即它总是将数值向下舍入为最接近的整数；<br>Math.round() 执行标准舍入，即它总是将数值四舍五入为最接近的整数(这也是我们在数学课上学到的舍入规则)。</p>
<h3 id="random-方法"><a href="#random-方法" class="headerlink" title="random() 方法"></a>random() 方法</h3><p><code>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</code><br>想选择一个 1到 10 之间的数值的话，<br><code>var num = Math.floor(Math.random() * 10 + 1);</code><br>想要选择一个介于 2 到 10 之间的值的话,<br><code>var num = Math.floor(Math.random() * 9 + 2);</code></p>
<p>也可以写成函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> choices = upperValue - lowerValue + <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lowerValue);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> num = selectFrom(<span class="number">2</span>, <span class="number">10</span>);</div><div class="line">alert(num); <span class="comment">// 介于 2 和 10 之间(包括 2 和 10)的一个数值</span></div></pre></td></tr></table></figure>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><pre><code>Math.abs(num)           返回 num 的绝对值
Math.asin(x)            返回 x 的反正弦值
Math.exp(num)           返回 Math.E 的 num 次幂
Math.atan(x)            返回 x 的反正切值
Math.log(num)           返回 num 的自然对数
Math.atan2(y,x)         返回 y/x 的反正切值
Math.pow(num,power)     返回 num 的 power 次幂
Math.cos(x)             返回 x 的余弦值
Math.sqrt(num)          返回 num 的平方根
Math.sin(x)             返回 x 的正弦值
Math.acos(x)            返回 x 的反余弦值
Math.tan(x)             返回 x 的正切值
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第五章-4]]></title>
      <url>http://codingme.xyz/2016/09/20/javascript-note-5-4/</url>
      <content type="html"><![CDATA[<h1 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h1><p>为了便于操作基本类型值， ECMAScript 还提供了 3 个特殊的引用类型： Boolean 、 Number 和 String 。<br>这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。<br>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</div><div class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">//等同于</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</div><div class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</div><div class="line">s1 = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>后台操作：<br>(1) 创建 String 类型的一个实例；<br>(2) 在实例上调用指定的方法；<br>(3) 销毁这个实例。<br>这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。<br><a id="more"></a><br>引用类型与基本包装类型的主要区别就是对象的生存期。<br>要点：<strong>引用类型与基本包装类型的主要区别就是对象的生存期。</strong><br>使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。<br>而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</div><div class="line">s1.color = <span class="string">"red"</span>;</div><div class="line">alert(s1.color); <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了。<br>第三行代码又创建自己的 String 对象，而该对象没有 color 属性。</p>
<p>当然，可以显式地调用 Boolean 、 Number 和 String 来创建基本包装类型的对象。<br>不过，应该在绝对必要的情况下再这样做，<br>因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。<br>对基本包装类型的实例调用 typeof 会返回 “object” ，<br>而且所有基本包装类型的对象都会被转换为布尔值 true 。</p>
<p>Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);</div><div class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>使用 new 调用<strong>基本包装类型的构造函数</strong>，与直接调用同名的<strong>转型函数</strong>是不一样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</div><div class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">//转型函数</span></div><div class="line">alert(<span class="keyword">typeof</span> number); <span class="comment">//"number"</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数</span></div><div class="line">alert(<span class="keyword">typeof</span> obj); <span class="comment">//"object"</span></div></pre></td></tr></table></figure>
<p>变量 number 中保存的是基本类型的值 25，而变量 obj 中保存的是 Number 的实例。</p>
<h2 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><p><code>var booleanObject = new Boolean(true);</code><br>Boolean 类型的实例重写了 valueOf() 方法，返回基本类型值 true 或 false ；<br>重写了 toString()方法，返回字符串 “true” 和 “false” 。<br>可是 Boolean 对象在 ECMAScript 中的用处不大，因为它经常会造成人们的误解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</div><div class="line">alert(result); <span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> falseValue = <span class="literal">false</span>;</div><div class="line">result = falseValue &amp;&amp; <span class="literal">true</span>;</div><div class="line">alert(result); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(<span class="keyword">typeof</span> falseObject); <span class="comment">//object</span></div><div class="line">alert(<span class="keyword">typeof</span> falseValue); <span class="comment">//boolean</span></div><div class="line">alert(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></div><div class="line">alert(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>理解基本类型的布尔值与 Boolean 对象之间的区别非常重要<br>——当然，我们的建议是<strong>永远不要使用 Boolean 对象。</strong></p>
<h2 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h2><p><code>var numberObject = new Number(10);</code></p>
<p>Number 类型也重写了 valueOf() 、 toLocaleString() 和 toString()方法。<br>重写后的 valueOf() 方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。<br>还可以为 toString() 方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。<br>除了继承的方法之外， Number 类型还提供了一些用于将数值格式化为字符串的方法。</p>
<h3 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed()"></a>toFixed()</h3><p>toFixed() 方法会按照指定的小数位返回数值的字符串表示。<br>toFixed()方法能够自动舍入，还能填补必要的小数位。</p>
<p>IE 的小 BUG :在给 toFixed() 传入 0 的情况下， IE8 及之前版本不能正确舍入范围在{(-0.94,-0.5],[0.5,0.94)}之间的值。<br>对于这个范围内的值， IE 会返回 0，而不是-1 或 1；<br>其他浏览器都能返回正确的值。 IE9 修复了这个问题。</p>
<h3 id="toExponential"><a href="#toExponential" class="headerlink" title="toExponential()"></a>toExponential()</h3><p>该方法返回以指数表示法(也称 e 表示法)表示的数值的字符串形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toExponential(<span class="number">1</span>)); <span class="comment">//"1.0e+1"</span></div></pre></td></tr></table></figure>
<h3 id="toPrecision"><a href="#toPrecision" class="headerlink" title="toPrecision()"></a>toPrecision()</h3><p>可能会返回固定大小(fixed)格式，也可能返回指数(exponential)格式；<br>具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数(不包括指数部分)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">99</span>;</div><div class="line">alert(num.toPrecision(<span class="number">1</span>)); <span class="comment">//"1e+2"</span></div><div class="line">alert(num.toPrecision(<span class="number">2</span>)); <span class="comment">//"99"</span></div><div class="line">alert(num.toPrecision(<span class="number">3</span>)); <span class="comment">//"99.0"</span></div></pre></td></tr></table></figure>
<p>因为一位数无法准确地表示 99，因此 toPrecision() 就将它向上舍入为 100,结果是 “1e+2”。<br>实际上， toPrecision() 会根据要处理的数值决定到底是调用 toFixed() 还是调用 toExponential() 。<br>而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。<br>toPrecision() 方法可以表现 1 到 21 位小数。某些浏览器支持的范围更大，但这是典型实现的范围。</p>
<p>不建议直接实例化 Number 类型，而原因与显式创建 Boolean 对象一样。<br>在使用 typeof 和 instanceof 操作符测试基本类型数值与引用类型数值时，得到的结果完全不同。</p>
<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p><code>var stringObject = new String(&quot;hello world&quot;);</code></p>
<p>length 属性即使字符串中包含双字节字符(不是占一个字节的 ASCII 字符)，每个字符也仍然算一个字符。<br>String 类型提供了很多方法，用于辅助完成对 ECMAScript 中字符串的解析和操作。</p>
<h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>charAt() 和 charCodeAt() 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line">alert(stringValue.charAt(<span class="number">1</span>)); <span class="comment">//"e"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line">alert(stringValue.charCodeAt(<span class="number">1</span>)); <span class="comment">// 输出"101"</span></div></pre></td></tr></table></figure>
<p><strong>ECMAScript 5</strong>还定义了另一个访问个别字符的方法。(兼容性问题…)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line">alert(stringValue[<span class="number">1</span>]); <span class="comment">//"e"</span></div></pre></td></tr></table></figure>
<h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><p>concat() ，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。跟 Array 的方法等同。<br>虽然 concat() 是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符(+)。<br>而且，使用加号操作符在大多数情况下都比使用 concat()方法要简便易行(特别是在拼接多个字符串的情况下)。</p>
<p>ECMAScript 还提供了三个基于子字符串创建新字符串的方法： slice() 、 substr() 和 substring() 。<br>这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。<br>第一个参数指定子字符串的开始位置，第二个参数(在指定的情况下)表示子字符串到哪里结束。<br>它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。</p>
<h4 id="slice-和-substr-、-substring-的区别"><a href="#slice-和-substr-、-substring-的区别" class="headerlink" title="slice() 和 substr()、 substring() 的区别"></a>slice() 和 substr()、 substring() 的区别</h4><p>当传入参数是非负数时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ar stringValue = <span class="string">"hello world"</span>;</div><div class="line">alert(stringValue.slice(<span class="number">3</span>));</div><div class="line"><span class="comment">//"lo world"</span></div><div class="line">alert(stringValue.substring(<span class="number">3</span>));</div><div class="line"><span class="comment">//"lo world"</span></div><div class="line">alert(stringValue.substr(<span class="number">3</span>));</div><div class="line"><span class="comment">//"lo world"</span></div><div class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>));</div><div class="line"><span class="comment">//"lo w"</span></div><div class="line">alert(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>));</div><div class="line"><span class="comment">//"lo w"</span></div><div class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>));</div><div class="line"><span class="comment">//"lo worl"  substr() 的第二个参数指定的则是返回的字符个数。</span></div></pre></td></tr></table></figure>
<p>当传入参数是负数时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line">alert(stringValue.slice(<span class="number">-3</span>));</div><div class="line"><span class="comment">//"rld"    slice() 方法会将传入的负值与字符串的长度相加。</span></div><div class="line">alert(stringValue.substring(<span class="number">-3</span>));</div><div class="line"><span class="comment">//"hello world"  substring() 方法会把所有负值参数都转换为 0。</span></div><div class="line">alert(stringValue.substr(<span class="number">-3</span>));</div><div class="line"><span class="comment">//"rld"</span></div><div class="line">alert(stringValue.slice(<span class="number">3</span>, <span class="number">-4</span>));</div><div class="line"><span class="comment">//"lo w"</span></div><div class="line">alert(stringValue.substring(<span class="number">3</span>, <span class="number">-4</span>));</div><div class="line"><span class="comment">//"hel"</span></div><div class="line">alert(stringValue.substr(<span class="number">3</span>, <span class="number">-4</span>));</div><div class="line"><span class="comment">//"" (空字符串) substr() 方法将负的第一个参数加上字符串的长度，</span></div><div class="line"><span class="comment">//而将负的第二个参数转换为 0。</span></div></pre></td></tr></table></figure>
<p>IE 的 BUG :IE 的 JavaScript 实现在处理向 substr() 方法传递负值的情况时存在问题，<br>它会返回原始的字符串。 IE9 修复了这个问题。</p>
<h3 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h3><p>indexOf() 和 lastIndexOf()。<br>都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置(如果没有找到该子字符串，则返回 -1 )。<br>可选的第二个参数，表示从字符串中的哪个位置开始搜索。<br>循环调用 indexOf() 或 lastIndexOf() 来找到所有匹配的子字符串例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"Lorem ipsum dolor sit amet, consectetur adipisicing elit"</span>;</div><div class="line"><span class="keyword">var</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> pos = stringValue.indexOf(<span class="string">"e"</span>);</div><div class="line"><span class="keyword">while</span>(pos &gt; <span class="number">-1</span>)&#123;</div><div class="line">    positions.push(pos);</div><div class="line">    pos = stringValue.indexOf(<span class="string">"e"</span>, pos + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">alert(positions); <span class="comment">//"3,24,32,35,52"</span></div></pre></td></tr></table></figure>
<h3 id="trim-方法-ECMAScript-5"><a href="#trim-方法-ECMAScript-5" class="headerlink" title="trim()方法 (ECMAScript 5)"></a>trim()方法 (ECMAScript 5)</h3><p>这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。<br>支持这个方法的浏览器有 IE9+、 Firefox 3.5+、 Safari 5+、 Opera 10.5+和 Chrome 。<br>此外， Firefox 3.5+、 Safari 5+和 Chrome 8+还支持非标准的 trimLeft() 和 trimRight() 方法，<br>分别用于删除字符串开头和末尾的空格。</p>
<h3 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h3><p>toLowerCase() 、 toLocaleLowerCase() 、 toUpperCase() 和 toLocaleUpperCase()<br>一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。</p>
<h3 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h3><h4 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h4><p>在字符串上调用这个方法，本质上与调用 RegExp 的 exec() 方法相同。<br>只接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象。</p>
<h4 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h4><p>这个方法的唯一参数与 match() 方法的参数相同。<br>search() 方法返回字符串中第一个匹配项的索引；<br>如果没有找到匹配项，则返回 -1 。<br>而且， search() 方法始终是从字符串开头向后查找模式。</p>
<h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace() 方法"></a>replace() 方法</h4><p>这个方法接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串(这个字符串不会被转换成正则表达式)，<br>第二个参数可以是一个字符串或者一个函数。<br>如果第一个参数是字符串，那么只会替换第一个子字符串。<br>要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局( g )标志。</p>
<pre><code>字符序列    替换文本
$$          $
$&amp;          匹配整个模式的子字符串。与 RegExp.lastMatch 的值相同
$&apos;          匹配的子字符串之前的子字符串。与 RegExp.leftContext 的值相同
$`          匹配的子字符串之后的子字符串。与 RegExp.rightContext 的值相同
$n          匹配第 n 个捕获组的子字符串，其中 n 等于0～9。例如， $1 是匹配第一个捕获组的子字符串，$2 是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串
$nn         匹配第 nn 个捕获组的子字符串，其中 nn 等于01～99。例如， $01 是匹配第一个捕获组的子字符串， $02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串
</code></pre><p>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</div><div class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($1)"</span>);</div><div class="line">alert(result); <span class="comment">//word (cat), word (bat), word (sat), word (fat)</span></div></pre></td></tr></table></figure>
<p>replace() 方法的第二个参数也可以是一个函数。<br>只有一个匹配项(即与模式匹配的字符串)的情况下，<br>会向这个函数传递 3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。</p>
<p>在正则表达式中定义了多个捕获组的情况下，<br>传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，<br>但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。<br>这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace() 方法的第二个参数可以实现更加精细的替换操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>)</span>&#123;</div><div class="line"><span class="keyword">switch</span>(match)&#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"&lt;"</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"&amp;lt;"</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"&gt;"</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"&amp;gt;"</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"&amp;"</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"&amp;amp;"</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"\""</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">"&amp;quot;"</span>;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">alert(htmlEscape(<span class="string">"&lt;p class=\"greeting\"&gt;Hello world!&lt;/p&gt;"</span>));</div><div class="line"><span class="comment">//&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;</span></div></pre></td></tr></table></figure>
<h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><p>基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。<br>分隔符可以是字符串，也可以是一个 RegExp 对象(这个方法不会将字符串看成正则表达式)。<br>split() 方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>;</div><div class="line"><span class="keyword">var</span> colors1 = colorText.split(<span class="string">","</span>); <span class="comment">//["red", "blue", "green", "yellow"]</span></div><div class="line"><span class="keyword">var</span> colors2 = colorText.split(<span class="string">","</span>, <span class="number">2</span>); <span class="comment">//["red", "blue"]</span></div><div class="line"><span class="keyword">var</span> colors3 = colorText.split(<span class="regexp">/[^\,]+/</span>); <span class="comment">//["", ",", ",", ",", ""]</span></div></pre></td></tr></table></figure>
<p>在最后一次调用 split() 返回的数组中，第一项和最后一项是两个空字符串。<br>之所以会这样，是因为通过正则表达式指定的分隔符出现在了字符串的开头(即子字符串 “red” )和末尾(即子字符串 “yellow” )。<br>对 split() 中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现匹配项以及带有捕获组的模式，匹配的行为就不大相同了。<br>以下是几种常见的差别。</p>
<p>IE8 及之前版本会忽略捕获组。 ECMA-262 规定应该把捕获组拼接到结果数组中。 IE9 能正确地在结果中包含捕获组。<br>Firefox 3.6 及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串； ECMA-262 规定没有匹配项的捕获组在结果数组中应该用 undefined 表示。</p>
<p>参考：要了解关于 split() 方法以及捕获组的跨浏览器问题的更多讨论，请参考 StevenLevithan 的文章<br>“ JavaScript split bugs ： Fixed!”(<a href="http://blog.stevenlevithan.com/archives/cross-browser-split/" target="_blank" rel="external">http://blog.stevenlevithan.com/archives/cross-browser-split/</a>)。</p>
<h3 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a>localeCompare() 方法</h3><p>这个方法比较两个字符串，并返回下列值中的一个:</p>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数(大多数情况下是 -1 ，具体的值要视实现而定)；</li>
<li>如果字符串等于字符串参数，则返回 0 ；</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数(大多数情况下是 1 ，具体的值同样要视实现而定)。</li>
</ul>
<p>因为 localeCompare() 返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineOrder</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = stringValue.localeCompare(value);</div><div class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)&#123;</div><div class="line">        alert(<span class="string">"The string 'yellow' comes before the string '"</span> + value + <span class="string">"'."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</div><div class="line">        alert(<span class="string">"The string 'yellow' comes after the string '"</span> + value + <span class="string">"'."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        alert(<span class="string">"The string 'yellow' is equal to the string '"</span> + value + <span class="string">"'."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">determineOrder(<span class="string">"brick"</span>);</div><div class="line">determineOrder(<span class="string">"yellow"</span>);</div><div class="line">determineOrder(<span class="string">"zoo"</span>);</div></pre></td></tr></table></figure>
<p>localeCompare() 方法比较与众不同的地方，就是实现所支持的地区(国家和语言)决定了这个方法的行为。<br>比如，美国以英语作为 ECMAScript 实现的标准语言，因此 localeCompare() 就是区分大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。<br>不过，在其他地区恐怕就不是这种情况了。</p>
<h3 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode() 方法"></a>fromCharCode() 方法</h3><p>静态方法,任务是接收一或多个字符编码，然后将它们转换成一个字符串。<br>从本质上来看，这个方法与实例方法 charCodeAt()执行的是相反的操作。<br><code>alert(String.fromCharCode(104, 101, 108, 108, 111)); //&quot;hello&quot;</code></p>
<h3 id="HTML-方法"><a href="#HTML-方法" class="headerlink" title="HTML 方法"></a>HTML 方法</h3><p>应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。</p>
<pre><code>方 法     输出结果
anchor(name)        &lt;a name= &quot;name&quot;&gt;string&lt;/a&gt;
big()               &lt;big&gt;string&lt;/big&gt;
bold()              &lt;b&gt;string&lt;/b&gt;
fixed()             &lt;tt&gt;string&lt;/tt&gt;
fontcolor(color)    &lt;font color=&quot;color&quot;&gt;string&lt;/font&gt;
fontsize(size)      &lt;font size=&quot;size&quot;&gt;string&lt;/font&gt;
italics()           &lt;i&gt;string&lt;/i&gt;
link(url)           &lt;a href=&quot;url&quot;&gt;string&lt;/a&gt;
small()             &lt;small&gt;string&lt;/small&gt;
strike()            &lt;strike&gt;string&lt;/strike&gt;
sub()               &lt;sub&gt;string&lt;/sub&gt;
sup()               &lt;sup&gt;string&lt;/sup&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第五章-3]]></title>
      <url>http://codingme.xyz/2016/09/19/javascript-note-5-3/</url>
      <content type="html"><![CDATA[<h1 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h1><p>ECMAScript 中最有意思的是函数——因为函数实际上是对象。<br>JavaScript 最有特色的地方。<br>每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。<br>由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*等同于*/</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>); <span class="comment">// 不推荐</span></div></pre></td></tr></table></figure>
<p>在使用函数表达式定义函数时，没有必要使用函数名——通过变量 sum 即可以引用函数。<br>另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。<br>最后一种定义函数的方式是使用 Function 构造函数。<br>但是不推荐这种方法定义函数，因为这种语法会导致解析两次代码(第一次是解析常规 ECMAScript 代码，第二次是解析传入构造函数中的字符串)，从而影响性能。</p>
<p>使用不带圆括号的函数名是访问函数指针，而非调用函数。<br><a id="more"></a></p>
<h2 id="没有重载-深入理解"><a href="#没有重载-深入理解" class="headerlink" title="没有重载(深入理解)"></a>没有重载(深入理解)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">100</span>;</div><div class="line">&#125;;</div><div class="line">addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">200</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></div></pre></td></tr></table></figure>
<p>在创建第二个函数时，实际上覆盖了引用第一个函数的变量 addSomeNumber 。</p>
<h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><p>实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。<br>解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问)；<br>至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码完全可以正常运行。<br>因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升(function declaration hoisting)的过程，<br>读取并将函数声明添加到执行环境中。<br>对代码求值时， JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。<br>下面的例子则会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>原因在于函数位于一个初始化语句中，而不是一个函数声明。<br>换句话说，在执行到函数所在的语句之前，变量 sum 中不会保存有对函数的引用；<br>而且，由于第一行代码就会导致“ unexpected identifier ”(意外标识符)错误，实际上也不会执行到下一行。</p>
<p>除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。</p>
<p>Safari 中同时使用函数声明和函数表达式会导致错误。</p>
<h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> someFunction(someArgument);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result1 = callSomeFunction(add10, <span class="number">10</span>);</div><div class="line">alert(result1); <span class="comment">//20</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> result2 = callSomeFunction(getGreeting, <span class="string">"Nicholas"</span>);</div><div class="line">alert(result2); <span class="comment">//"Hello, Nicholas"</span></div></pre></td></tr></table></figure>
<p>要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。</p>
<p>例子2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">    <span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">    <span class="keyword">if</span> (value1 &lt; value2)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = [&#123;name: <span class="string">"Zachary"</span>, age: <span class="number">28</span>&#125;, &#123;name: <span class="string">"Nicholas"</span>, age: <span class="number">29</span>&#125;];</div><div class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));</div><div class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Nicholas</span></div><div class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</div><div class="line">alert(data[<span class="number">0</span>].name); <span class="comment">//Zachary</span></div></pre></td></tr></table></figure>
<h2 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h2><p>arguments 和 this 。</p>
<h3 id="arguments-的-callee"><a href="#arguments-的-callee" class="headerlink" title="arguments 的 callee"></a>arguments 的 callee</h3><p>arguments 的 callee 的属性是一个指针，指向拥有这个 arguments 对象的函数。<br>当函数在严格模式下运行时，访问 arguments.callee 会导致错误。<br>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*阶乘函数。问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">使用 arguments.callee 消除这种紧密耦合的现象。</div><div class="line">这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">变量 trueFactorial 获得了 factorial 的值，实际上是在另一个位置上保存了一个函数的指针。</div><div class="line">又将一个简单地返回 0 的函数赋值给 factorial 变量。</div><div class="line">在解除了函数体内的代码与函数名的耦合状态之后， trueFactorial() 仍然能够正常地计算阶乘。</div><div class="line">*/</div><div class="line"><span class="keyword">var</span> trueFactorial = factorial;</div><div class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line">alert(trueFactorial(<span class="number">5</span>)); <span class="comment">//120</span></div><div class="line">alert(factorial(<span class="number">5</span>)); <span class="comment">//0</span></div></pre></td></tr></table></figure>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 引用的是函数据以执行的环境对象。<br>(当在网页的全局作用域中调用函数时， this 对象引用的就是 window )。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; color: <span class="string">"blue"</span> &#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor(); <span class="comment">//"red"</span></div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor(); <span class="comment">//"blue"</span></div></pre></td></tr></table></figure>
<p>要点：<strong>函数的名字仅仅是一个包含指针的变量而已。</strong></p>
<h3 id="caller-ECMAScript5"><a href="#caller-ECMAScript5" class="headerlink" title="caller(ECMAScript5)"></a>caller(ECMAScript5)</h3><p>ECMAScript 5 也规范化了另一个函数对象的属性： caller 。 ECMAScript 3 并没有定义。<br>这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null 。<br>ECMAScript 5 还定义了 arguments.caller 属性，但在严格模式下访问它也会导致错误，<br>而在非严格模式下这个属性始终是 undefined 。定义这个属性是为了分清 arguments.caller 和函数的 caller 属性。<br>以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。<br>严格模式还有一个限制：不能为函数的 caller 属性赋值，否则会导致错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    inner();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(inner.caller);</div><div class="line">&#125;</div><div class="line">outer();</div><div class="line"><span class="comment">/*</span></div><div class="line">以上代码会导致警告框中显示 outer() 函数的源代码。</div><div class="line">因为 outer() 调用了 inter() ，所以 inner.caller 就指向 outer() 。</div><div class="line">为了实现更松散的耦合，也可以通过 arguments.callee.caller 来访问相同的信息。</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">inner();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">alert(<span class="built_in">arguments</span>.callee.caller);</div><div class="line">&#125;</div><div class="line">outer();</div></pre></td></tr></table></figure>
<h2 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h2><p>每个函数都包含两个属性： length 和 prototype 。<br>每个函数都包含两个非继承而来的方法： apply() 和 call() 。<br>这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</p>
<h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>length 属性表示函数希望接收的命名参数的个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    alert(name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"hi"</span>);</div><div class="line">&#125;</div><div class="line">alert(sayName.length); <span class="comment">//1</span></div><div class="line">alert(sum.length); <span class="comment">//2</span></div><div class="line">alert(sayHi.length); <span class="comment">//0</span></div></pre></td></tr></table></figure>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味。<br>对于 ECMAScript 中的引用类型而言， prototype 是保存它们所有实例方法的真正所在。<br>换句话说，诸如 toString() 和 valueOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。<br>在创建自定义引用类型以及实现继承时， prototype 属性的作用是极为重要的。<br>在 ECMAScript 5 中， prototype 属性是不可枚举的，因此使用 for-in 无法发现。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p>apply() 方法接收两个参数：一个是<strong>在其中运行函数的作用域</strong>，另一个是<strong>参数数组</strong>。<br>其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入 arguments 对象</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></div><div class="line">&#125;</div><div class="line">alert(callSum1(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div><div class="line">alert(callSum2(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div><div class="line"><span class="comment">/*</span></div><div class="line">callSum1() 在执行 sum() 函数时传入了 this 作为 this 值</div><div class="line">(因为是在全局作用域中调用的，所以传入的就是 window 对象)</div><div class="line">和 arguments 对象。</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>在严格模式下，未指定环境对象而调用函数，则 this 值不会转型为 window 。<br>除非明确把函数添加到某个对象或者调用 apply() 或 call() ，否则 this 值将是 undefined 。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><p>call() 方法与 apply() 方法的作用相同，它们的区别仅在于接收参数的方式不同。<br>对于 call()方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。<br>换句话说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</div><div class="line">&#125;</div><div class="line">alert(callSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></div></pre></td></tr></table></figure>
<h3 id="apply-与-call-的取舍"><a href="#apply-与-call-的取舍" class="headerlink" title="apply() 与 call() 的取舍"></a>apply() 与 call() 的取舍</h3><p>取决于你采取哪种给函数传递参数的方式最方便。<br>如果你打算直接传入 arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用 apply()肯定更方便；<br>否则，选择 call() 可能更合适。<br>(在不给函数传递参数的情况下，使用哪个方法都无所谓。)</p>
<h3 id="apply-与-call-的用武之地"><a href="#apply-与-call-的用武之地" class="headerlink" title="apply() 与 call() 的用武之地"></a>apply() 与 call() 的用武之地</h3><p>它们真正强大的地方是能够扩充函数赖以运行的作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; color: <span class="string">"blue"</span> &#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor(); <span class="comment">//red</span></div><div class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">//red</span></div><div class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></div><div class="line">sayColor.call(o); <span class="comment">//blue</span></div></pre></td></tr></table></figure>
<p>sayColor() 也是作为全局函数定义的,<br>当在全局作用域中调用它时，会显示 “red”。<br>因为对 this.color 的求值会转换成对 window.color 的求值。<br>而 sayColor.call(this) 和 sayColor.call(window) ，<br>则是两种<strong>显式地</strong>在全局作用域中调用函数的方式。<br>当运行 sayColor.call(o)时，函数的执行环境就不一样了，<br>因为此时函数体内的 this 对象指向了 o ，于是结果显示的是 “blue”。</p>
<p>使用 call() (或 apply() )来扩充作用域的最大好处，就是<strong>对象不需要与方法有任何耦合关系</strong>。</p>
<h3 id="bind-ECMAScript5"><a href="#bind-ECMAScript5" class="headerlink" title="bind() (ECMAScript5)"></a>bind() (ECMAScript5)</h3><p>这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; color: <span class="string">"blue"</span> &#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</div><div class="line">objectSayColor(); <span class="comment">//blue</span></div></pre></td></tr></table></figure>
<p>sayColor() 调用 bind() 并传入对象 o ，创建了 objectSayColor() 函数。<br>objectSayColor() 函数的 this 值等于 o 。<br>优点请参考第 22 章。</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>每个函数继承的 toLocaleString() 和 toString() 方法始终都返回函数的代码。<br>返回代码的格式则因浏览器而异。<br>另外一个继承的 valueOf() 方法同样也只返回函数代码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第五章-2]]></title>
      <url>http://codingme.xyz/2016/09/19/javascript-note-5-2/</url>
      <content type="html"><![CDATA[<h1 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h1><p>创建一个 Date 对象，使用 new 操作符和 Date 构造函数即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div></pre></td></tr></table></figure>
<p>在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。<br>如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数。(从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数)<br>了简化这一计算过程， ECMAScript 提供了两个方法： Date.parse()和 Date.UTC() 。<br><a id="more"></a></p>
<ul>
<li>Date.parse() 方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。<br>  ECMA-262 没有定义 Date.parse() 应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。<br>  如果传入 Date.parse() 方法的字符串不能表示日期，那么它会返回 NaN 。<br>  要点：日期对象及其在不同浏览器中的实现有许多奇怪的行为。<br>  在解析 “January 32, 2007”时，有的浏览器会将其解释为 “February 1, 2007” 。<br>  而 Opera 则倾向于插入当前月份的当前日期，返回 “January 当前日期， 2007” 。<br>  如果在 2007 年 9 月21 日运行前面的代码，将会得到 “January 21, 2007” (都是 21 日)。<ul>
<li>“月/日/年”，如 6/13/2004；</li>
<li>“英文月名 日,年”，如 January 12,2004；</li>
<li>“英文星期几 英文月名 日 年 时:分:秒 时区”，如 Tue May 25 2004 00:00:00 GMT-0700。</li>
<li>ISO 8601 扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ(例如 2004-05-25T00:00:00)。只有兼容 ECMAScript5 的实现支持这种格式。<br>实际上，如果直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 Date.parse() 。<br><code>var someDate = new Date(&quot;May 25, 2004&quot;);</code>等同于<code>var someDate = new Date(Date.parse(&quot;May 25, 2004&quot;));</code></li>
</ul>
</li>
<li><p>Date.UTC() 方法同样也返回表示日期的毫秒数。<br>  Date.UTC() 的参数分别是年份、基于 0 的月份(一月是 0，二月是 1，以此类推)、月中的哪一天(1 到 31)、小时数(0 到 23)、分钟、秒以及毫秒数。<br>  在这些参数中，只有前两个参数(年和月)是必需的。<br>  如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// GMT 时间 2000 年 1 月 1 日午夜零时</span></div><div class="line"><span class="keyword">var</span> y2k = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>));</div><div class="line"><span class="comment">// GMT 时间 2005 年 5 月 5 日下午 5:55:55</span></div><div class="line"><span class="keyword">var</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</div></pre></td></tr></table></figure>
<p>  如同模仿 Date.parse() 一样， Date 构造函数也会模仿 Date.UTC() ，但有一点明显不同：日期和时间都基于本地时区而非 GMT 来创建。<br>  <code>var allFives = new Date(2005, 4, 5, 17, 55, 55);</code>等同于<code>var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));</code></p>
</li>
<li><p>Data.now() 方法， ECMAScript 5 添加,返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用 Data 对象分析代码的工作。例如：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得开始时间</span></div><div class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</div><div class="line"><span class="comment">//调用函数</span></div><div class="line">doSomething();</div><div class="line"><span class="comment">//取得停止时间</span></div><div class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now(),</div><div class="line">result = stop – start;</div></pre></td></tr></table></figure>
<p>  在不支持它的浏览器中，使用+操作符把 Data 对象转换成字符串，也可以达到同样的目的。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得开始时间</span></div><div class="line"><span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="comment">//调用函数</span></div><div class="line">doSomething();</div><div class="line"><span class="comment">//取得停止时间</span></div><div class="line"><span class="keyword">var</span> stop = +<span class="keyword">new</span> <span class="built_in">Date</span>(),</div><div class="line">result = stop - start;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>Date 类型也重写了 toLocaleString() 、 toString() 和 valueOf() 方法。<br>在不同浏览器中调用 toLocaleString() 和 toString() 方法，返回的日期和时间格式可谓大相径庭。<br>事实上， toLocaleString() 和 toString() 的这一差别仅在调试代码时比较有用，而在显示日期和时间时没有什么价值。<br>Date 类型的 valueOf() 方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符(小于或大于)来比较日期值。</p>
<h2 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h2><ul>
<li>toDateString() ——以特定于实现的格式显示星期几、月、日和年；</li>
<li>toTimeString() ——以特定于实现的格式显示时、分、秒和时区；</li>
<li>toLocaleDateString() ——以特定于地区的格式显示星期几、月、日和年；</li>
<li>toLocaleTimeString() ——以特定于实现的格式显示时、分、秒；</li>
<li>toUTCString() ——以特定于实现的格式完整的 UTC 日期。</li>
</ul>
<p>与 toLocaleString() 和 toString() 方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。<br>还有一个名叫 toGMTString() 的方法，这是一个与 toUTCString() 等价的方法，其存在目的在于确保向后兼容。<br>不过， ECMAScript 推荐现在编写的代码一律使用 toUTCString() 方法。</p>
<h2 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h2><ul>
<li>getTime()：    返回表示日期的毫秒数；与 valueOf() 方法返回的值相同</li>
<li>setTime( 毫秒 ) ：   以毫秒数设置日期，会改变整个日期</li>
<li>getFullYear()：    取得4位数的年份(如2007而非仅07)</li>
<li>getUTCFullYear()： 返回 UTC 日期的4位数年份</li>
<li>setFullYear( 年 )：  设置日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</li>
<li>setUTCFullYear( 年 )：  设置 UTC 日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</li>
<li>getMonth()：   返回日期中的月份，其中0表示一月，11表示十二月</li>
<li>getUTCMonth()：    返回 UTC 日期中的月份，其中0表示一月，11表示十二月</li>
<li>setMonth( 月 )：  设置日期的月份。传入的月份值必须大于0，超过11则增加年份</li>
<li>setUTCMonth( 月 )：  设置 UTC 日期的月份。传入的月份值必须大于0，超过11则增加年份</li>
<li>getDate()：    返回日期月份中的天数(1到31)</li>
<li>getUTCDate()： 返回 UTC 日期月份中的天数(1到31)</li>
<li>setDate( 日 )：  设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份</li>
<li>setUTCDate( 日 )：  设置 UTC 日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份</li>
<li>getDay()： 返回日期中星期的星期几(其中0表示星期日，6表示星期六)</li>
<li>getUTCDay()：  返回 UTC 日期中星期的星期几(其中0表示星期日，6表示星期六)</li>
<li>getHours()：   返回日期中的小时数(0到23)</li>
<li>getUTCHours()：    返回 UTC 日期中的小时数(0到23)</li>
<li>setHours( 时 )：  设置日期中的小时数。传入的值超过了23则增加月份中的天数</li>
<li>setUTCHours( 时 )：  设置 UTC 日期中的小时数。传入的值超过了23则增加月份中的天数</li>
<li>getMinutes()： 返回日期中的分钟数(0到59)</li>
<li>getUTCMinutes()：  返回 UTC 日期中的分钟数(0到59)</li>
<li>setMinutes( 分 )：  设置日期中的分钟数。传入的值超过59则增加小时数</li>
<li>setUTCMinutes( 分 )：  设置 UTC 日期中的分钟数。传入的值超过59则增加小时数</li>
<li>getSeconds()： 返回日期中的秒数(0到59)</li>
<li>getUTCSeconds()：  返回 UTC 日期中的秒数(0到59)</li>
<li>setSeconds( 秒 )：  设置日期中的秒数。传入的值超过了59会增加分钟数</li>
<li>setUTCSeconds( 秒 )：  设置 UTC 日期中的秒数。传入的值超过了59会增加分钟数</li>
<li>getMilliseconds()：    返回日期中的毫秒数</li>
<li>getUTCMilliseconds()： 返回 UTC 日期中的毫秒数</li>
<li>setMilliseconds( 毫秒 )  设置日期中的毫秒数</li>
</ul>
<h1 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h1><p>ECMAScript 通过 RegExp 类型来支持正则表达式。<br><code>var expression = / pattern / flags ;</code></p>
<h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><p>g ：表示全局(global)模式，<br>i ：表示不区分大小写(case-insensitive)模式，<br>m ：表示多行(multiline)模式。即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( [ &#123; \ ^ $ | ) ? * + .]&#125;</div></pre></td></tr></table></figure>
<p>如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。</p>
<h2 id="定义正则表达式的方式："><a href="#定义正则表达式的方式：" class="headerlink" title="定义正则表达式的方式："></a>定义正则表达式的方式：</h2><p>字面量形式定义正则表达式：<br><code>var pattern1 = /[bc]at/i;</code></p>
<p>构造函数定义正则表达式：<br><code>var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</code><br>传递给 RegExp 构造函数的两个参数都是字符串(不能把正则表达式字面量传递给 RegExp 构造函数)。<br>所以在某些情况下要对字符进行双重转义。<br>    字面量模式           等价的字符串<br>    /[bc]at/          “\[bc\]at”<br>    /.at/              “\.at”<br>    /name\/age/         “name\/age”<br>    /\d.\d{1,2}/        “\d.\d{1,2}”<br>    /\w\hello\123/    “\w\\hello\\123”</p>
<h2 id="ECMAScript-3的正则表达式字面量共享实例问题"><a href="#ECMAScript-3的正则表达式字面量共享实例问题" class="headerlink" title="ECMAScript 3的正则表达式字面量共享实例问题"></a>ECMAScript 3的正则表达式字面量共享实例问题</h2><p>在 ECMAScript 3 中，正则表达式字面量始终会共享同一个 RegExp 实例。<br>而使用构造函数创建的每一个新 RegExp 实例都是一个新实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re = <span class="literal">null</span>,</div><div class="line">i;</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    re = <span class="regexp">/cat/g</span>;</div><div class="line">    re.test(<span class="string">"catastrophe"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"cat"</span>, <span class="string">"g"</span>);</div><div class="line">    re.test(<span class="string">"catastrophe"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在第一个循环中，即使是循环体中指定的，但实际上只为 /cat/ 创建了一个 RegExp 实例。<br>由于实例属性不会重置，所以在循环中再次调用 test() 方法会失败。<br>第一次调用 test() 找到了 “cat” ，但第二次调用是从索引为 3 的字符(上一次匹配的末尾)开始的，所以就找不到它了。<br>由于会测试到字符串末尾，所以下一次再调用 test() 就又从开头开始了。<br>所以第一个循环应该是：成功、失败失败失败，又从头开始的时候成功，失败失败…..</p>
<p>第二个循环使用 RegExp 构造函数在每次循环中创建正则表达式。<br>因为每次迭代都会创建一个新的 RegExp 实例，所以每次调用 test() 都会返回 true 。</p>
<p>ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用 RegExp 构造函数一样，每次都创建新的 RegExp 实例。<br>IE9+、 Firefox 4+和 Chrome 都据此做出了修改。</p>
<h2 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h2><ul>
<li>global ：布尔值，表示是否设置了 g 标志。</li>
<li>ignoreCase ：布尔值，表示是否设置了 i 标志。</li>
<li>lastIndex ：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。</li>
<li>multiline ：布尔值，表示是否设置了 m 标志。</li>
<li>source ：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
</ul>
<p>通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。</p>
<h2 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>RegExp 对象的主要方法是 exec() ，该方法是专门为<strong>捕获组</strong>而设计的。<br>接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 null 。<br>返回的数组虽然是 Array 的实例，但包含两个额外的属性： index 和 input 。<br>index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</div><div class="line"><span class="keyword">var</span> matches = pattern.exec(text);</div><div class="line">alert(matches.index); <span class="comment">// 0</span></div><div class="line">alert(matches.input); <span class="comment">// "mom and dad and baby"</span></div><div class="line">alert(matches[<span class="number">0</span>]); <span class="comment">// "mom and dad and baby"</span></div><div class="line">alert(matches[<span class="number">1</span>]); <span class="comment">// " and dad and baby"</span></div><div class="line">alert(matches[<span class="number">2</span>]); <span class="comment">// " and baby"</span></div></pre></td></tr></table></figure>
<p>这个例子中的模式包含两个捕获组。<br>最内部的捕获组匹配 “and baby” ，<br>而包含它的捕获组匹配 “and dad” 或者 “and dad and baby” 。<br>数组中的第一项是匹配的整个字符串，<br>第二项包含与第一个捕获组匹配的内容，<br>第三项包含与第二个捕获组匹配的内容。</p>
<p>对于 exec() 方法而言，即使在模式中设置了全局标志( g )，它每次也只会返回一个匹配项。<br>在不设置全局标志的情况下，在同一个字符串上多次调用 exec() 将始终返回第一个匹配项的信息。<br>而在设置全局标志的情况下，每次调用 exec() 则都会在字符串中继续查找新匹配项。</p>
<p>IE:IE 的 JavaScript 实现在 lastIndex 属性上存在偏差，即使在非全局模式下， lastIndex 属性每次也会变化。</p>
<h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><p>正则表达式的第二个方法是 test() ，它接受一个字符串参数。<br>在模式与该参数匹配的情况下返回 true ；否则，返回 false 。<br>在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。<br>因此， test() 方法经常被用在 if 语句中。</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>RegExp 实例继承的 toLocaleString() 和 toString() 方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。<br>正则表达式的 valueOf() 方法返回正则表达式本身。</p>
<h2 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h2><p>Opera 不支持短属性名.</p>
<pre><code>input  $_
最近一次要匹配的字符串。 Opera 未实现此属性
lastMatch  $&amp;
最近一次的匹配项。 Opera 未实现此属性
lastParen  $+
最近一次匹配的捕获组。 Opera 未实现此属性
leftContext  $`
input 字符串中 lastMatch 之前的文本
multiline  $*
布尔值，表示是否所有表达式都使用多行模式。 IE 和 Opera 未实现此属性
rightContext  $&apos;
Input 字符串中 lastMatch 之后的文本
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">* 注意： Opera 不支持 input 、 lastMatch 、 lastParen 和 multiline 属性</div><div class="line">* Internet Explorer 不支持 multiline 属性</div><div class="line">*/</div><div class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</div><div class="line">    alert(<span class="built_in">RegExp</span>.input); <span class="comment">// this has been a short summer</span></div><div class="line">    alert(<span class="built_in">RegExp</span>.leftContext); <span class="comment">// this has been a</span></div><div class="line">    alert(<span class="built_in">RegExp</span>.rightContext); <span class="comment">// summer</span></div><div class="line">    alert(<span class="built_in">RegExp</span>.lastMatch); <span class="comment">// short</span></div><div class="line">    alert(<span class="built_in">RegExp</span>.lastParen); <span class="comment">// s</span></div><div class="line">    alert(<span class="built_in">RegExp</span>.multiline); <span class="comment">// false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用短属性名的话：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">* 注意： Opera 不支持 input 、 lastMatch 、 lastParen 和 multiline 属性</div><div class="line">* Internet Explorer 不支持 multiline 属性</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</div><div class="line">    alert(<span class="built_in">RegExp</span>.$_); <span class="comment">// this has been a short summer</span></div><div class="line">    alert(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]); <span class="comment">// this has been a</span></div><div class="line">    alert(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]); <span class="comment">// summer</span></div><div class="line">    alert(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]); <span class="comment">// short</span></div><div class="line">    alert(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]); <span class="comment">// s</span></div><div class="line">    alert(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]); <span class="comment">// false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。访问这些属性的语法是 RegExp.$1 、 RegExp.$2 … RegExp.$9 ，分别用于存储第一、第二……第九个匹配的捕获组。</p>
<h2 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h2><p>尽管 ECMAScript 中的正则表达式功能还是比较完备的，但仍然缺少某些语言(特别是 Perl)所支持的高级正则表达式特性。<br>比如：<br>匹配字符串开始和结尾的 \A 和 \Z 锚(但是支持以插入符号(^)和美元符号($)来匹配字符串的开始和结尾。)<br>向后查找(lookbehind)(但完全支持向前查找(lookahead))<br>并集和交集类<br>原子组(atomic grouping)<br>Unicode 支持(单个字符除外，如 \uFFFF )<br>命名的捕获组( 但支持编号的捕获组)<br>s (single ，单行)和 x (free-spacing ，无间隔)匹配模式<br>条件匹配<br>正则表达式注释</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第五章-1]]></title>
      <url>http://codingme.xyz/2016/09/17/javascript-note-5-1/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 ECMAScript 中，<strong>引用类型</strong>是一种数据结构，用于将数据和功能组织在一起。<br>它也常被称为<strong>类</strong>，但这种称呼并不妥当。<br>ECMAScript 不具备传统的面向对象语言所支持的<strong>类和接口</strong>等基本结构。<br>引用类型有时候也被称为<strong>对象定义</strong>，因为它们描述的是一类<strong>对象所具有的属性和方法</strong>。</p>
<p>虽然引用类型与类看起来相似，但它们并不是相同的概念。<br><strong>对象(Object)是某个特定引用类型的实例。</strong><br>新对象是使用 new 操作符后跟一个构造函数来创建的。</p>
<h1 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h1><p>Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为。</p>
<h2 id="创建-Object-实例的方式"><a href="#创建-Object-实例的方式" class="headerlink" title="创建 Object 实例的方式"></a>创建 Object 实例的方式</h2><ol>
<li>使用 new 操作符后跟 Object 构造函数:<code>var person = new Object();</code></li>
<li><p>使用对象字面量表示法：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="string">"name"</span> : <span class="string">"Nicholas"</span>,</div><div class="line">    <span class="string">"age"</span> : <span class="number">29</span>,</div><div class="line">    <span class="number">5</span> : <span class="literal">true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> 左边的花括号( { )表示对象字面量的开始，如果是在 if 语句的后面，则表示一个语句块的开始。<br> 在使用对象字面量语法时，属性名也可以使用字符串。5会自动转化为字符串。<br> 使用字面量表示法不会调用 Object 构造函数。<br> 使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象。<code>var person = {}; //与 new Object()相同</code><br> 关于对象字面量语法，我们推荐只在考虑对象属性名的可读性时使用。<br> 因为这种语法要求的代码量少，而且能够给人封装数据的感觉，开发人员更青睐对象字面量语法。<br> 对象字面量也是向函数传递大量可选参数的首选方式。<br> 在函数中的使用：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">displayInfo(&#123;</div><div class="line">    name: <span class="string">"Nicholas"</span>,</div><div class="line">    age: <span class="number">29</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。</p>
</li>
</ol>
<a id="more"></a>
<h2 id="访问对象属性的方法"><a href="#访问对象属性的方法" class="headerlink" title="访问对象属性的方法"></a>访问对象属性的方法</h2><ol>
<li>点表示法</li>
<li><p>方括号表示法(JavaScript 中)<br> 在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中。<br> 主要优点是可以通过变量来访问属性。例如：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</div><div class="line">alert(person[propertyName]); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p> 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。比如带空格的属性”first name”。<br> 通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。</p>
</li>
</ol>
<h1 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h1><ol>
<li>都是有序列表。</li>
<li>每一项可以保存任何类型的数据。</li>
<li>数组的大小是可以动态调整的。</li>
</ol>
<h2 id="创建数组的基本方式"><a href="#创建数组的基本方式" class="headerlink" title="创建数组的基本方式"></a>创建数组的基本方式</h2><ol>
<li><p>第一种:使用 Array 构造函数。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</div></pre></td></tr></table></figure>
<p> 在使用 Array 构造函数时也可以省略 new 操作符。</p>
</li>
<li><p>第二种:数组字面量表示法。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></div><div class="line"><span class="keyword">var</span> names = []; <span class="comment">// 创建一个空数组</span></div><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">// 不要这样！这样会创建一个包含 2 或 3 项的数组</span></div><div class="line"><span class="keyword">var</span> options = [,,,,,]; <span class="comment">// 不要这样！这样会创建一个包含 5 或 6 项的数组</span></div></pre></td></tr></table></figure>
<p> IE 的 BUG ：在 IE 中， values 会成为一个包含 3 个项且每项的值分别为 1、2 和 undefined 的数组。<br> 原因是 IE8 及之前版本中的 ECMAScript 实现在数组字面量方面存在 bug 。<br> 所以强烈建议不要使用<code>var values = [1,2,];</code>这种写法。<br> 在使用数组字面量表示法时，也不会调用 Array 构造函数。</p>
</li>
</ol>
<h2 id="读取和设置数组"><a href="#读取和设置数组" class="headerlink" title="读取和设置数组"></a>读取和设置数组</h2><p>使用方括号并提供相应值的基于 0 的数字索引。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 定义一个字符串数组</span></div><div class="line">alert(colors[<span class="number">0</span>]); <span class="comment">// 显示第一项</span></div><div class="line">colors[<span class="number">2</span>] = <span class="string">"black"</span>; <span class="comment">// 修改第三项</span></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"brown"</span>; <span class="comment">// 新增第四项</span></div></pre></td></tr></table></figure>
<h2 id="数组的-length"><a href="#数组的-length" class="headerlink" title="数组的 length"></a>数组的 length</h2><p>它不是只读的。因此，</p>
<ol>
<li>通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。<br> 往小了设置，可以移除最后几项；<br> 往大了设置，可以新增几项 undefined 。</li>
<li>利用 length 属性也可以方便地在数组末尾添加新项。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></div><div class="line">colors[colors.length] = <span class="string">"black"</span>; <span class="comment">// (在位置 3 )添加一种颜色</span></div><div class="line">colors[colors.length] = <span class="string">"brown"</span>; <span class="comment">// (在位置 4</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>数组最多可以包含 4 294 967 295 个项,如果超过这个上限值，就会发生异常。<br>而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。</p>
<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>对于 ECMAScript3 来说，使用 instanceof 。<br>存在问题：<br>如果网页包含多个框架，那实际上存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。<br>解决方法：<br>ECMAScript5 新增了 Array,isArray() 方法。<br>支持 Array.isArray() 方法的浏览器有 IE9+ 、 Firefox 4+ 、 Safari 5+ 、 Opera 10.5+和 Chrome 。<br>要在尚未实现这个方法中的浏览器中准确检测数组，请参考 22 章节。</p>
<h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>所有对象都具有 toLocaleString() 、 toString() 和 valueOf() 方法。</p>
<ul>
<li>toString() ：返回由数组中每个值的字符串形式拼接而成的<strong>一个以逗号分隔的字符串</strong>。</li>
<li>valueOf() ：返回的还是数组。</li>
<li>toLocaleString()：也会创建一个数组值的以逗号分隔的字符串。为了取得每一项的值，调用的是每一项的 toLocale-String() 方法，而不是 toString() 方法。</li>
</ul>
<p>例子中使用了对象字面量表示法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = &#123;</div><div class="line">    toLocaleString : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Nikolaos"</span>;</div><div class="line">&#125;,</div><div class="line">toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果数组中的某一项的值是 null 或者 undefined ，那么该值在 join() 、 toLocaleString() 、 toString() 和 valueOf() 方法返回的结果中以空字符串表示。</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>如果使用 join() 方法，可以使用不同分隔符来构建字符串。<br>如果不给 join() 方法传入任何值，或者给它传入 undefined ，则使用逗号作为分隔符。<br>IE7 及更早版本会错误的使用字符串 “undefined” 作为分隔符。</p>
<h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>数组可以表现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。<br>ECMAScript 为数组专门提供了 push() 和 pop() 方法，以便实现类似栈的行为。</p>
<h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>栈数据结构的访问规则是 LIFO(后进先出)，而队列数据结构的访问规则是 FIFO(First-In-First-Out ，先进先出)。<br><strong>兼容性要点</strong>： IE7 及更早版本对 JavaScript 的实现中存在一个偏差，其 unshift() 方法总是返回 undefined 而不是数组的新长度。 IE8 在非兼容模式下会返回正确的长度值。</p>
<h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p> reverse() 和 sort()</p>
<p><code>sort()</code>方法是根据测试字符串的结果改变原来的顺序，所以会造成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort();</div><div class="line">alert(values); <span class="comment">//0,1,10,15,5</span></div></pre></td></tr></table></figure>
<p>要解决这个问题，可以使用比较函数。<br>比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort(compare);</div><div class="line">alert(values); <span class="comment">//0,1,5,10,15</span></div></pre></td></tr></table></figure>
<p>对于数值类型或者其 valueOf() 方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可。</p>
<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul>
<li>concat() 方法：<br>  基于当前数组中的所有项创建一个新数组。<br>  具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。<br>  没有给 concat() 方法传递参数的情况下，它只是复制当前数组并返回副本。<br>  如果传递给 concat() 方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。<br>  concat() 方法不会影响原始数组。</li>
<li>slice()方法：<br>  基于当前数组中的一或多个项创建一个新数组。<br>  slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。<br>  在只有一个参数的情况下， slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。<br>  slice() 方法不会影响原始数组。<br>  要点：如果 slice() 方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。<br>  在一个包含 5 项的数组上调用 slice(-2,-1) 与调用 slice(3,4) 得到的结果相同。如果结束位置小于起始位置，则返回空数组。</li>
<li>splice() 方法：<br>  恐怕要算是最强大的数组方法。<br>  splice() 方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何项，则返回一个空数组)。<br>  使用方式有3种：<ul>
<li><strong>删除</strong>：<br>可以删除任意数量的项。<br>只需指定 2 个参数：要删除的第一项的位置，要删除的项数。<br>例如， splice(0,2) 会删除数组中的前两项。</li>
<li><strong>插入</strong>：可以向指定位置插入任意数量的项。<br>只需提供 3 个参数：起始位置，0(要删除的项数)，要插入的项。<br>如果要插入多个项，可以再传入第四、第五，以至任意多个项。</li>
<li><strong>替换</strong>：可以向指定位置插入任意数量的项，且同时删除任意数量的项。<br>只需指定 3 个参数：起始位置，要删除的项数，要插入的任意数量的项。<br>插入的项数不必与删除的项数相等。</li>
</ul>
</li>
</ul>
<h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p>ECMAScript 5 新增的两个位置方法。 indexOf() 和 lastIndexOf() 。<br>indexOf() 方法从数组的开头(位置 0)开始向后查找， lastIndexOf() 方法则从数组的末尾开始向前查找。<br>这两个方法在比较查找的项时，都使用全等操作符(===)</p>
<p>支持它们的浏览器包括 IE9+ 、 Firefox 2+ 、 Safari 3+ 、 Opera 9.5+和 Chrome 。<br>(也就是说，对于 IE7、8 来说，这两个位置方法不能用..)</p>
<h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>ECMAScript 5 为数组定义了 5 个迭代方法。<br>支持这些迭代方法的浏览器有 IE9+ 、 Firefox 2+ 、 Safari 3+ 、 Opera 9.5+和 Chrome 。<br>(一个问题：也就是说 ECMAScript3 不支持吧？跟前面的位置方法一样，如果要兼容 IE7、8 ，就得考虑迭代方法的兼容问题)<br>每个方法都接收两个参数：要在每一项上运行的<strong>函数</strong>，(可选的)运行该函数的<strong>作用域对象</strong>——影响 <strong>this</strong> 的值。<br>传入这些方法中的函数会接收三个参数：数组项的值，该项在数组中的位置，数组对象本身。</p>
<ul>
<li>every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true 。<br>  使用示例：数组中每个值都大于2的话，则返回 true 。</li>
<li>filter() ：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。<br>  使用示例：返回 数组中所有大于2的值 的数组。</li>
<li>forEach() ：对数组中的每一项运行给定函数。这个方法没有返回值。<br>  使用示例：基本等同于 for 语句。</li>
<li>map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>  使用示例：返回 数组中所有值乘以2 的数组。</li>
<li>some() ：对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true 。<br>  使用示例：数组中有一个值大于2的话，返回 true 。</li>
</ul>
<p>以上方法都不会修改数组中的包含的值。<br>every()就像是 与， some()就像是 或。两者都返回布尔值。</p>
<h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p>ECMAScript 5 新增了两个归并数组的方法： reduce() 和 reduceRight() 。<br>支持这些归并方法的浏览器有 IE9+ 、 Firefox 2+ 、 Safari 3+ 、 Opera 9.5+和 Chrome 。<br>(一个问题：又是说 ECMAScript3 不支持吧？跟前面的迭代方法一样，如果要兼容 IE7、8 ，就得考虑归并方法的兼容问题)<br>reduce() 方法从数组的第一项开始，逐个遍历到最后。而 reduceRight() 则从数组的最后一项开始，向前遍历到第一项。<br>都接收两个参数：一个在每一项上调用的函数，(可选的)作为归并基础的初始值。<br>reduce() 和 reduceRight() 的函数接收 4 个参数：前一个值，当前值，项的索引，数组对象。<br>求和示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum); <span class="comment">//15</span></div></pre></td></tr></table></figure>
<p>reduceRight() 的作用类似，方向相反。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第四章]]></title>
      <url>http://codingme.xyz/2016/09/17/javascript-note-4/</url>
      <content type="html"><![CDATA[<h1 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h1><p>基本数据类型： Undefined 、 Null 、 Boolean 、 Number 和 String 。<br>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中。<br>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。</p>
<p>引用类型的值是保存在内存中的对象(Object)。<br>引用类型的值是对象，保存在堆内存中。<br>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。<br>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</p>
<p>JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。<br>在操作对象时，实际上是在操作对象的引用而不是实际的对象。<br>为此，引用类型的值是按引用访问的。(当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际<br>的对象。)</p>
<p>在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。<br>ECMAScript 放弃了这一传统。</p>
<h2 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h2><p>对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。(Object)<br>只能给引用类型值动态地添加属性，以便将来使用。(给基本类型的添加了也是 undefined)</p>
<a id="more"></a>
<h2 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h2><p>基本类型：如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。<br>引用类型：当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。</p>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript 中所有函数的参数都是按值传递的。<br>有不少开发人员在这一点上可能会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。</p>
<p>基本类型：在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素)。<br>引用类型：在向参数传递引用类型的值时，会把这个值在内存中的地址(引用/指针)复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部(引用类型的值会被修改)。</p>
<p>有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    obj.name = <span class="string">"Nicholas"</span>;</div><div class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name = <span class="string">"Greg"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<p>如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值为 “Greg” 的新对象。<br>但是，当接下来再访问 person.name 时，显示的值仍然是 “Nicholas” 。<br>这说明即使在函数内部修改了参数的值，但<strong>原始的引用仍然保持未变</strong>。<br>实际上，当在函数内部重写 obj 时，这个变量引用的就是另一个对象，一个局部对象了。<br>而这个局部对象会在函数执行完毕后立即被销毁。<br>可以把 ECMAScript 函数的参数想象成局部变量。</p>
<h2 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h2><p>typeof:检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。<br>instanceof:如果变量是给定引用类型的实例，那么 instanceof 操作符就会返回 true 。如果使用 instanceof 操作符检测基本类型的值，则该操作符始终会返回 false ，因为基本类型不是对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// 变量 person 是 Object 吗？</span></div><div class="line">alert(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// 变量 colors 是 Array 吗？</span></div><div class="line">alert(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// 变量 pattern 是 RegExp 吗？</span></div></pre></td></tr></table></figure>
<p>使用 typeof 操作符检测函数时，该操作符会返回 “function” 。<br>ECMA-262 规定任何在内部实现 [[Call]] 方法的对象都应该在应用 typeof 操作符时返回 “function” 。<br>(在 Safari 5 及之前版本和 Chrome 7 及之前版本中使用 typeof 检测正则表达式时，浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用 typeof 会返回 “function” )<br>(在 IE 和 Firefox 中，对正则表达式应用 typeof 会返回 “object”)</p>
<h1 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h1><h2 id="全局执行环境"><a href="#全局执行环境" class="headerlink" title="全局执行环境"></a>全局执行环境</h2><p><strong>全局执行环境</strong>是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。(全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁)</p>
<h2 id="执行流"><a href="#执行流" class="headerlink" title="执行流"></a>执行流</h2><p>ECMAScript 程序中的<strong>执行流</strong>的控制机制：每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>(scope chain)。<br>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链。</p>
<p>用途：是保证对执行环境有权访问的所有变量和函数的有序访问。</p>
<p>当前的变量对象——&gt;<br>活动对象作为变量对象(环境若是函数)——&gt;<br>活动对象最开始只包含 arguments 对象——&gt;<br>下一个变量对象来自包含(外部)环境——&gt;<br>再下一个来自下一个包含(外部)环境——&gt;<br>……<br>直到全局执行环境。</p>
<p>标识符(name)解析是沿着作用域链一级一级地搜索标识符的过程。(如果找不到标识符，通常会导致错误发生)</p>
<p>函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><ol>
<li>try-catch 语句的 catch 块；</li>
<li>with 语句。</li>
</ol>
<p>这两个语句都会在作用域链的前端添加一个变量对象。<br>对 with 语句来说，会将指定的对象添加到作用域链中。<br>对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</div><div class="line">    <span class="keyword">with</span>(location)&#123;</div><div class="line">        <span class="keyword">var</span> url = href + qs;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> url;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>url 成了函数执行环境中的一部分，所以可以当作函数的值被返回。</p>
<p>旧浏览器的 BUG :<br>在 IE8 及之前版本的 JavaScript 实现中，存在一个与标准不一致的地方，<br>即在 catch 语句中捕获的错误对象会被添加到执行环境的变量对象，而不是 catch 语句的变量对象中。<br>换句话说，即使是在 catch 块的外部也可以访问到错误对象。<br>IE9 修复了这个问题。</p>
<h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line">&#125;</div><div class="line">alert(color); <span class="comment">//"blue"</span></div></pre></td></tr></table></figure>
<p>如果是在 C 、 C++ 或 Java 中， color 会在 if 语句执行完毕后被销毁。<br>但在 JavaScript 中， if 语句中的变量声明会将变量添加到当前的执行环境(在这里是全局环境)中。<br>在使用 for 语句时尤其要牢记这一差异。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</div><div class="line">    doSomething(i);</div><div class="line">&#125;</div><div class="line">alert(i); <span class="comment">//10</span></div></pre></td></tr></table></figure>
<p>对于有块级作用域的语言来说， for 语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。<br>而对于 JavaScript 来说，由 for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会存在于循环外部的执行环境中。</p>
<ol>
<li>声明变量：<br> 使用 var 声明的变量会自动被添加到最接近的环境中。<br> 在函数内部，最接近的环境就是函数的局部环境；<br> 在 with 语句中，最接近的环境是函数环境。<br> 如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。<br> 要点：<br> 在编写 JavaScript 代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。<br> 我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。<br> <strong>在严格模式下，初始化未经声明的变量会导致错误。</strong></li>
<li>查询标识符：<br> 如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。<br> 换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。<br> 变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。<br> JavaScript 引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。</li>
</ol>
<h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><p>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。<br>用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。</p>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>JavaScript 中最常用的垃圾收集方式(mark-and-sweep)。<br>当变量进入环境(例如，在函数中声明一个变量)时，就将这个变量标记为“进入环境”。<br>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。<br>而当变量离开环境时，则将其标记为“离开环境”。<br>如何标记变量其实并不重要，关键在于采取什么策略。</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记(当然，可以使用任何标记方式)。——[mark all]<br>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。——[delete used]<br>在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。——[mark garbage]<br>最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。——[swap]</p>
<p>到 2008 年为止， IE 、 Firefox 、 Opera 、 Chrome 和 Safari 的 JavaScript 实现使用的都是标记清除式的垃圾收集策略(或类似的策略)，只不过垃圾收集的时间间隔互有不同。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>另一种不太常见的垃圾收集策略。<br>含义是跟踪记录每个值被引用的次数。<br>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。<br>如果同一个值又被赋给另一个变量，则该值的引用次数加 1。<br>相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。<br>当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。<br>当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p>
<p>Netscape Navigator 3.0是最早使用引用计数策略的浏览器。</p>
<h3 id="严重问题：循环引用。"><a href="#严重问题：循环引用。" class="headerlink" title="严重问题：循环引用。"></a>严重问题：循环引用。</h3><p>所以 Netscape 在 Navigator 4.0 中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。<br>可是引用计数导致的麻烦并未就此终结。</p>
<p>IE 中有一部分对象并不是原生 JavaScript 对象。<br>例如，其 BOM 和 DOM 中的对象就是使用 C++以 COM(Component Object Model ，组件对象模型)对象的形式实现的，<br>而 COM 对象的垃圾收集机制采用的就是引用计数策略。<br>即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，<br>但 JavaScript 访问的 COM 对象依然是基于引用计数策略的。<br>换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</div><div class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">myObject.element = element;</div><div class="line">element.someObject = myObject;</div></pre></td></tr></table></figure>
<p>这个例子在一个 DOM 元素( element )与一个原生 JavaScript 对象( myObject )之间创建了循环引用。<br>其中，变量 myObject 有一个名为 element 的属性指向 element 对象；<br>而变量 element 也有一个属性名叫 someObject 回指 myObject 。<br>由于存在这个循环引用，即使将例子中的 DOM 从页面中移除，它也永远不会被回收。</p>
<p>为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与 DOM 元素之间的连接。<br>例如可以使用下面的代码消除前面例子创建的循环引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myObject.element = <span class="literal">null</span>;</div><div class="line">element.someObject = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。</p>
<p>在 IE9 时把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。</p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><h3 id="IE-声名狼藉的性能问题。"><a href="#IE-声名狼藉的性能问题。" class="headerlink" title="IE 声名狼藉的性能问题。"></a>IE 声名狼藉的性能问题。</h3><p>IE 的垃圾收集器是根据内存分配量运行的，<br>具体一点说就是 256 个变量、4096 个对象(或数组)字面量和数组元素(slot)或者 64KB 的字符串。<br>达到上述任何一个临界值，垃圾收集器就会运行。</p>
<p>问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。<br>而这样一来，垃圾收集器就不得不频繁地运行。</p>
<p>由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。<br>IE7触发垃圾收集的变量分配、字面量和(或)数组元素的临界值被调整为动态修正。</p>
<p>临界值在初始时与 IE6 相等。<br>如果垃圾收集例程回收的内存分配量低于 15%，则临界值加倍。<br>如果例程回收了 85%的内存分配量，则将各种临界值重置回默认值。</p>
<p><strong>事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。</strong>在 IE 中，调用 window.CollectGarbage() 方法会立即执行垃圾收集。</p>
<h1 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h1><p>JavaScript 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。</p>
<p>最主要的一个问题，就是分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。<br>目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。<br><strong>内存限制问题</strong>不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。</p>
<p>优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。<br>一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用(dereferencing)。<br>这一做法适用于大多数全局变量和全局对象的属性。<br>局部变量会在它们离开执行环境时自动被解除引用。</p>
<p>解除一个值的引用并不意味着自动回收该值所占用的内存。<br>解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。<br>为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第三章-3]]></title>
      <url>http://codingme.xyz/2016/09/17/javascript-note-3-3/</url>
      <content type="html"><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p>ECMA-262 规定了一组语句(也称为流控制语句)。</p>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) statement1 <span class="keyword">else</span> statement2</div></pre></td></tr></table></figure>
<p>其中的 condition(条件)可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。<br>ECMAScript 会自动调用 <code>Boolean()</code> 转换函数将这个表达式的结果转换为一个布尔值。</p>
<p><strong>业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。</strong>因为这样可以消除人们的误解，否则可能让人分不清在不同条件下要执行哪些语句。</p>
<h2 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h2><p>要点：<strong>像 do-while 这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。</strong></p>
<h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p>while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。</p>
<h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。</p>
<p><strong>使用 while 循环做不到的，使用 for 循环同样也做不到。</strong>也就是说， for 循环只是把与循环有关的代码集中在了一个位置。</p>
<p>由于 ECMAScript 中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。</p>
<p>for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部省略，就会创建一个无限循环。</p>
<a id="more"></a>
<h2 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h2><p>for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (property <span class="keyword">in</span> expression) statement</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line">    <span class="built_in">document</span>.write(propName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName 。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。</p>
<p>与 for 语句类似，这里控制语句中的 var 操作符也不是必需的。但是，<strong>为了保证使用局部变量</strong>，我们推荐上面例子中的这种做法。</p>
<p>ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。</p>
<p>如果表示要迭代的对象的变量值为 null 或 undefined ， for-in 语句会抛出错误。 ECMAScript 5 更正了这一行为；<br>为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined 。</p>
<h2 id="label-语句"><a href="#label-语句" class="headerlink" title="label 语句"></a>label 语句</h2><p>使用 label 语句可以在代码中添加标签，以便将来使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">label: statement</div><div class="line"></div><div class="line">start: <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">    alert(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中定义的 start 标签可以在将来由 break 或 continue 语句引用。<br>加标签的语句一般都要与 for 语句等循环语句配合使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line">outPoint:</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; j++)&#123;</div><div class="line">          <span class="keyword">if</span>( i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span> )&#123;</div><div class="line">                <span class="keyword">break</span> outPoint;</div><div class="line">          &#125;;</div><div class="line">     num++;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">alert(num); <span class="comment">// 循环在 i 为5， j 为5的时候跳出双循环，返回到 outPoint 层继续执行，输出 55</span></div></pre></td></tr></table></figure>
<p>由例子可见 label 语句可以用来实现 break 跳出内层循环回到外层这样的功能。<br>然而，就像 Java 中的 goto 语句一样，对于 label 语句：</p>
<p>标记(Labels)在 JavaScript 中并不经常被使用，这是因为它们会使程序变得更难于阅读和理解。<br>应该尽可能地避免使用，根据情况，选择<strong>调用函数</strong> 或 <strong>抛出异常</strong>。——<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label/" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label/</a></p>
<h2 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h2><p>虽然联用 break 、 continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，<strong>一定要使用描述性的标签，同时不要嵌套过多的循环。</strong></p>
<h2 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h2><p>with 语句的作用是将代码的作用域设置到一个特定的对象中。<br>定义 with 语句的目的主要是为了简化多次编写同一个对象的工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> hostName = location.hostname;</div><div class="line"><span class="keyword">var</span> url = location.href;</div></pre></td></tr></table></figure>
<p>上面几行代码都包含 location 对象。如果使用 with 语句:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span>(location)&#123;</div><div class="line">    <span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</div><div class="line">    <span class="keyword">var</span> hostName = hostname;</div><div class="line">    <span class="keyword">var</span> url = href;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提示：<strong>严格模式下不允许使用 with 语句，否则将视为语法错误。</strong><br>提示1：由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在<strong>开发大型应用程序时，不建议使用 with 语句。</strong></p>
<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><p>ECMAScript 中 switch 语句的语法与其他基于 C 的语言非常接近。<br>从根本上讲， switch 语句就是为了让开发人员免于编写多个 if else 重复代码。<br>如果需要省略 break 合并几种情况，不要忘了在代码中添加注释，说明你是有意省略了 break 关键字。<br>ECMAScript 中可以在 switch 语句中使用任何数据类型(在很多其他语言中只能使用数值)，无论是字符串，还是对象都没有问题。<br>其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (<span class="string">"hello world"</span>) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"hello"</span> + <span class="string">" world"</span>:</div><div class="line">        alert(<span class="string">"Greeting was found."</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"goodbye"</span>:</div><div class="line">        alert(<span class="string">"Closing was found."</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        alert(<span class="string">"Unexpected message was found."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">25</span>;</div><div class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">case</span> num &lt; <span class="number">0</span>:</div><div class="line">        alert(<span class="string">"Less than 0."</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</div><div class="line">        alert(<span class="string">"Between 0 and 10."</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</div><div class="line">        alert(<span class="string">"Between 10 and 20."</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        alert(<span class="string">"More than 20."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要点：<strong>switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换(例如，字符串 “10” 不等于数值 10)。</strong></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>ECMAScript 中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过 return 语句后跟要返回的值来实现返回值。<br>要点：<strong>推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。</strong><br>实际上，未指定返回值的函数返回的是一个特殊的 undefined 值。</p>
<h2 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h2><ul>
<li>不能把函数命名为 eval 或 arguments ；</li>
<li>不能把参数命名为 eval 或 arguments ；</li>
<li>不能出现两个命名参数同名的情况。</li>
</ul>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="参数特点"><a href="#参数特点" class="headerlink" title="参数特点"></a>参数特点</h3><ul>
<li>ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。<br>  原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数(如果有参数的话)。</li>
<li>没有传递值的命名参数将自动被赋予 undefined 值。</li>
<li>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。</li>
</ul>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>arguments 对象只是与数组类似(它并不是 Array 的实例)，因为可以使用方括号语法访问它的每一个元素(即第一个元素是 arguments[0] ，第二个元素是 argumetns[1] ，以此类推)，使用 length 属性来确定传递进来多少个参数。</p>
<p>arguments 的使用体现 ECMAScript 函数的一个重要特点：<strong>命名的参数只提供便利，但不是必需的。</strong></p>
<h4 id="arguments-特点："><a href="#arguments-特点：" class="headerlink" title="arguments 特点："></a>arguments 特点：</h4><ul>
<li>arguments 对象可以与命名参数一起使用。</li>
<li>它的值永远与对应命名参数的值保持同步。<strong>并不是说读取第一个命名参数和 arguments[0] 这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。</strong></li>
<li>严格模式下，对 arguments 赋值会变得无效。其次，重写 arguments 的值会导致语法错误(代码将不会执行)。</li>
</ul>
<h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><p>ECMAScirpt 函数没有签名，真正的重载是不可能做到的。<br>如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。<br>通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第三章-2]]></title>
      <url>http://codingme.xyz/2016/09/17/javascript-note-3-2/</url>
      <content type="html"><![CDATA[<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>包括算术操作符(如加号和减号)、位操作符、关系操作符和相等操作符。<br>ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。<br>不过，<strong>在应用于对象时，相应的操作符通常都会调用对象的 valueOf()和(或) toString() 方法，以便取得可以操作的值。</strong></p>
<h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><h3 id="递增递减操作符"><a href="#递增递减操作符" class="headerlink" title="递增递减操作符"></a>递增递减操作符</h3><p>执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。(在计算机科学领域，这种情况通常被称作副效应。)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</div><div class="line"><span class="keyword">var</span> anotherAge = --age + <span class="number">2</span>;</div><div class="line">alert(age); <span class="comment">// 输出 28</span></div><div class="line">alert(anotherAge); <span class="comment">// 输出 30</span></div></pre></td></tr></table></figure>
<p>后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> num3 = num1-- + num2; <span class="comment">//  等于 22</span></div><div class="line"><span class="keyword">var</span> num4 = num1 + num2; <span class="comment">// 等于 21</span></div></pre></td></tr></table></figure>
<p>作用数据类型时候，等同于先 Number() 再加减1，会像 Number() 转型函数一样对这个值执行转换。</p>
<a id="more"></a>
<h3 id="一元加操作符"><a href="#一元加操作符" class="headerlink" title="一元加操作符"></a>一元加操作符</h3><p>对数值不会产生任何影响。<br>对非数值应用一元加操作符时，该操作符会像 Number() 转型函数一样对这个值执行转换。<br>所以<strong>疑问</strong>：一元加操作符乃至于递增递减操作符和 Number() 有什么关系？感觉好像都会经由 Number() 转换。</p>
<h3 id="一元减操作符"><a href="#一元减操作符" class="headerlink" title="一元减操作符"></a>一元减操作符</h3><p>对数值会让其变成其负数。<br>对非数值跟一元加操作符相同，最后再转换成负数。</p>
<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。<br>而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。<br>对于开发人员来说，由于 64 位存储格式是透明的，因此整个过程就像是只存在 32 位的整数一样。</p>
<p>对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：0 表示正数，1 表示负数。<br>这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。<br>正数以纯二进制格式存储，31 位中的每一位都表示 2 的幂。<br>负数同样以二进制码存储，但使用的格式是二进制补码。<br>这个转换过程也导致了一个严重的副效应，即在<strong>对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。</strong></p>
<h3 id="按位非-NOT"><a href="#按位非-NOT" class="headerlink" title="按位非 NOT"></a>按位非 NOT</h3><p>按位非操作符由一个波浪线(~)表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">25</span>; <span class="comment">// 二进制 00000000000000000000000000011001</span></div><div class="line"><span class="keyword">var</span> num2 = ~num1; <span class="comment">// 二进制 11111111111111111111111111100110</span></div><div class="line">alert(num2); <span class="comment">// -26</span></div></pre></td></tr></table></figure>
<h3 id="按位与-AND"><a href="#按位与-AND" class="headerlink" title="按位与 AND"></a>按位与 AND</h3><p>按位与操作符由一个和号字符( &amp; )表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="number">25</span> &amp; <span class="number">3</span>;</div><div class="line">alert(result); <span class="comment">//1</span></div></pre></td></tr></table></figure>
<h3 id="按位或-OR"><a href="#按位或-OR" class="headerlink" title="按位或 OR"></a>按位或 OR</h3><p>按位或操作符由一个竖线符号(|)表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="number">25</span> | <span class="number">3</span>;</div><div class="line">alert(result); <span class="comment">//27</span></div></pre></td></tr></table></figure>
<h3 id="按位异或-XOR"><a href="#按位异或-XOR" class="headerlink" title="按位异或 XOR"></a>按位异或 XOR</h3><p>按位异或操作符由一个插入符号(^)表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="number">25</span> ^ <span class="number">3</span>;</div><div class="line">alert(result); <span class="comment">//26</span></div></pre></td></tr></table></figure>
<h3 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h3><p>左移操作符由两个小于号(&lt;&lt;)表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oldValue = <span class="number">2</span>; <span class="comment">// 等于二进制的 10</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue &lt;&lt; <span class="number">5</span>; <span class="comment">// 等于二进制的 1000000，十进制的 64</span></div></pre></td></tr></table></figure>
<p>注意，左移不会影响操作数的符号位。换句话说，如果将-2向左移动 5位，结果将是-64，而非 64。<br><strong>也就是说，符号位是不会有变化，而是符号位右边的位会变化</strong></p>
<h3 id="有符号右移"><a href="#有符号右移" class="headerlink" title="有符号右移"></a>有符号右移</h3><p>有符号的右移操作符由两个大于号(&gt;&gt;)表示。<br>会将数值向右移动，但保留符号位。<br> ECMAScript 会用符号位的值来填充所有空位。<br> <strong>即如果是负数的话，填充空位用的是1，反之为0</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oldValue = <span class="number">64</span>; <span class="comment">// 等于二进制的 1000000</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt; <span class="number">5</span>; <span class="comment">// 等于二进制的 10 ，即十进制的 2</span></div></pre></td></tr></table></figure>
<h3 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h3><p>无符号右移操作符由 3 个大于号(&gt;&gt;&gt;)表示。<br>对正数来说，无符号右移的结果与有符号右移相同。<br>无符号右移是以 0 来填充空位，而不是像有符号右移那样以符号位的值来填充空位。</p>
<p>无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。<strong>(填充了无数个0，反码计算回去，十进制的数字无限大)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oldValue = <span class="number">-64</span>; <span class="comment">//  等于二进制的 11111111111111111111111111000000</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>; <span class="comment">// 等于十进制的 134217726</span></div></pre></td></tr></table></figure>
<h3 id="无符号左移"><a href="#无符号左移" class="headerlink" title="无符号左移"></a>无符号左移</h3><p>无符号右移操作符由 3 个大于号(&gt;&gt;&gt;)表示。<br>对负数来说，无符号右移是以 0 来填充空位，其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oldValue = <span class="number">-64</span>; <span class="comment">//  等于二进制的 11111111111111111111111111000000</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>; <span class="comment">// 等于十进制的 134217726</span></div></pre></td></tr></table></figure>
<h2 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h2><h3 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h3><p>逻辑非操作符由一个叹号(！)表示，可以应用于 ECMAScript 中的任何值。</p>
<ul>
<li>如果操作数是一个对象，返回 false ；</li>
<li>如果操作数是一个空字符串，返回 true ；</li>
<li>如果操作数是一个非空字符串，返回 false ；</li>
<li>如果操作数是数值 0，返回 true ；</li>
<li>如果操作数是任意非 0 数值(包括 Infinity )，返回 false ；</li>
<li>如果操作数是 null ，返回 true ；</li>
<li>如果操作数是 NaN ，返回 true ；</li>
<li>如果操作数是 undefined ，返回 true 。</li>
</ul>
<p>同时使用两个逻辑非操作符，实际上就会模拟 Boolean() 转型函数的行为。</p>
<h3 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h3><p>逻辑与操作符由两个和号( &amp;&amp; )表示。</p>
<ol>
<li>如果第一个操作数是对象，则返回第二个操作数；</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；</li>
<li>如果两个操作数都是对象，则返回第二个操作数；</li>
<li>如果有一个操作数是 null ，则返回 null ；</li>
<li>如果有一个操作数是 NaN ，则返回 NaN ；</li>
<li>如果有一个操作数是 undefined ，则返回 undefined 。</li>
</ol>
<p><strong>短路操作符</strong>：如果第一个操作数的求值结果为 true ，就不会对第二个操作数求值了。</p>
<h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h3><p>逻辑或操作符由两个竖线符号( || )表示。</p>
<ol>
<li>同 逻辑与 第一条。</li>
</ol>
<ul>
<li>如果第一个操作数的求值结果为 false ，则返回第二个操作数；</li>
<li>如果两个操作数都是对象，则返回第一个操作数；</li>
<li>如果两个操作数都是 null ，则返回 null ；</li>
<li>如果两个操作数都是 NaN ，则返回 NaN ；</li>
<li>如果两个操作数都是 undefined ，则返回 undefined 。</li>
</ul>
<p>同样是<strong>短路操作符</strong>。</p>
<h4 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h4><p>利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。 ECMAScript 程序的赋值语句经常会使用这种模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = preferredObject || backupObject;</div></pre></td></tr></table></figure>
<h2 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h2><p>乘法、除法和求模。<br>如果参与乘性计算的某个操作数不是数值，后台会先使用 Number() 转型函数将其转换为数值。</p>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><ol>
<li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是数。如果乘积超过了 ECMAScript 数值的表示范围，则返回 Infinity 或 -Infinity ；</li>
<li>如果有一个操作数是 NaN ，则结果是 NaN ；</li>
<li>如果是 Infinity 与 0 相乘，则结果是 NaN ；</li>
<li>如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或 -Infinity ，取决于有符号操作数的符号；</li>
<li>如果是 Infinity 与 Infinity 相乘，则结果是 Infinity ；</li>
<li>如果有一个操作数不是数值，则在后台调用 Number() 将其转换为数值，然后再应用上面的规则。</li>
</ol>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><ul>
<li>同 乘法 第一条；</li>
<li>同 乘法 第二条；</li>
<li>同 乘法 第五条；</li>
<li>如果是零被零除，则结果是 NaN ；</li>
<li>如果是非零的有限数被零除，则结果是 Infinity 或 -Infinity ，取决于有符号操作数的符号；</li>
<li>如果是 Infinity 被任何非零数值除，则结果是 Infinity 或 -Infinity ，取决于有符号操作数的符号；</li>
<li>同 乘法 第六条。</li>
</ul>
<h3 id="求模"><a href="#求模" class="headerlink" title="求模"></a>求模</h3><ol>
<li>如果操作数都是数值，执行常规的除法计算，返回除得的余数；</li>
<li>如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN ；</li>
<li>如果被除数是有限大的数值而除数是零，则结果是 NaN ；</li>
<li>如果是 Infinity 被 Infinity 除，则结果是 NaN ；</li>
<li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；</li>
<li>如果被除数是零，则结果是零； 0%？</li>
<li>同 乘法 第六条。</li>
</ol>
<h2 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><ul>
<li>如果有一个操作数是 NaN ，则结果是 NaN ；</li>
<li>如果是 Infinity 加 Infinity ，则结果是 Infinity ；</li>
<li>如果是 -Infinity 加 -Infinity ，则结果是 -Infinity ；</li>
<li>如果是 Infinity 加 -Infinity ，则结果是 NaN ；</li>
<li>如果是+0 加+0，则结果是+0；</li>
<li>如果是-0 加-0，则结果是-0；</li>
<li>如果是+0 加-0，则结果是+0。</li>
</ul>
<p>如果有一个操作数是字符串，则：</p>
<ul>
<li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。</li>
</ul>
<p>忽视加法操作中的数据类型是 ECMAScript 编程中最常见的一个错误。</p>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><ul>
<li>同 加法 第一条；</li>
<li>如果是 Infinity 减 Infinity ，则结果是 NaN ；</li>
<li>如果是 -Infinity 减 -Infinity ，则结果是 NaN ；</li>
<li>如果是 Infinity 减 -Infinity ，则结果是 Infinity ；</li>
<li>如果是 -Infinity 减 Infinity ，则结果是 -Infinity ；</li>
<li>如果是+0 减+0，则结果是+0；</li>
<li>如果是+0 减-0，则结果是-0；</li>
<li>如果是-0 减-0，则结果是+0；</li>
<li>如果有一个操作数是字符串、布尔值、 null 或 undefined ，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN ，则减法的结果就是 NaN ；</li>
<li>如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN ，则减法的结果就是 NaN 。如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。</li>
</ul>
<h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><ul>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li>
<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li>
<li>如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf() 方法，则调用 toString() 方法，并用得到的结果根据前面的规则执行比较。</li>
<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li>
</ul>
<p>有趣的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">"a"</span> &lt; <span class="number">3</span>; <span class="comment">// false ，因为"a"被转换成了 NaN</span></div></pre></td></tr></table></figure>
<p>由于字母 “a” 不能转换成合理的数值，因此就被转换成了 NaN 。根据规则，任何操作数与 NaN 进行关系比较，结果都是 false 。</p>
<h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h2><p>由于相等和不相等操作符存在类型转换问题，<strong>而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。</strong></p>
<h3 id="相等和不相等——先转换再比较"><a href="#相等和不相等——先转换再比较" class="headerlink" title="相等和不相等——先转换再比较"></a>相等和不相等——先转换再比较</h3><p>相等操作符由两个等于号( == )表示，不相等操作符由叹号后跟等于号( != )表示。<br>这两个操作符都会先转换操作数(通常称为强制转型)，然后再比较它们的相等性。</p>
<ul>
<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值—— false 转换为 0，而 true 转换为 1；</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；</li>
</ul>
<p>这两个操作符在进行比较时则要遵循下列规则。</p>
<ul>
<li>null 和 undefined 是相等的。</li>
<li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li>
<li>如果有一个操作数是 NaN ，则相等操作符返回 false ，而不相等操作符返回 true 。重要提示：即使两个操作数都是 NaN ，相等操作符也返回 false ；因为按照规则， NaN 不等于 NaN 。</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true ；否则，返回 false 。</li>
</ul>
<h3 id="全等和不全等——仅比较而不转换"><a href="#全等和不全等——仅比较而不转换" class="headerlink" title="全等和不全等——仅比较而不转换"></a>全等和不全等——仅比较而不转换</h3><p>全等操作符由 3 个等于号( === )表示，不全等操作符由一个叹号后跟两个等于号( !== )表示。</p>
<h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><p>条件操作符应该算是 ECMAScript 中最灵活的一种操作符了，而且它遵循与 Java 中的条件操作符相同的语法形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">variable = boolean_expression ? true_value : false_value;</div></pre></td></tr></table></figure>
<p>本质上，这行代码的含义就是基于对 <code>boolean_expression</code> 求值的结果，决定给变量 <code>variable</code>赋什么值。如果求值结果为 <code>true</code> ，则给变量 <code>variable</code> 赋 <code>true_value</code> 值；如果求值结果为<code>false</code> ，则给变量 <code>variable</code> 赋 <code>false_value</code> 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> max = (num1 &gt; num2) ? num1 : num2;</div></pre></td></tr></table></figure>
<p>在这个例子中， max 中将会保存一个最大的值。这个表达式的意思是：如果 num1 大于 num2 (关系表达式返回 true )，则将 num1 的值赋给 max ；如果 num1 小于或等于 num2 (关系表达式返回 false )，则将 num2 的值赋给 max 。</p>
<h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><p>简单的赋值操作符由等于号( = )表示。</p>
<ul>
<li>乘/赋值( *= )；</li>
<li>除/赋值( /= )；</li>
<li>模/赋值( %= )；</li>
<li>加/赋值( += )；</li>
<li>减/赋值( -= )；</li>
<li>左移/赋值( &lt;&lt;= )；</li>
<li>有符号右移/赋值( &gt;&gt;= )；</li>
<li>无符号右移/赋值( &gt;&gt;&gt;= )。</li>
</ul>
<p>设计这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。</p>
<h2 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h2><p>使用逗号操作符可以在一条语句中执行多个操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1=<span class="number">1</span>, num2=<span class="number">2</span>, num3=<span class="number">3</span>;</div></pre></td></tr></table></figure>
<p>逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">// num 的值为 0</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第三章-1]]></title>
      <url>http://codingme.xyz/2016/09/11/javascript-note-3-1/</url>
      <content type="html"><![CDATA[<h1 id="ECMAScript-的标识符"><a href="#ECMAScript-的标识符" class="headerlink" title="ECMAScript 的标识符"></a>ECMAScript 的标识符</h1><ul>
<li>区分大小写</li>
<li>采用驼峰大小写格式。为了与 ECMAScript 内置的函数和对象命名格式保持一致。<br>  如： doSomethingImportant</li>
</ul>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ul>
<li>单行： <code>//这里是注释</code></li>
<li>多行：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">这里是注释</div><div class="line">*/</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="ECMAScript-的严格模式-strict-mode"><a href="#ECMAScript-的严格模式-strict-mode" class="headerlink" title="ECMAScript 的严格模式 (strict mode)"></a>ECMAScript 的严格模式 (strict mode)</h1><ul>
<li>严格模式的启用：<br>顶部添加如下代码：”use strict”;<br>看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示(pragma)，用于告诉支持的 JavaScript 引擎切换到严格模式。这是为不破坏 ECMAScript 3 语法而特意选定的语法。</li>
<li><p>也可以指定函数在严格模式下执行：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line">    <span class="comment">//函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>严格模式下， JavaScript 的执行结果会有很大不同。<br>  支持严格模式的浏览器包括 IE10+ 、 Firefox 4+ 、 Safari 5.1+ 、 Opera 12+和 Chrome 。</p>
</li>
</ul>
<a id="more"></a>
<h1 id="ECMAScript-的语句"><a href="#ECMAScript-的语句" class="headerlink" title="ECMAScript 的语句"></a>ECMAScript 的语句</h1><ul>
<li>任何时候都不要省略语句结尾的分号。加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。</li>
<li>最佳实践是始终在控制语句中使用代码块。</li>
</ul>
<h1 id="ECMAScript-的关键字和保留字"><a href="#ECMAScript-的关键字和保留字" class="headerlink" title="ECMAScript 的关键字和保留字"></a>ECMAScript 的关键字和保留字</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><pre><code>break       do      instanceof  typeof
case        else    new         var
catch       finally return      void
continue    for     switch      while
debugger*   function this       with
default     if      throw
delete      in      try
</code></pre><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>第三版的全部保留字：</p>
<pre><code>abstract    enum        int         short
boolean     export      interface   static
byte        extends     long        super
char        final       native      synchronized
class       float       package     throws
const       goto        private     transient
debugger    implements  protected   volatile
double      import      public
</code></pre><p>第 5 版在非严格模式下：</p>
<pre><code>class   enum      extends   super
const   export    import
</code></pre><p>在严格模式下还有：</p>
<pre><code>implements  package     public
interface   private     static
let         protected   yield
</code></pre><p>为了最大程度地保证兼容性，建议读者将第 3 版定义的保留字外加 let 和 yield 作为编程时的参考。<br>一般来说，最好都不要使用关键字和保留字作为标识符和属性名，以便与将来的 ECMAScript 版本兼容。<br>举例：<br>IE7 问世时 ECMAScript5 还没出来。 IE8 支持一点，直到 IE9 支持更多 、 IE10完美支持。<br>所以为了兼容 IE ，要这么参考。</p>
<h1 id="ECMAScript-的变量"><a href="#ECMAScript-的变量" class="headerlink" title="ECMAScript 的变量"></a>ECMAScript 的变量</h1><ol>
<li>不建议修改变量所保存值的<strong>类型</strong>。</li>
<li>用 var 操作符定义的变量将成为定义该变量的作用域中的<strong>局部变量</strong>。(即作用域方面的问题)</li>
<li>虽然省略 var 操作符可以定义全局变量，但这也不是我们推荐的做法。<br> 因为在局部作用域中定义的全局变量很难维护，<br> 而且如果有意地忽略了 var 操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。<br> 给<strong>未经声明</strong>的变量赋值在严格模式下会导致抛出 ReferenceError 错误。</li>
<li><p>可以使用一条语句定义多个变量，只要把每个变量用逗号分隔开就行。虽然代码里的换行和变量缩进不是必需的，但这样做可以提高<strong>可读性</strong>。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"hi"</span>,</div><div class="line">    found = <span class="literal">false</span>,</div><div class="line">    age = <span class="number">29</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>在严格模式下，不能定义名为 eval 或 arguments 的变量，否则会导致语法错误。</p>
</li>
</ol>
<h1 id="ECMAScript-的数据类型"><a href="#ECMAScript-的数据类型" class="headerlink" title="ECMAScript 的数据类型"></a>ECMAScript 的数据类型</h1><ol>
<li>五种简单数据类型：<ol>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ol>
</li>
<li>一种复杂数据类型—— Object ， Object 本质上是由一组无序的名值对组成的。</li>
</ol>
<h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><ol>
<li>可能返回的字符串：<br> “undefined” ——如果这个值未定义；<br> “boolean” ——如果这个值是布尔值；<br> “string” ——如果这个值是字符串；<br> “number” ——如果这个值是数值；<br> “object” ——如果这个值是对象或 null ；<br> “function” ——如果这个值是函数。</li>
<li><code>typeof null</code>会返回 “object”，因为特殊值 null 被认为是一个空的对象引用。</li>
<li>从技术角度讲，函数在 ECMAScript 中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 typeof 操作符来区分函数和其他对象是有必要的。</li>
</ol>
<h2 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h2><ol>
<li>显式的 undefined 值 由 ECMAScript 第三版引入，引入这个值的目的是用于比较，为了正式区分空对象指针(引用,null)与未经初始化的变量。<br> undefined 的一个示例：<br> <code>var message;</code> 等同于 <code>var message = undefined;</code></li>
<li><p>对于尚未声明的变量，只能执行一项操作，即使用 typeof 操作符检测其数据类型，然而:</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message; <span class="comment">// 这个变量声明之后默认取得了 undefined 值</span></div><div class="line"><span class="comment">// 下面这个变量并没有声明</span></div><div class="line"><span class="comment">// var age</span></div><div class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// "undefined"</span></div><div class="line">alert(<span class="keyword">typeof</span> age); <span class="comment">// "undefined"</span></div></pre></td></tr></table></figure>
<p> 这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p>
</li>
<li>显式地初始化变量依然是明智的选择。于是 typeof 操作符返回 “undefined”时我们就能确定被检测的变量还没有被声明。(如果声明肯定初始化了不会是 undefined )</li>
</ol>
<h2 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h2><ol>
<li><p>Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null 。从逻辑角度来看， null 值表示一个<strong>空对象指针</strong>，而这也正是使用 typeof 操作符检测 null 值时会返回 “object” 的原因。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> car = <span class="literal">null</span>;</div><div class="line">alert(<span class="keyword">typeof</span> car); <span class="comment">// "object"</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样就可以直接检查知道变量是否已经保存了一个对象的引用。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>)&#123;</div><div class="line">    <span class="comment">// 对 car 对象执行某些操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>实际上， undefined 值是派生自 null 值的,因此相等性测试【相等操作符( == )】：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p> 两者用途完全不同。无论在什么情况下都没有必要把一个变量的值显式地设置为 undefined ，对 null 则不同。只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined 。</p>
</li>
</ol>
<h2 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><ol>
<li><p>虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 <code>Boolean()</code>。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"Hello world!"</span>;</div><div class="line"><span class="keyword">var</span> messageAsBoolean = <span class="built_in">Boolean</span>(message);</div></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">数据类型     转换为 true 的值                 转换为 false 的值</div><div class="line">Boolean     true                          false</div><div class="line">String      任何非空字符串                  "" (空字符串)</div><div class="line">Number      任何非零数字值(包括无穷大)     0和 NaN</div><div class="line">Object      任何对象                       null</div><div class="line">Undefined   n/a                           undefined</div><div class="line">*/</div></pre></td></tr></table></figure>
<p> 这些转换规则对理解流控制语句(如 if 语句)自动执行相应的 Boolean 转换非常重要</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"Hello world!"</span>;</div><div class="line"><span class="keyword">if</span> (message)&#123;</div><div class="line">    alert(<span class="string">"Value is true"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h2><p>ECMScript 没有为整数和浮点数值分别定义不同的数据类型， Number 类型可用于表示所有数值。</p>
<ol>
<li>十进制整数:<br> <code>var intNum = 55; // 整数</code></li>
<li>八进制：<br> <code>var octalNum1 = 070; // 八进制的 56</code></li>
<li>十六进制:<br> <code>var hexNum1 = 0xA; // 十六进制的 10</code></li>
<li>浮点数值：<br> <code>var floatNum1 = 1.1;</code><br> 虽然小数点前面可以没有整数，但我们不推荐这种写法。<br> 保存浮点数值需要的内存空间是保存整数值的两倍，所以 ECMAScript 会不失时机地将浮点数值转换为整数值。<br> 如果小数点后面没有跟任何数字，或者本身表示的就是一个整数，那么这个数值就可以作为整数值来保存。<br> 对于那些极大或极小的数值，可以用 e 表示法(即科学计数法)表示的浮点数值表示。<br> <code>var floatNum = 3.125e7; // 等于 31250000</code><br> 在默认情况下， ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值。</li>
<li>数值范围<ul>
<li><code>Number.MIN_VALUE</code> ：5e-324</li>
<li><code>Number.MAX_VALUE</code> ：1.7976931348623157e+308</li>
<li>一旦超出就会被转换成特殊的 Infinity 值。</li>
<li>如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，因为 Infinity 不是能够参与计算的数值。</li>
<li>判断是不是有穷的，可以用 <code>isFinite()</code> 函数。</li>
<li>访问 <code>Number.NEGATIVE_INFINITY</code> 和 <code>Number.POSITIVE_INFINITY</code> 也可以得到负和正 Infinity 的值。可以想见，这两个属性中分别保存着 -Infinity 和 Infinity 。</li>
</ul>
</li>
<li>NaN<ul>
<li>用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。</li>
<li>在 ECMAScript 中，任何数值除以 0会返回 NaN ，因此不会影响其他代码的执行。</li>
<li>特点1：任何涉及 NaN 的操作(例如 NaN /10)都会返回 NaN ，这个特点在多步计算中有可能导致问题。</li>
<li>特点2： NaN 与任何值都不相等，包括 NaN 本身。针对 NaN 的这两个特点， ECMAScript 定义了 <code>isNaN()</code> 函数。</li>
<li><code>isNaN()</code> 也适用于对象。会首先调用对象的 <code>valueOf()</code> 方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 <code>toString()</code> 方法，再测试返回值。</li>
</ul>
</li>
<li><p><code>Number()</code> 函数</p>
<ul>
<li>如果是对象，则<strong>调用对象的 <code>valueOf()</code> 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN ，则调用对象的 <code>toString()</code> 方法，然后再次依照前面的规则转换返回的字符串值。</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">"Hello world!"</span>); <span class="comment">//NaN</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">""</span>); <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">"000011"</span>); <span class="comment">//11</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">//1</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>parseInt()</code></p>
<ul>
<li><p>由于 <code>Number()</code> 函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是 parseInt() 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>); <span class="comment">// 1234</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">""</span>); <span class="comment">// NaN</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>); <span class="comment">// 10(十六进制数)</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>); <span class="comment">// 22</span></div><div class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>); <span class="comment">// 56(八进制数)</span></div><div class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>); <span class="comment">// 70(十进制数)</span></div><div class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">"0xf"</span>); <span class="comment">// 15(十六进制数)</span></div></pre></td></tr></table></figure>
</li>
<li><p>版本的分歧。在 ECMAScript 3 JavaScript 引擎中， “070” 被当成八进制字面量，因此转换后的值是十进制的 56。而在 ECMAScript 5 JavaScript 引擎中， <code>parseInt()</code> 已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成 “70” ，结果就得到十进制的 70。在 ECMAScript 5 中，即使是在非严格模式下也会如此。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ECMAScript 3 认为是 56(八进制)， ECMAScript 5 认为是 70(十进制)</span></div><div class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">"070"</span>);</div></pre></td></tr></table></figure>
<p>所以要使用第二个参数指定进制基数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>, <span class="number">16</span>); <span class="comment">//175</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>); <span class="comment">//NaN</span></div></pre></td></tr></table></figure>
</li>
<li><p>建议无论在什么情况下都明确指定基数。</p>
</li>
</ul>
</li>
<li><code>parseFloat()</code><ul>
<li>字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。</li>
<li><code>parseFloat()</code> 与 parseInt() 的第二个区别在于它始终都会忽略前导的零。十六进制格式的字符串则始终会被转换成 0 。</li>
<li><code>parseFloat()</code> 只解析十进制值。如果字符串包含的是一个可解析为整数的数(没有小数点，或者小数点后都是零)， <code>parseFloat()</code> 会返回整数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234 (整数)</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>); <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>); <span class="comment">//22.5</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>); <span class="comment">//22.34</span></div><div class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>); <span class="comment">//908.5</span></div><div class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>); <span class="comment">//31250000</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="parseInt和0-1-0-2的陷阱-所以要用parseFloat"><a href="#parseInt和0-1-0-2的陷阱-所以要用parseFloat" class="headerlink" title="parseInt和0.1+0.2的陷阱(所以要用parseFloat)"></a><code>parseInt</code>和<code>0.1+0.2</code>的陷阱(所以要用<code>parseFloat</code>)</h3><p><code>parse(0.0000001)==1</code>，而<code>parseInt(0.01) == 0</code></p>
<ul>
<li><strong>原因</strong>:<ol>
<li><code>parseInt</code> 会先调用 <code>toString</code> 方法。</li>
<li>对于小于 <code>1e-6</code> 的数值来说，<code>toString</code> 时会自动转换为科学计数法。</li>
<li>0.0000001会被转换成<code>&quot;1e-7&quot;</code></li>
<li>于是<code>parseInt(0.0000001)</code>就会变成<code>parseInt(&quot;1e-7&quot;)</code></li>
<li>因为<code>parseInt</code>不认识字符串形式的科学计数法，所以直接匹配字符串数字，<code>&quot;1e-7&quot;</code>就匹配到第一个数字1。</li>
</ol>
</li>
<li><strong>另一示例</strong>:  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="number">1</span>/<span class="number">1000001</span>) <span class="comment">//即 parseInt("9.99999000001e-7")</span></div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。<br>例如，0.1 加 0.2的结果不是 0.3，而是 0.30000000000000004。<br>这是使用基于 IEEE754 数值的浮点计算的通病， ECMAScript 并非独此一家。<br>但是别的语言一般有内置的标准库来解决这个问题，比如 BigDecimal 。<br>因此，永远不要测试某个特定的浮点数值。<br>解决方法1：使用 JavaScript 内置的函数 toPrecision 或 toFixed 来保留一定的精度。<br>解决方法2：<code>Math.round((0.1+0.2)*100)/100;//0.3</code><br>解决方法3：使用 BigDecimal 。其他语言有标准类库， js 没有内置的 BigDecimal 的库，要找一些第三方的来完成。</p>
<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><ol>
<li>拼接变量：首先创建一个能容纳 10 个字符的新字符串，然后在这个字符串中填充 “Java” 和 “Script” ，最后一步是销毁原来的字符串 “Java” 和字符串 “Script” ，因为这两个字符串已经没用了。这也是在某些旧版本的浏览器(例如版本低于 1.0 的 Firefox 、 IE6 等)中拼接字符串时速度很慢的原因所在。</li>
<li>数值、布尔值、对象和字符串值(没错，每个字符串也都有一个 <code>toString()</code> 方法，该方法返回字符串的一个副本)都有 <code>toString()</code> 方法。但 null` 和 undefined 值没有这个方法。</li>
<li><code>toString()</code> 可以输出以二进制、八进制、十六进制乃至其他任意有效进制格式表示的字符串值。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toString()); <span class="comment">// "10"</span></div><div class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">// "1010"</span></div><div class="line">alert(num.toString(<span class="number">8</span>)); <span class="comment">// "12"</span></div><div class="line">alert(num.toString(<span class="number">10</span>)); <span class="comment">// "10"</span></div><div class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">// "a"</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><ol>
<li><p>ECMAScript 中的对象其实就是一组数据和功能的集合。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 有效，但不推荐省略圆括号</span></div></pre></td></tr></table></figure>
</li>
<li><p>在 ECMAScript 中，(就像 Java 中的 java.lang.Object 对象一样) Object 类型是所有它的实例的基础。换句话说， Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。所有对象都具有这些基本的属性和方法。</p>
<ul>
<li><strong>constructor</strong> ：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数(constructor)就是 Object() 。</li>
<li><strong>hasOwnProperty(propertyName)</strong> ：用于检查给定的属性在当前对象实例中(而不是在实例的原型中)是否存在。其中，作为参数的属性名( propertyName )必须以字符串形式指定(例如： o.hasOwnProperty(“name”) )。</li>
<li><strong>isPrototypeOf(object)</strong> ：用于检查传入的对象是否是传入对象的原型。</li>
<li><strong>propertyIsEnumerable(propertyName)</strong> ：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 <code>hasOwnProperty()</code> 方法一样，作为参数的属性名必须以字符串形式指定。</li>
<li><strong>toLocaleString()</strong> ：返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li><strong>toString()</strong> ：返回对象的字符串表示。</li>
<li><strong>valueOf()</strong> ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。</li>
</ul>
</li>
<li>ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。 BOM 和 DOM 中的对象，都属于宿主对象， ECMA-262 不负责定义宿主对象，因此宿主对象可能会也可能不会继承 Object 。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第二章]]></title>
      <url>http://codingme.xyz/2016/09/10/javascript-note-2/</url>
      <content type="html"><![CDATA[<h1 id="script-元素的-defer"><a href="#script-元素的-defer" class="headerlink" title="script 元素的 defer"></a>script 元素的 defer</h1><p><strong>defer</strong> 延迟脚本。<br>效果：在页面解析时候下载脚本，可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。(HTML 4.01时定义)</p>
<ul>
<li>在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。</li>
<li>把延迟脚本放在页面底部仍然是最佳选择。</li>
<li>defer 属性在浏览器之间表现并不一致。 defer 属性只被 IE 4 和 Firefox 3.5 更高版本的浏览器所支持，所以它不是一个理想的跨浏览器解决方案。在其他浏览器中， defer 属性会被直接忽略，因此<code>&lt;script&gt;</code>标签会以默认的方式处理，也就是说会造成阻塞。</li>
<li>为了避免跨浏览器的差异，可以使用 “ lazy loading ”的方法，即直到用到该脚本时才加载。</li>
<li>在 XHTML 文档中，要把 defer 属性设置为 defer=”defer” 。 async 同理。</li>
</ul>
<h1 id="script-元素的-async"><a href="#script-元素的-async" class="headerlink" title="script 元素的 async"></a>script 元素的 async</h1><p><strong>async</strong> 异步脚本。<br>效果：下载脚本同时不影响页面解析，当下载完毕后就执行，执行完接着页面解析。只对外部脚本文件有效。<br>Google Analytics 就是适合使用 async 的脚本；<br>还有下载其他资源。<br>目的：不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。</p>
<ul>
<li>标记为 async 的脚本并不保证按照指定它们的先后顺序执行。因此，确保互不依赖非常重要。</li>
<li>建议异步脚本不要在加载期间修改 DOM 。</li>
<li>异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</li>
</ul>
<a id="more"></a>
<h1 id="MIME-类型"><a href="#MIME-类型" class="headerlink" title="MIME 类型"></a>MIME 类型</h1><ul>
<li>即 type 。表示编写代码使用的脚本语言的内容类型。</li>
<li>如果是 Apache Web 服务器，可以通过 .htaccess 文件设置 MIME 类型。类似：<br>  .htaccess 文件中添加 MIME 类型：<br>  AddType video/ogg .ogv<br>  AddType video/mp4 .mp4<br>  AddType video/webm .webm<br>  AddType audio/ogg .ogg<br>  AddType audio/mp3 .mp3</li>
</ul>
<h1 id="script-元素的-src-属性"><a href="#script-元素的-src-属性" class="headerlink" title="script 元素的 src 属性"></a>script 元素的 src 属性</h1><ul>
<li>如果使用了 src 属性的值是一个指向外部 JavaScript 文件的链接，那么内部嵌入的代码会被忽略。</li>
<li>正常的 &lt;script&gt; 元素在解析外部 JavaScript 文件(包括下载该文件)时，页面的处理会暂时停止。所以使用 async 和 defer 可以在下载该文件时不妨碍页面的处理。</li>
<li>外部 JavaScript 文件带有.js 扩展名。但这个扩展名不是必需的这样一来，使用 JSP 、 PHP 或其他服务器端语言动态生成 JavaScript 代码也就成为了可能。但是，服务器通常还是需要看扩展名决定为响应应用哪种 MIME 类型。如果不使用.js 扩展名，请确保服务器能返回正确的 MIME 类型。</li>
<li>src 属性还可以包含来自外部域的 JavaScript 文件。这点备受争议。如果想包含来自不同域的代码，则要么你是那个域的所有者，要么那个域的所有者值得信赖。否则会有安全隐患。</li>
</ul>
<h1 id="script-元素的注意事项"><a href="#script-元素的注意事项" class="headerlink" title="script 元素的注意事项"></a>script 元素的注意事项</h1><ul>
<li>脚本执行和页面的渲染是共用一个线程。</li>
<li>在解释器对 &lt;script&gt; 元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。</li>
<li>使用 <code>&lt;script&gt;</code> 嵌入 JavaScript 代码时，记住不要在代码中的任何地方出现 “<code>&lt;/script&gt;</code>“ 字符串。</li>
<li>一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript 代码。<br>  优点有：<br>  可维护性；<br>  可缓存；<br>  适应未来。</li>
</ul>
<h1 id="script-元素与-XHTML"><a href="#script-元素与-XHTML" class="headerlink" title="script 元素与 XHTML"></a>script 元素与 XHTML</h1><p>比较语句 a &lt; b 中的小于号(&lt;)在 XHTML 中将被当作开始一个新标签来解析。但是作为标签来讲，小于号后面不能跟空格，因此就会导致语法错误。</p>
<ul>
<li>解决方法1：使用字符实体来代替小于号(&lt;)，比如 &lt; 。</li>
<li>解决方法2：使用一个 CData 片段来包含 JavaScript 代码。示例：  <figure class="highlight xhtml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">&lt;![CDATA[   <span class="comment">//不兼容 XHTML 的话将此行注释掉。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (a &lt; b) &#123;</div><div class="line">alert(<span class="string">"A is less than B"</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) &#123;</div><div class="line">alert(<span class="string">"A is greater than B"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">alert(<span class="string">"A is equal to B"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">]]&gt;    <span class="comment">//不兼容 XHTML 的话将此行注释掉。</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>将页面的 MIME 类型指定为 “application/xhtml+xml” 的情况下会触发 XHTML 模式。并不是所有浏览器都支持以这种方式提供 XHTML 文档。</p>
<h1 id="文档模式与文档类型-doctype"><a href="#文档模式与文档类型-doctype" class="headerlink" title="文档模式与文档类型(doctype)"></a>文档模式与文档类型(doctype)</h1><ul>
<li>IE 5.5 引入了文档模式的概念，而这个概念是通过使用文档类型(doctype)切换实现的。</li>
<li>最初两种文档模式：混杂模式(quirks mode)和标准模式(standards mode)。混杂模式也称作怪异模式。</li>
<li>混杂模式会让 IE 的行为与 IE5 相同,而标准模式则让 IE 的行为更接近标准行为。</li>
<li>这两种模式主要影响 CSS 内容的呈现，但在某些情况下也会影响到 JavaScript 的解释执行。</li>
<li>之后， IE 又提出一种所谓的准标准模式(almost standards mode)。这种模式下的浏览器特性有很多都是符合标准的，但也不尽然。不标准的地方主要体现在处理图片间隙的时候(在表格中使用图片时问题最明显)。</li>
<li>准标准模式与标准模式非常接近，它们的差异几乎可以忽略不计。因此，当有人提到“标准模式”时，有可能是指这两种模式中的任何一种。</li>
<li>如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。</li>
<li>采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。</li>
</ul>
<h2 id="标准模式-包含-HTML-的严格模式-版本"><a href="#标准模式-包含-HTML-的严格模式-版本" class="headerlink" title="标准模式(包含 HTML 的严格模式/版本)"></a>标准模式(包含 HTML 的严格模式/版本)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- HTML 4.01 严格型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"</span></div><div class="line">"http://www.w3.org/TR/html4/strict.dtd"&gt;</div><div class="line"><span class="comment">&lt;!-- XHTML 1.0 严格型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC</span></div><div class="line">"-//W3C//DTD XHTML 1.0 Strict//EN"</div><div class="line">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</div><div class="line"><span class="comment">&lt;!-- HTML 5 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div></pre></td></tr></table></figure>
<h2 id="准标准模式-有框架集版本、过渡版本"><a href="#准标准模式-有框架集版本、过渡版本" class="headerlink" title="准标准模式(有框架集版本、过渡版本)"></a>准标准模式(有框架集版本、过渡版本)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- HTML 4.01 过渡型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC</span></div><div class="line">"-//W3C//DTD HTML 4.01 Transitional//EN"</div><div class="line">"http://www.w3.org/TR/html4/loose.dtd"&gt;</div><div class="line"><span class="comment">&lt;!-- HTML 4.01 框架集型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC</span></div><div class="line">"-//W3C//DTD HTML 4.01 Frameset//EN"</div><div class="line">"http://www.w3.org/TR/html4/frameset.dtd"&gt;</div><div class="line"><span class="comment">&lt;!-- XHTML 1.0 过渡型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC</span></div><div class="line">"-//W3C//DTD XHTML 1.0 Transitional//EN"</div><div class="line">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</div><div class="line"><span class="comment">&lt;!-- XHTML 1.0 框架集型 --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC</span></div><div class="line">"-//W3C//DTD XHTML 1.0 Frameset//EN"</div><div class="line">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt;</div></pre></td></tr></table></figure>
<h1 id="noscript-元素"><a href="#noscript-元素" class="headerlink" title="noscript 元素"></a>noscript 元素</h1><p>浏览器不支持 JavaScript 时如何让页面平稳地退化。于是 noscript 诞生。<br>这个元素可以包含能够出现在文档 <code>&lt;body&gt;</code> 中的任何 HTML 元素—— <code>&lt;script&gt;</code> 元素除外。<br>包含在 <code>&lt;noscript&gt;</code> 元素中的内容只有在下列情况下才会显示出来：</p>
<ul>
<li>浏览器不支持脚本；</li>
<li>浏览器支持脚本，但脚本被禁用。</li>
</ul>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">"defer"</span> <span class="attr">src</span>=<span class="string">"example1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">"defer"</span> <span class="attr">src</span>=<span class="string">"example2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> 本页面需要浏览器支持(启用)JavaScript 。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 JavaScript 高级程序设计》备忘-第一章]]></title>
      <url>http://codingme.xyz/2016/09/09/javascript-note-1/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript-的诞生："><a href="#JavaScript-的诞生：" class="headerlink" title="JavaScript 的诞生："></a>JavaScript 的诞生：</h1><p>以前必须把表单数据发送到服务器端才能确定用户是否没有填写某个必填域。<br>Netscape Navigator 希望通过 JavaScript 来解决这个问题。<br>于是 JavaScript 诞生，当时主要目的是处理以前由服务器端语言负责的一些输入验证操作。<br>它从一个简单的输入验证器发展成为一门强大的编程语言。</p>
<h1 id="JavaScript-、-ECMAScript-历史："><a href="#JavaScript-、-ECMAScript-历史：" class="headerlink" title="JavaScript 、 ECMAScript 历史："></a>JavaScript 、 ECMAScript 历史：</h1><ol>
<li>Netscape navigator 2诞生, JavaScript 诞生。</li>
<li>IE 的 JScript 。</li>
<li>标准化， ECMA-262，即 ECMAScript 诞生。</li>
<li>ECMAScript 与 Web 浏览器没有依赖关系,Web 浏览器只是 ECMAScript 实现可能的宿主环境之一。</li>
<li>ECMA-262 定义的只是这门语言的基础。</li>
<li>JavaScript 包含 <strong>ECMAScript</strong> 、 <strong>DOM</strong> 、 <strong>BOM</strong> 三个部分。</li>
</ol>
<a id="more"></a>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><ul>
<li>针对 XML 但经过扩展用于 HTML 的应用程序编程接口(API,Application Programming Interface)</li>
<li>DOM 目的：允许您使用 JavaScript 动态创建 HTML 的几乎全部文档内容。</li>
<li>为什么要用 DOM ?<br>  IE 4 和 网景浏览器 4 分别支持不同形式的 DHTML 。怕出现技术割据互不兼容，于是 W3C 开始着手规划 DOM 。<br>  DOM 并不只是针对 JavaScript 的，很多别的语言也都实现了 DOM 。不过，在 Web 浏览器中，基于 ECMAScript 实现的 DOM 的确已经成为 JavaScript 这门语言的一个重要组成部分。</li>
</ul>
<h2 id="DOM-1-级"><a href="#DOM-1-级" class="headerlink" title="DOM 1 级"></a>DOM 1 级</h2><p>目标主要是映射文档的结构。(DOM1 级 于 1998 年 10 月成为 W3C 的推荐标准。)</p>
<ul>
<li><strong>DOM 核心(DOM Core)</strong>，规定如何映射基于 XML 的文档结构；</li>
<li><strong>DOM HTML</strong> ，在前者基础上扩展，添加了针对 HTML 的对象和方法。</li>
</ul>
<h2 id="DOM-2-级"><a href="#DOM-2-级" class="headerlink" title="DOM 2 级"></a>DOM 2 级</h2><p>原来 DOM 的基础上又扩充了许多细分模块。而且通过对象接口增加了对 CSS 的支持。</p>
<ul>
<li><strong>DOM 视图(DOM Views)</strong>，定义了跟踪不同文档视图的接口；</li>
<li><strong>DOM 事件(DOM Events)</strong>：定义了事件和事件处理的接口；</li>
<li><strong>DOM 样式(DOM Style)</strong>：定义了基于 CSS 为元素应用样式的接口；</li>
<li><strong>DOM 遍历和范围(DOM Traversal and Range)</strong>：定义了遍历和操作文档树的接口。</li>
</ul>
<h2 id="DOM-3-级"><a href="#DOM-3-级" class="headerlink" title="DOM 3 级"></a>DOM 3 级</h2><ul>
<li><strong>DOM 加载和保存(DOM Load and Save)</strong>：引入了以统一方式加载和保存文档的方法；</li>
<li><strong>DOM 验证(DOM Validation)</strong>：新增了验证文档的方法；</li>
<li>对 DOM 核心进行了扩展，开始<strong>支持 XML 1.0 规范</strong>，涉及 XML Infoset 、 XPath 和 XML Base 。</li>
</ul>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><ul>
<li>在 HTML5 之前， BOM 的问题在于他作为 JavaScript 的一部分却没有相关标准。</li>
<li>根本上讲， BOM 只处理浏览器窗口和框架；</li>
<li>但人们习惯上也把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。 比如：<br>  弹出新浏览器窗口的功能；<br>  移动、缩放和关闭浏览器窗口的功能；<br>  提供浏览器详细信息的 navigator 对象；<br>  提供浏览器所加载页面的详细信息的 location 对象；<br>  提供用户显示器分辨率详细信息的 screen 对象；<br>  对 cookies 的支持；<br>  像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象。</li>
</ul>
<h1 id="JavaScript-版本"><a href="#JavaScript-版本" class="headerlink" title="JavaScript 版本"></a>JavaScript 版本</h1><p>大多数浏览器在提及对 JavaScript 的支持情况时，一般都以 ECMAScript 兼容性和对 DOM 的支持情况为准。</p>
<h1 id="HTML-、-CSS-版本联动"><a href="#HTML-、-CSS-版本联动" class="headerlink" title="HTML 、 CSS 版本联动"></a>HTML 、 CSS 版本联动</h1><ul>
<li>当早期的浏览器 Netscape 4 和 Explorer 4 对 css 进行解析时，并未遵守 W3C 标准，这时的解析方式就被我们称之为 quirks mode (怪异模式)。</li>
<li>怪异模式的主要目的就是向后兼容(向下兼容)，兼容旧版浏览器。在怪异模式下，排版会模拟 Navigator 4 与 Internet Explorer 5 的非标准行为。</li>
<li>怪异模式与标准模式的具体的最大不同在于盒模型的解释上。<br>  怪异模式的盒模型宽度：元素的实际宽度 width ，不包含 margin 、 border 、 padding 。<br>  标准模式(包含 HTML 严格模式)的盒模型宽度： margin + padding + border + 元素的实际宽度 width 。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 HTML5 与 CSS3基础教程》备忘5]]></title>
      <url>http://codingme.xyz/2016/09/06/html-css-diary-5/</url>
      <content type="html"><![CDATA[<h1 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h1><ol>
<li><code>type=&quot;radio&quot;</code> ，例子：性别的单选按钮。</li>
<li>两个按钮的 name 属性都是 gender ，相同 name 才能实现同一时间只有其中一个能被选中。</li>
<li>value 属性设置值，因为对于单选按钮访问者无法输入值。</li>
<li>输入 checked 或者 <code>checked=&quot;checked&quot;</code> 让该单选按钮在页面打开时默认处于激活状态</li>
</ol>
<h1 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h1><ol>
<li><code>type=&quot;checkbox&quot;</code> ,例子：选择订阅推送。</li>
<li>name 属性相同，<code>name=&quot; boxset &quot;</code>。(如果使用 PHP 处理表单，使用 name=” boxset[] “)</li>
<li>value 属性设置值，因为对于复选按钮访问者无法输入值。</li>
<li>checked 方面跟单选按钮一样。</li>
</ol>
<h1 id="textarea-元素，文本区域"><a href="#textarea-元素，文本区域" class="headerlink" title="textarea 元素，文本区域"></a>textarea 元素，文本区域</h1><ol>
<li>rows 和 cols 属性分别控制文本区域的高度和宽度，除非使用 CSS 覆盖其中之一或者全部。</li>
<li>textarea 没有 value 属性，所以如果想要预设文本要直接在 textarea 标签之间添加文本。</li>
</ol>
<a id="more"></a>
<h1 id="下拉选择框"><a href="#下拉选择框" class="headerlink" title="下拉选择框"></a>下拉选择框</h1><ul>
<li><p>用 select 和 option 元素</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"state"</span>&gt;</span>State:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"state"</span> <span class="attr">name</span>=<span class="string">"state"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"AL"</span>&gt;</span>Alabama<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"AK"</span>&gt;</span>Alaska<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line">...</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>size=”n”， n 代表选择框高度。如果不设置就必须选择一个选择项。设置后菜单显示为一个有滚动条的列表，默认没有选中任何一项。</p>
</li>
<li>option 元素的属性： selected 或者 <code>selected=&quot;selected&quot;</code> ，指定该选项默认被选中。</li>
<li>option 元素也是有 label 属性可替代中间的文本，不过 Firefox 不支持这一属性，所以最好不用。</li>
<li>如果需要对选择项进行分组，使用 optgroup 元素，带有 label 属性。</li>
</ul>
<h1 id="上传文件的设置"><a href="#上传文件的设置" class="headerlink" title="上传文件的设置"></a>上传文件的设置</h1><ol>
<li>对于 input 要设置 <code>type=&quot;file&quot;</code>,对于 form 要设置<code>&lt;form method=&quot;post&quot; action=&quot;show-data.php&quot;enctype=&quot;multipart/form-data&quot;&gt;</code></li>
<li>multiple 属性可以允许上传多个文件(IE10+ 支持，移动端忽略)</li>
<li>对于 type=”file” 的 input 元素，浏览器会自动创建 Browse(浏览)按钮。 Chrome 和 Safari 不会创建框，它们只显示按钮。</li>
</ol>
<h1 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h1><ol>
<li>例子：<code>&lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;6&quot; /&gt;</code><br> 访问者不会看到这个输入框，但他们提交表单的时候，名 “ step ” 和值 “6” 会随着表单中从访问者输入获取的数据一起传送给服务器。</li>
<li><code>&lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;&lt;?= $email ?&gt;&quot; /&gt;</code><br> 创建隐藏字段时，可以使用脚本中的变量将字段的值设置为访问者原来输入的值(这个示例使用了 PHP 语法)</li>
<li>隐藏字段用法：<br> 用来处理那些你不想在表单页面里编辑和显示 ，但是又必须跟随表单填写者填写的其他信息，例如当前时间。<br> <code>&lt;input type=&quot;hidden&quot; name=&quot;time&quot; value=&quot;&lt;%=NowTime%&gt;&quot;&gt;</code></li>
</ol>
<h1 id="disabled-和-readonly"><a href="#disabled-和-readonly" class="headerlink" title="disabled 和 readonly"></a>disabled 和 readonly</h1><p>readonly 可以获得焦点，访问者可以选择和复制里面的文本，但不能修改，只能用于文本框和文本区域。</p>
<h1 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h1><ol>
<li>除了典型的 <code>type=&quot;submit&quot;</code> 外，还可以用 <code>type=&quot;image&quot;</code> 使用图像形式的提交按钮。</li>
<li>创建结合文本和图像的提交按钮可以用 button 元素。(依然使用 <code>type=&quot;submit&quot;</code> 。其中除了文字还包含 <code>&lt;img&gt;</code>)<br> (使用 button 元素要注意考虑 IE8 之前的兼容问题)</li>
<li>如果有多个提交按钮，可以为每个按钮设置 name 属性和 value 属性。<br> 否则 name 属性最好省略。<br> 如果需要多个提交按钮就应避免使用 button 。</li>
</ol>
<h1 id="表单的重置"><a href="#表单的重置" class="headerlink" title="表单的重置"></a>表单的重置</h1><ol>
<li><code>&lt;input type=&quot;reset&quot; /&gt;</code> 或 <code>&lt;button type=&quot;reset&quot;&gt;Reset&lt;/button&gt;</code></li>
<li><code>&lt;input type=&quot;button&quot; value=&quot;这个用 JavaScript 清除&quot;onclick=&quot;document.getElementById(&#39;form1&#39;).reset()&quot;/&gt;</code></li>
</ol>
<h1 id="禁用验证功能"><a href="#禁用验证功能" class="headerlink" title="禁用验证功能"></a>禁用验证功能</h1><p>HTML5 对 <code>type=&quot;email&quot;</code> 和 <code>type=&quot;URL&quot;</code> 的 input 添加了自动验证功能。对提交按钮使用 formnovalidate 属性可以关闭该功能，如 <code>&lt;input type=&quot;submit&quot; formnovalidate /&gt;</code> 。</p>
<h1 id="禁用表单元素"><a href="#禁用表单元素" class="headerlink" title="禁用表单元素"></a>禁用表单元素</h1><p>例子：当选择了 Others 的时候， textarea 才可以访问修改输入文本。<br>方式：</p>
<ol>
<li>将 textarea 设为 disabled ；</li>
<li>在最后 <code>&lt;/body&gt;</code> 之前添加 script 引入了一个 JavaScript 文件。该文件包含了一段脚本，其作用是当用户选择 Other(其他)单选按钮时，让 textarea 变为可用的，选择其余两个单选按钮中的任意一个，则会禁用 textarea 。</li>
</ol>
<h1 id="活用伪类"><a href="#活用伪类" class="headerlink" title="活用伪类"></a>活用伪类</h1><ol>
<li>利用和相邻同胞结合符+,实现选择框勾中后文字变色、选择输入框时输入框背景颜色改变等。</li>
<li>给 form 元素一个类，对于该类所有 input 子元素有 <code>:invalid</code> 伪类的颜色设置为红色。</li>
</ol>
<h1 id="多媒体元素属性"><a href="#多媒体元素属性" class="headerlink" title="多媒体元素属性"></a>多媒体元素属性</h1><ol>
<li>使用控件 controls 属性。</li>
<li>预加载 preload 默认 auto ，可设 metadata 和 none 。</li>
</ol>
<h1 id="旧浏览器兼容-html5-多媒体"><a href="#旧浏览器兼容-html5-多媒体" class="headerlink" title="旧浏览器兼容 html5 多媒体"></a>旧浏览器兼容 html5 多媒体</h1><ol>
<li>mediaelement.js(mediaelementjs.com/)</li>
<li>Video.js(www.videojs.com)、</li>
<li>JW Player (www.longtailvideo.com/jw-player/)</li>
<li>Flowplayer(flowplayer.org)</li>
</ol>
<p>JW Player 和 Flowplayer 的免费版本会在媒体播放器上显示它们的标识。</p>
<h1 id="表格的属性"><a href="#表格的属性" class="headerlink" title="表格的属性"></a>表格的属性</h1><ol>
<li>对于标题单元格 th ，使用 scope 属性 (col/row/colgroup/rowgroup)</li>
<li>如果有 caption 元素则必定是 table 中第一个元素。</li>
<li>thead 和 tfoot 每个 table 只能各有一个。</li>
<li>如果有了 thead 和 tfoot 则必定要有 tbody 。</li>
<li>table 嵌套在 figure 中时可以省略掉 caption 直接用 figcaption 。</li>
<li>当使单元格跨越多行多列时使用 colspan 和 rowspan 属性。</li>
<li>如果<strong>正下列正好是标题单元格的内容</strong>的话，可以用 <code>scope=&quot;rowgroup&quot;</code> 属性。<br> 例子： th 为 Time ,正下列为各个时间。</li>
</ol>
<h1 id="表格的相关-CSS-设置"><a href="#表格的相关-CSS-设置" class="headerlink" title="表格的相关 CSS 设置"></a>表格的相关 CSS 设置</h1><ol>
<li><code>border-collapse:collapse;</code> 能<strong>合并重复的单元格边框</strong>。<br> (默认值为 <code>border-collapse:separate;</code> )</li>
<li>不同的浏览器显示的样式稍有差异，尤其是 <code>Internet Explorer</code>。</li>
</ol>
<h1 id="JavaScript-的部分注意事项"><a href="#JavaScript-的部分注意事项" class="headerlink" title="JavaScript 的部分注意事项"></a>JavaScript 的部分注意事项</h1><ol>
<li><code>&lt;script&gt;</code> 标签在大多数情况下最好在页面的<strong>最末尾</strong>加载，即<code>&lt;/body&gt;</code>前面</li>
<li>保持组织文件良好，通常将 JavaScript 文件放在一个<strong>子文件夹</strong>中。</li>
<li>通常，<strong>压缩后的脚本</strong>以 <strong>.min.js</strong> 作为扩展名</li>
</ol>
<h1 id="JavaScript-的阻塞行为"><a href="#JavaScript-的阻塞行为" class="headerlink" title="JavaScript 的阻塞行为"></a>JavaScript 的阻塞行为</h1><ol>
<li>默认情况下，浏览器会按照脚本在 HTML 中出现的顺序对它们进行加载。</li>
<li>在处理脚本的过程中，浏览器既不会下载该 script 元素后面出现的内容(哪怕是文本)，也不会呈现这些内容。这称为<strong>阻塞行为</strong>。</li>
<li>消除 JavaScript 阻塞最简单的方法就是将所有的 script 元素放置在 HTML 结束之前，即 <code>&lt;/body&gt;</code> 结束标签的前面。</li>
<li>如果确实需要在 head 中加载脚本，也要将它们放置在所有加载 CSS 文件的 link 元素之后(这也是出于性能的考虑)。</li>
<li>另一种简单的加快脚本加载速率的方法就是将 JavaScript 放在同一个文件中(或尽可能少的一些文件中)并压缩代码。</li>
</ol>
<h1 id="压缩脚本工具"><a href="#压缩脚本工具" class="headerlink" title="压缩脚本工具"></a>压缩脚本工具</h1><ul>
<li><strong>Google Closure Compiler</strong><br>  <a href="http://code.google.com/closure/compiler/" target="_blank" rel="external">http://code.google.com/closure/compiler/</a>(供下载的版本及文档)<br>  <a href="http://closure-compiler.appspot.com/" target="_blank" rel="external">http://closure-compiler.appspot.com/</a>(在线版本)</li>
<li><strong>UglifyJS</strong>(使用第二个链接)<br>  <a href="https://github.com/mishoo/UglifyJS2/" target="_blank" rel="external">https://github.com/mishoo/UglifyJS2/</a>(供下载的版本及文档)<br>  <a href="http://lisperator.net/uglifyjs/" target="_blank" rel="external">http://lisperator.net/uglifyjs/</a>(在线版本，选择“ Open demo ”)</li>
<li><strong>YUI Compressor</strong>(使用第二个链接)<br>  <a href="http://developer.yahoo.com/yui/compressor/" target="_blank" rel="external">http://developer.yahoo.com/yui/compressor/</a>(供下载的版本及文档)<br>  <a href="http://refresh-sf.com/yui/" target="_blank" rel="external">http://refresh-sf.com/yui/</a>(非官方的在线版本)</li>
</ul>
<h1 id="验证代码"><a href="#验证代码" class="headerlink" title="验证代码"></a>验证代码</h1><ol>
<li>HTML 的代码验证：<ul>
<li><a href="http://validator.w3.org/" target="_blank" rel="external">http://validator.w3.org/</a></li>
<li><a href="http://html5.validator.nu/" target="_blank" rel="external">http://html5.validator.nu/</a><br>感觉部分验证过于注重“正统”..</li>
</ul>
</li>
<li>CSS 的代码验证：<br> <a href="http://jigsaw.w3.org/css-validator/" target="_blank" rel="external">http://jigsaw.w3.org/css-validator/</a><br> 依然是过于注重“正统”的感觉….</li>
<li>Lint<br> 有 HTML Lint ,也有各种各样的 Lint 。<br> 有在线的，也有本地的；<br> 有单独的，也有插件式的。</li>
</ol>
<h1 id="浏览器开发工具"><a href="#浏览器开发工具" class="headerlink" title="浏览器开发工具"></a>浏览器开发工具</h1><ol>
<li>Chrome DevTools<br> <a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="external">https://developers.google.com/web/tools/chrome-devtools/</a></li>
<li>Firebug<br> <a href="http://getfirebug.com/" target="_blank" rel="external">http://getfirebug.com/</a></li>
<li>Web Developer<br> <a href="http://chrispederick.com/work/web-developer/" target="_blank" rel="external">http://chrispederick.com/work/web-developer/</a></li>
</ol>
<p>此外还有 Internet Explorer ： F12 Developer Tools 、 Opera ： Dragonfly 、 Safari ： Web Inspector 等。</p>
<h1 id="Web-分析"><a href="#Web-分析" class="headerlink" title="Web 分析"></a>Web 分析</h1><ul>
<li>谷歌分析： <a href="https://www.google.com/analytics/" target="_blank" rel="external">https://www.google.com/analytics/</a></li>
<li>百度统计： <a href="http://tongji.baidu.com/" target="_blank" rel="external">http://tongji.baidu.com/</a></li>
<li>腾讯分析: <a href="http://ta.qq.com/" target="_blank" rel="external">http://ta.qq.com/</a></li>
<li>CNZZ &amp;友盟统计：<br>  <a href="https://web.umeng.com/main.php?c=user&amp;a=index/" target="_blank" rel="external">https://web.umeng.com/main.php?c=user&amp;a=index/</a><br>  <a href="http://www.cnzz.com/o_index.php/" target="_blank" rel="external">http://www.cnzz.com/o_index.php/</a></li>
<li>不蒜子统计： <a href="http://service.ibruce.info/" target="_blank" rel="external">http://service.ibruce.info/</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 HTML5 与 CSS3 基础教程》备忘4]]></title>
      <url>http://codingme.xyz/2016/09/01/html-css-diary-4/</url>
      <content type="html"><![CDATA[<h1 id="sprite"><a href="#sprite" class="headerlink" title="sprite"></a>sprite</h1><ul>
<li>目的：<br>  将多个图像拼合成单个背景图像(sprite)，再通过 CSS 控制具体显示图像的哪一部分，从而减少多个图像的 HTTP 请求问题。常用于 UI 上的多个小图标、重复图标等。</li>
<li>使用方法：<br>  <code>background-image</code> 获得图像，<code>background-position</code> 获得所取的具体位置(目前只知道 x 范围和 y 范围，但想必还可以更加深入的切取)</li>
<li>工具：<br>  可以多个图片合成一张 sprite 的 CSS Sprite Generator:<a href="http://spritegen.website-performance.org/" target="_blank" rel="external">http://spritegen.website-performance.org/</a></li>
<li>关于 Retina 显示屏：<br>  使用长宽双倍大小像素的图片，一样的容器长宽，使其缩小。</li>
</ul>
<h1 id="列表的缩进对齐"><a href="#列表的缩进对齐" class="headerlink" title="列表的缩进对齐"></a>列表的缩进对齐</h1><p>默认的列表要左缩进对齐的话，用<code>padding-left:1.125em</code>，但是针对 IE7 及以下版本，还要使用<code>margin-left:0;</code></p>
<h1 id="ol-、-ul-的选择"><a href="#ol-、-ul-的选择" class="headerlink" title="ol 、 ul 的选择"></a>ol 、 ul 的选择</h1><p>会因为顺序改变而改变的列表，使用有序列表，比如<strong>分页标记</strong>、<strong>面包屑导航</strong>；其他大多数情况下都可以用无序列表。</p>
<h1 id="标记的修改"><a href="#标记的修改" class="headerlink" title="标记的修改"></a>标记的修改</h1><ul>
<li>对于标记的修改，使用 <code>list-style-type:none;</code> 或者 <code>type=&quot;none&quot;;</code></li>
<li><code>background: url( image.ext ) repeat-type horizontal vertical;</code> [ horizontal 、 vertical 是背景图像相对于元素的位置，默认为0]</li>
<li><code>list-style-image</code> 不同浏览器显示效果不一致，更难控制位置(所以很少用)</li>
</ul>
<h1 id="列表的属性-start-、-value"><a href="#列表的属性-start-、-value" class="headerlink" title="列表的属性 start 、 value"></a>列表的属性 start 、 value</h1><p><code>&lt;ol&gt;</code> 中 <code>start=&quot;n&quot;</code> 表示列表初始值， <code>&lt;li&gt;</code> 的 <code>value=&quot;n&quot;</code> 表示该项目的值。 value 属性的值会覆盖 start 的值。</p>
<h1 id="列表标记的位置"><a href="#列表标记的位置" class="headerlink" title="列表标记的位置"></a>列表标记的位置</h1><p><code>list-style-position</code> 默认为 <code>outside</code> ，可以设置为 <code>inside</code> 成为段落的一部分(像首个大写的字母)而不是独立在段落外。</p>
<a id="more"></a>
<h1 id="列表中文本拥挤问题"><a href="#列表中文本拥挤问题" class="headerlink" title="列表中文本拥挤问题"></a>列表中文本拥挤问题</h1><p>利用好 <code>line-height</code> 增大文本行间距。</p>
<h1 id="list-style-的继承"><a href="#list-style-的继承" class="headerlink" title="list-style-* 的继承"></a>list-style-* 的继承</h1><p>list-style-type 、 list-style-position 和 list-style-image ， list-style 属性都是继承的。这也是我们可以应用到父元素 ol 或 ul 上的原因。</p>
<h1 id="元素的隐藏"><a href="#元素的隐藏" class="headerlink" title="元素的隐藏"></a>元素的隐藏</h1><p>使用 <code>left:</code><br>    <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.nav</span> <span class="selector-class">.subnav</span> &#123;</div><div class="line">    <span class="attribute">left</span>: -<span class="number">999em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.nav</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.subnav</span> &#123;</div><div class="line"><span class="attribute">left</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题:除了 left 能否用其他方法？<br>(关键是要避免误交互，所以我想元素本身还在那里的 opacity 和 visibility 应该不行)<br>能否用 display:none 、 position:absolute 、 Clip-path ？</p>
<h1 id="dt-元素、-dd-元素"><a href="#dt-元素、-dd-元素" class="headerlink" title="dt 元素、 dd 元素"></a>dt 元素、 dd 元素</h1><p><code>&lt;dt&gt;</code>: Definition Term.<br><code>&lt;dd&gt;</code>: Description.<br>dd 元素必定是接在 dt 元素之后。<br>dd 元素不必用 p 元素来标记文本(除非里面有多个段落)</p>
<h1 id="HTML5-form-表单的旧浏览器兼容"><a href="#HTML5-form-表单的旧浏览器兼容" class="headerlink" title="HTML5 form 表单的旧浏览器兼容"></a>HTML5 form 表单的旧浏览器兼容</h1><p><a href="https://github.com/ryanseddon/H5F/" target="_blank" rel="external">https://github.com/ryanseddon/H5F/</a></p>
<h1 id="input-type-选择的兼容性"><a href="#input-type-选择的兼容性" class="headerlink" title="input type 选择的兼容性"></a>input type 选择的兼容性</h1><p><a href="https://www.wufoo.com/html5/" target="_blank" rel="external">https://www.wufoo.com/html5/</a></p>
<h1 id="method-”get”-与-“post”-的区别"><a href="#method-”get”-与-“post”-的区别" class="headerlink" title="method=”get” 与 “post” 的区别"></a>method=”get” 与 “post” 的区别</h1><ol>
<li>如果希望表单提交后从服务器得到信息使用 method=”get”。表单提交后，表单中的数据会显示在浏览器的地址栏里。 get 一般用于<strong>数据查询</strong>。<br> 例子：各大搜索引擎。</li>
<li>使用 method=”post” 提交表单后，表单中的数据不会显示在浏览器的地址栏里，这样更为安全。同时，比起 get ，使用 post 可以向服务器发送更多的数据。通常， post 用于向服务器存入数据，而非获取数据。如果需要在数据库中<strong>保存、添加和删除数据</strong>，就应选择 post 。</li>
<li>通常，如果不确定使用哪一种，就使用 post ，这样数据不会暴露在 URL 中。</li>
<li>GET 相对 POST 的优点：<ol>
<li>GET 请求是可被缓存的，可被收藏为书签，不应在处理敏感数据时使用，只应当用于取回数据。但是 POST 不可以。</li>
<li>GET 速度一般比 POST 快。</li>
</ol>
</li>
</ol>
<h1 id="表单安全性"><a href="#表单安全性" class="headerlink" title="表单安全性"></a>表单安全性</h1><p><a href="http://www.htmlcssvqs.com/8ed/form-security/" target="_blank" rel="external">http://www.htmlcssvqs.com/8ed/form-security/</a>(跟 PHP 相关性更高点)</p>
<h1 id="表单标题描述"><a href="#表单标题描述" class="headerlink" title="表单标题描述"></a>表单标题描述</h1><ol>
<li>使用 h1 、 h2 标题</li>
<li>使用 legend 元素(如果使用必须是 fieldset 的第一个元素)</li>
<li>fieldset :用于将一套表单元素组合在一起.</li>
</ol>
<h1 id="legend-元素"><a href="#legend-元素" class="headerlink" title="legend 元素"></a>legend 元素</h1><ol>
<li>虽然 legend 元素可以提高表单的可访问性。</li>
<li>但是，这种行为在不同的屏幕阅读器和浏览器上并不完全一样，不同的模式下也不一样。</li>
<li>所以，考虑到以上这些问题，使用 h1 ～ h6 标题代替 legend 来识别一些(并非所有) fieldset ，就是一个明智的选择。</li>
<li>无论如何，对于单选按钮，最好总是使用 fieldset 和 legend 。</li>
</ol>
<h1 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h1><ul>
<li>必须为每个文本框设置 name 属性，只有在希望为文本框添加默认值的情况下才需要设置 value 属性。</li>
<li>文本框可选属性：<ol>
<li><code>placeholder=&quot;hinttext&quot;</code>，指导用户输入。</li>
<li><code>required=&quot;required&quot;</code>，仅在这个字段有值的情况下才能提交表单</li>
<li><code>autofocus 或者 autofocus=&quot;autofocus&quot;</code>，如果是第一个拥有这个属性的控件， input 会在页面加载时默认获得焦点。</li>
<li><code>size=&quot;n&quot;</code> 定义文本框大小， n 是需要设置的文本框宽度，以字符为单位(也可以用 CSS 单独设置)默认值20。</li>
<li><code>maxlength=&quot;n&quot;</code>， n 是允许输入的最大字符数。</li>
<li><code>autocomplete=&quot;off/on&quot;</code>,保存用户所输入的内容并根据先前的表单输入给出一些包含同样字母的建议文本。可以作用与父元素 form 让所有子元素继承。</li>
</ol>
</li>
</ul>
<h1 id="分隔表单元素"><a href="#分隔表单元素" class="headerlink" title="分隔表单元素"></a>分隔表单元素</h1><p>分隔表单元素的方法在例子中大多数情况下使用 p 元素，嵌套 p 情况下使用 div 。并且都使用了 class=”row” 作为定义样式的钩子。</p>
<h1 id="label-元素"><a href="#label-元素" class="headerlink" title="label 元素"></a>label 元素</h1><p>标签(label)是描述表单字段用途的文本。</p>
<ul>
<li>for 属性：<br>  <code>for=&quot;idlabel&quot;</code>，利用 for 显示关联表单字段 (aka input)。<br>  例子：点击复选框的文本也可以勾选上。实现点击文本标签来修改状态。</li>
</ul>
<p>强烈推荐使用，对提升表单的可访问性和可用性有很重要的作用。</p>
<h1 id="id-、-for-和-name-属性的命名习惯"><a href="#id-、-for-和-name-属性的命名习惯" class="headerlink" title="id 、 for 和 name 属性的命名习惯"></a>id 、 for 和 name 属性的命名习惯</h1><ul>
<li>让 for 、 id 和 name 属性值都一样是一种并非必需但很常见的做法。单选按钮和复选框是例外。</li>
<li>对于包含多个单词的值， for 和 id 中使用连字符(-)分隔各个单词， name 中使用下划线(_)。<br>  例子：<code>for=&quot;first-name&quot;</code> 、 id=”first-name” 和 name=”first_name”</li>
<li>无论使用哪种方法，一定要保证 for 和 id 的值是一样的。</li>
</ul>
<h1 id="pattern-属性"><a href="#pattern-属性" class="headerlink" title="pattern 属性"></a>pattern 属性</h1><p>pattern 属性用于定制的验证规则。它使用正则表达式对用户在框中输入的内容进行限制。<br><a href="http://html5pattern.com/" target="_blank" rel="external">http://html5pattern.com/</a>——<strong>常用正则表达式</strong>。</p>
<h1 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h1><ol>
<li><strong>multiple</strong> 属性：用逗号分开，例如电子邮件框用逗号分开输入多个邮件地址。</li>
<li>WebKit 浏览器支持两个非官方 HTML5 属性： autosave 和 results 。</li>
<li>为 form 添加了 ARIA 地标角色 <strong>role=”search”</strong> 。这会让屏幕阅读器指出网页上有搜索区域，从而提高页面的可访问性。如果表单有多个控件而非只有搜索，就将与搜索相关的控件放在一个 fieldset 或 div 中并为其添加 role=”search” ，而不是将 role=”search” 添加到 form 元素本身。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[target="_blank" 漏洞]]></title>
      <url>http://codingme.xyz/2016/08/30/target-blank-vulnerable/</url>
      <content type="html"><![CDATA[<h1 id="劫持手段"><a href="#劫持手段" class="headerlink" title="劫持手段"></a>劫持手段</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">/* pseudo url */</div><div class="line">window.opener.location = 'https://钓鱼网站.假/</div><div class="line">qq 客服中奖.电脑一台/输入账号密码.领奖';</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>举例说明：</p>
<ol>
<li>如果<strong>页面一</strong>上有<code>target=&quot;_blank&quot;</code>没有 script ，新建窗口跳转到<strong>页面二</strong>，而<strong>页面二</strong>上有这段 script 的话：<ul>
<li>原本在后台作为后台标签页的<strong>页面一</strong>，会被重定向为<code>https://钓鱼网站.假/qq 客服中奖.电脑一台/输入账号密码.领奖&#39;</code>的页面；</li>
</ul>
</li>
<li>如果<strong>页面一</strong>上有<code>target=&quot;_blank&quot;</code>而且有 script ，使用了<code>target=&quot;_blank&quot;</code>新建窗口跳转到其他没有 script 的页面的话：<ul>
<li><strong>页面一</strong>并不会有改变。</li>
</ul>
</li>
</ol>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><code>target=&quot;_blank&quot;</code>打开新页面实际上是要经由<code>window.opener</code>对象。<br>每次打开一个新窗口都要经由<code>window.open();</code></p>
<h1 id="劫持效果"><a href="#劫持效果" class="headerlink" title="劫持效果"></a>劫持效果</h1><p>结果：<br>`target=”_blank”的漏洞会影响新建窗口之前的页面一，使其重定向为 script 设置好的钓鱼网站。</p>
<p>实际例子 demo ：<br><a href="http://tvvocold.coding.me/target_blank_vulnerability/test.html/" target="_blank" rel="external">http://tvvocold.coding.me/target_blank_vulnerability/test.html/</a></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ul>
<li><p>对于使用了<code>target=&quot;_blank&quot;</code>的元素，使用 rel 属性：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*因为 FireFox 不支持 noopener ，所以添加了 noreferrer */</span></div><div class="line">rel=<span class="string">"noopener noreferrer"</span></div></pre></td></tr></table></figure>
</li>
<li><p>解决 opener 属性：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newWnd = <span class="built_in">window</span>.open();</div><div class="line">newWnd.opener = <span class="literal">null</span>;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 HTML5 与 CSS3 基础教程》备忘3]]></title>
      <url>http://codingme.xyz/2016/08/29/html-css-diary-3/</url>
      <content type="html"><![CDATA[<h1 id="边距-简记法"><a href="#边距-简记法" class="headerlink" title="边距 简记法"></a>边距 简记法</h1><p><code>padding: 5px;</code>——使用一个值，这个值就会应用于全部四个边。<br><code>padding: 5px 9px;</code>——使用两个值，则前一个值会应用于上下两边，后一个值会应用于左右两边。<br><code>padding: 5px 9px 11px;</code>——使用三个值，则第一个值会应用于上边，第二个值会应用于左右两边，第三个值会应用于下边<br><code>padding: 5px 9px 11px 0;</code>——使用四个值，它们会按照时钟顺序，依次应用于上、右、下、左四个边.<br>应该也适用与 margin 。</p>
<h1 id="Bootstrap-3的-box-sizing"><a href="#Bootstrap-3的-box-sizing" class="headerlink" title="Bootstrap 3的 box-sizing"></a>Bootstrap 3的 box-sizing</h1><p>学习到 <code>box-sizing:border-box</code> 时候发现原来 <strong>Bootstrap 3</strong> 已经把所有的盒模型都设置成 border-box 了……将 box-sizing 属性设置为 border-box ，就可以很方便地对拥有水平方向内边距(使用 em 或其他的单位)的元素定义宽度，而不必进行复杂的数学计算来找出百分数的值。这对响应式页面来说很方便。所以 Bootstrap 3 才用了 border-box 吧。</p>
<h1 id="em-与-margin-、-padding"><a href="#em-与-margin-、-padding" class="headerlink" title="em 与 margin 、 padding"></a>em 与 margin 、 padding</h1><p>当 em 值用于内边距和外边距时，它的值是<strong>相对于元素的字体大小</strong>的，而不是相对于父元素的字体大小。</p>
<a id="more"></a>
<h1 id="clearfix-解决浮动后遗症"><a href="#clearfix-解决浮动后遗症" class="headerlink" title="clearfix 解决浮动后遗症"></a>clearfix 解决浮动后遗症</h1><ul>
<li>使用 float 浮动后，父元素高度为0，这样一来想给内容加背景色什么的很麻烦。解决方法：<br>  让容器自身具有清除浮动的能力。<br>  用所谓的 <strong>clearfix 方法</strong>(最可靠？)<br>  在 CSS 中引入规则，然后为浮动元素的父元素添加 clearfix 类，从而可以支撑起父元素，并能够添加一些预期样式。<br>  大量网站使用 clearfix 类或类似方法清除浮动。  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.clearfix:before,</div><div class="line">.clearfix:after &#123;</div><div class="line">content: " ";</div><div class="line">display: table;</div><div class="line">&#125;</div><div class="line">.clearfix:after &#123;</div><div class="line">clear: both;</div><div class="line">&#125;</div><div class="line">.clearfix &#123;</div><div class="line">*zoom: 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="另一种方法：-overflow-方法"><a href="#另一种方法：-overflow-方法" class="headerlink" title="另一种方法： overflow 方法"></a>另一种方法： overflow 方法</h1><p>通常，可以对浮动元素的父元素使用 overflow 属性以替代 clearfix 方法。例如，在示例页面中可以使用以下代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line"><span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在某些情况下， overflow: hidden; 会将内容<strong>截断</strong>，对此要多加注意。有时使用 overflow: auto; 也有效，但这样做可能会出现一个<strong>滚动条</strong>，这显然是我们不希望看到的。</li>
<li>可 以 将 clearfix 或 overflow 应用到浮动元素的任何一个非父元素的祖先元素。这样做不会让父元素变高，但祖先元素的高度会包含浮动元素。</li>
</ul>
<h1 id="position-relative"><a href="#position-relative" class="headerlink" title="position: relative"></a>position: relative</h1><ul>
<li><code>position: relative;</code>对元素进行<strong>相对定位</strong>,偏移自然流中元素。</li>
<li>使用相对定位、绝对定位或固定定位时，对于相互重叠的元素，可以用 <strong>z-index</strong> 属性指定它们的叠放次序。</li>
<li>对包含图标列表的父元素设置 <code>position: relative</code> ，从而让这些图标可以相对父元素(而不是 body 元素)进行绝对定位。</li>
</ul>
<h1 id="align-的基准线值"><a href="#align-的基准线值" class="headerlink" title="align 的基准线值"></a>align 的基准线值</h1><p>输入 <code>vertical-align:</code>  输入 <code>baseline</code> ，使元素的基准线对齐父元素的基准线；或者 <code>sub 、 super 、 text-top 、 text-bottom 、 top 、 bottom</code>。</p>
<h1 id="viewport-解决宽度问题"><a href="#viewport-解决宽度问题" class="headerlink" title="viewport 解决宽度问题"></a>viewport 解决宽度问题</h1><ul>
<li>解决浏览器视觉区域宽与屏幕宽度不同的一种快速解决方案：页面的 head 部分添加视觉区域 meta 元素 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</code></li>
<li><code>initial-scale=1</code> 的的意思：将页面的默认缩放级别设成 100%，换成纵向模式也一样。如果不设置 <code>initial-scale=1</code> ，在 iPhone 中，手机从纵向模式改为横向模式时，网页会被放大，从而让布局与纵向模式的一致。</li>
</ul>
<h1 id="font-简记法"><a href="#font-简记法" class="headerlink" title="font 简记法"></a>font 简记法</h1><ul>
<li><code>font:100%/1.2 ...</code> 行高1.2跟在字体大小100%和一个斜杠后面。</li>
<li><code>font: .875em/1.3 &quot;Palatino Linotype&quot;,Palatino, serif;</code></li>
</ul>
<h1 id="media-与响应式页面"><a href="#media-与响应式页面" class="headerlink" title="@media 与响应式页面"></a>@media 与响应式页面</h1><ul>
<li>响应式页面利用媒体查询器和百分比宽度  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*  30em(大于等于480px)</span></div><div class="line">----------------------------------- */</div><div class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">30em</span>) &#123;</div><div class="line">...  报头样式  ...</div><div class="line"><span class="selector-class">.post-photo</span> &#123;</div><div class="line"><span class="attribute">float</span>: left;</div><div class="line"><span class="attribute">margin-bottom</span>: <span class="number">2px</span>;</div><div class="line"><span class="attribute">margin-right</span>: <span class="number">22px</span>;</div><div class="line"><span class="attribute">max-width</span>: <span class="number">61.667%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.post-footer</span> &#123;</div><div class="line"><span class="attribute">clear</span>: left;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="响应式设计的旧版兼容"><a href="#响应式设计的旧版兼容" class="headerlink" title="响应式设计的旧版兼容"></a>响应式设计的旧版兼容</h1><ul>
<li><p>响应式设计要兼容旧版 IE 的话：</p>
<ul>
<li>移动优先方法，因为媒体查询器对 IE8 及以下的版本不支持。所以有3种解决方法：<ul>
<li>什么都不做。让网站显示基本的版本</li>
<li>为它们单独创建一个样式表，让它们显示网站最宽的版本。一种做法是复制一份常规的样式表，将其命名为 old-ie.css 之类的文件名。将媒体查询语句去掉，但保留其中的样式规则。在 HTML 中添加条件注释，从而让不同的浏览器都能找到正确的样式表：<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--</span></div><div class="line">第一个条件注释包含的是为 IE8 及更旧版本以外</div><div class="line">的所有浏览器准备的样式表。</div><div class="line">第二个包含的则是仅为 IE9 以下的 IE 准备的样式表</div><div class="line">--&gt;</div><div class="line"><span class="comment">&lt;!--[if gt IE 8]&gt;&lt;!--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></div><div class="line"><span class="attr">href</span>=<span class="string">"css/styles.css"</span> /&gt;</div><div class="line"><span class="comment">&lt;!--&lt;![endif]--&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></div><div class="line">&lt;script src="js/respond.min.js"&gt;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如果希望页面有响应式的效果，就在页面中引入 respond.min.js 。它让 min-width 和 max-width 媒体查询对旧版 IE 也有效。<a href="https://github.com/scottjehl/Respond/" target="_blank" rel="external">https://github.com/scottjehl/Respond/</a></p>
</li>
<li>第二种方法更可靠，它让 IE8 用户也能看到网站的完整布局。</li>
<li>如果使用 Sass 、 LESS 或 Stylus 这类 CSS 预处理器，就可以自动创建为旧版 IE 准备的样式表。地址：<a href="https://akearchibald.github.io/sass-ie/" target="_blank" rel="external">https://akearchibald.github.io/sass-ie/</a></li>
</ul>
<h1 id="Web-字体"><a href="#Web-字体" class="headerlink" title="Web 字体"></a>Web 字体</h1><ol>
<li>使用 Web 字体可能在它们显示到页面上之前，都需要下载到用户的计算机上。这会减慢网站加载的速度，尤其是对移动用户来说。所以审慎地选择 Web 字体。</li>
<li>每一个样式和粗细版本都会引入一个新的字体文件，从而增加浏览器要下载的文件大小，这会影响性能。出于这个原因，很多设计师仅对标题使用 Web 字体。</li>
<li>字体的常见分类：<ul>
<li>衬线字体(San):衬线体的字体可以有效的转移视线，提高阅读速度，尤其在印刷品中效果非常明显。</li>
<li>无衬线体(Sans-serif):非衬线字体有着简单的风格，在网上或者银幕上表现效果都很好，能让画面感觉变得更清晰。</li>
<li>等宽字体(monospace)</li>
<li>梦幻字体(fantasy)</li>
<li>手写字体(cursive)</li>
</ul>
</li>
</ol>
<h1 id="IE-的-CSS-polyfill"><a href="#IE-的-CSS-polyfill" class="headerlink" title="IE 的 CSS polyfill"></a>IE 的 CSS polyfill</h1><ul>
<li>关于 IE ， Jason Johnston 的 CSS3 PIE(<a href="http://css3pie.com/" target="_blank" rel="external">http://css3pie.com/</a> )是一种最为常见的 <strong>polyfill</strong>。它为  Internet Explorer 6 ～ 9 提供了本章讨论的大部分 CSS 效果的支持。</li>
<li>CSS3 属性前缀可以用 Autoprefixer 。</li>
</ul>
<h1 id="border-radius-的可能-bug"><a href="#border-radius-的可能-bug" class="headerlink" title="border-radius 的可能 bug"></a>border-radius 的可能 bug</h1><p>有时元素的背景(这里讲的不是子元素的背景)会透过其圆角。为了避免这种情况，可以在元素的 border-radius 声明后面增加一条样式规则： <code>background-clip: padding-box;</code>。</p>
<h1 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h1><p>允许使用两个可选的属性—— inset 关键字属性和 spread 属性(前者用于内阴影，后者用于扩张/收缩阴影)。</p>
<p>希望兼容浏览器，需要加 css 前缀(autoprefixer):</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-webkit-box-shadow</span>: <span class="selector-tag">x-offset</span> <span class="selector-tag">y-offset</span> <span class="selector-tag">blur-radius</span></div><div class="line"> <span class="selector-tag">inset</span> <span class="selector-tag">spread</span> <span class="selector-tag">color</span>( <span class="selector-tag">inset</span> 内阴影);</div><div class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">x-offset</span> <span class="selector-tag">y-offset</span> <span class="selector-tag">blur-radius</span></div><div class="line"> <span class="selector-tag">spread</span> <span class="selector-tag">color</span> (<span class="selector-tag">inset</span>);</div><div class="line"><span class="selector-tag">box-shadow</span>:参数组1，参数组2(多重阴影);</div></pre></td></tr></table></figure>
<h1 id="HTML-多重背景"><a href="#HTML-多重背景" class="headerlink" title="HTML 多重背景"></a>HTML 多重背景</h1><p><code>background-image</code>、<code>background-position</code>、<code>background-repeat</code>等，用逗号分隔多个参数组；也可以用<code>background</code>简写。<br>其中<code>background-position:x-offset y-offset;</code><br>(实用性在哪…增加多个图片背景不是会增加 HTTP 请求么..)</p>
<h1 id="渐变背景"><a href="#渐变背景" class="headerlink" title="渐变背景"></a>渐变背景</h1><ul>
<li>先有<code>background</code>颜色(用于防止不支持的浏览器)</li>
<li>用<code>background-image</code>和<code>background</code>效果相同。</li>
<li><p>线性渐变：</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*关键字指定线性渐变的方向*/</span></div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">bottom</span> <span class="selector-tag">right</span>, <span class="selector-tag">aqua</span>, <span class="selector-tag">navy</span>);</div><div class="line"></div><div class="line"><span class="comment">/*指定角度*/</span></div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(290<span class="selector-tag">deg</span>, <span class="selector-tag">aqua</span>, <span class="selector-tag">navy</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>径向渐变:</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">使用渐变尺寸(长/宽)，或者 closest-side 、</div><div class="line">farthest-side 、 closest-corner 或 farthest-corner</div><div class="line">*/</div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(100<span class="selector-tag">px</span> 50<span class="selector-tag">px</span>,<span class="selector-tag">yellow</span>, <span class="selector-tag">red</span>);</div><div class="line"></div><div class="line"><span class="comment">/*at 决定渐变中心(关键字、 x/y)：*/</span></div><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">closest-side</span></div><div class="line"> <span class="selector-tag">at</span> 70<span class="selector-tag">px</span> 60<span class="selector-tag">px</span>, <span class="selector-tag">yellow</span>, <span class="selector-tag">lime</span>, <span class="selector-tag">red</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>考虑浏览器兼容情况加上 CSS 前缀。</p>
</li>
</ul>
<h1 id="opacity-的透明程度"><a href="#opacity-的透明程度" class="headerlink" title="opacity 的透明程度"></a>opacity 的透明程度</h1><ul>
<li>示例：<code>&lt;body&gt;</code>背景褐色;<code>&lt;div&gt;</code>背景黑色，里面有个<code>&lt;img&gt;</code>;对<code>&lt;div&gt;</code>使用 opacity 属性0.5，变半透明，整个<code>&lt;div&gt;</code>包括黑色背景都呈现褐色。如果对<code>&lt;img&gt;</code>使用，应该是图片半透明呈现黑色。</li>
<li>对于旧版 IE :使用滤镜。  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line"><span class="attribute">-ms-filter</span>: progid:DXImageTransform.</div><div class="line"> Microsoft.<span class="built_in">Alpha</span>(opacity=50);</div><div class="line"><span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=50);</div><div class="line"><span class="attribute">opacity</span>: .<span class="number">5</span>;</div><div class="line"><span class="attribute">zoom</span>: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="CSS-生成内容"><a href="#CSS-生成内容" class="headerlink" title="CSS 生成内容"></a>CSS 生成内容</h1><ul>
<li>功能：<br>  使用生成内容可以添加符号、创建用于添加样式的空内容元素等。<br>  生成内容并不是为页面添加段落或标题。这些内容还是应该交给 HTML 。</li>
<li>示例：<br>  CSS 实现三角形:<a href="http://web.jobbole.com/87367/" target="_blank" rel="external">http://web.jobbole.com/87367/</a>。<br>  生成 CSS 三角形：<a href="http://www.cssarrowplease.com/" target="_blank" rel="external">http://www.cssarrowplease.com/</a>。</li>
<li>学习到的：<ol>
<li>伪元素 <code>:before</code> 和 <code>:after</code> ,都拥有 <code>position:absolute</code> 时候，<code>z-index</code> 值后者比前者高，或者说后者会覆盖前者。</li>
<li>伪类 <code>:focus</code> 要实现正常工作，对其元素使用 <code>tabindex=&quot;0&quot;</code> (例子中用的 <code>&lt;img&gt;</code>)<br><code>:focus</code> 伪类默认对链接和表单元素起作用。对于这些元素，不必添加 <code>tabindex=&quot;0&quot;</code> 。</li>
<li>tabindex 属性决定 tab 键在控件中的移动顺序。 tab 移动顺序根据 tabindex 值从大到小。</li>
</ol>
</li>
</ul>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>除了无序列表 ul 、有序列表 ol 外，还有个描述列表 dl 之前被称作定义列表。( dt 、 dd 为 dl 中的术语和描述)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 HTML5 与 CSS3 基础教程》备忘2]]></title>
      <url>http://codingme.xyz/2016/08/29/html-css-diary-2/</url>
      <content type="html"><![CDATA[<h1 id="html-的其他属性"><a href="#html-的其他属性" class="headerlink" title="html 的其他属性"></a>html 的其他属性</h1><p>除非在 html 元素中添加 dir 属性并将属性值设为 rtl ，否则内容的基准方向都默认为从左至右。</p>
<h1 id="span-和-div"><a href="#span-和-div" class="headerlink" title="span 和 div"></a>span 和 div</h1><p>span 只适合<strong>包围字词或短语内容</strong>，而 div 适合<strong>包含块级内容</strong>。由于 span 没有任何语义，因此应将它作为最后的选择，仅在没有其他合适的元素时才使用它。</p>
<h1 id="bdo"><a href="#bdo" class="headerlink" title="bdo"></a>bdo</h1><p>bdo ( bidirectional override ，双向重载):用于显式地格式化其内容的文本方向。<br>要使用 bdo ，必须包含 dir 属性并将属性值设为 ltr (由左至右)或 rtl (由右至左)，指定你希望呈现的方向。(如果你的 HTML 页面中混合了从左至右书写的字符和从右至左书写的字符，就可能要用到 bdi 和 bdo 元素。)例子： <code>&lt;plang=&quot;he&quot;&gt;&lt;bdo dir=&quot;rtl&quot;&gt;...&lt;/bdo&gt;&lt;/p&gt;</code></p>
<h1 id="bdi-元素"><a href="#bdi-元素" class="headerlink" title="bdi 元素"></a>bdi 元素</h1><p>bdi 指的是 bidi 隔离(Bi-directional Isolation)，用于标识独立于周围文本的用做双向文本格式化的一块文本。<br>bdi 元素是 HTML5 中新加的元素，用于内容的方向未知的情况。不必包含 dir 属性，因为默认已设为自动判断。例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>User <span class="tag">&lt;<span class="name">bdi</span>&gt;</span>jcranmer<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span>:</div><div class="line">    12 posts.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>User <span class="tag">&lt;<span class="name">bdi</span>&gt;</span>hober<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span>:</div><div class="line">    5 posts.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>User <span class="tag">&lt;<span class="name">bdi</span>&gt;</span>نا إي<span class="tag">&lt;/<span class="name">bdi</span>&gt;</span>:</div><div class="line">    3 posts.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="meter-元素"><a href="#meter-元素" class="headerlink" title="meter 元素"></a>meter 元素</h1><p>可以用 meter 元素表示<strong>分数的值或已知范围的测量结果</strong>。简单地说，它代表的是<strong>投票结果</strong>。 HTML5 建议(并非强制)浏览器在呈现 meter 时，在旁边显示一个类似温度计的图形——一个表示测量值的横条，测量值的颜色与最大值的颜色有所区别(相等除外)。作为当前少数几个支持 meter 的浏览器， Firefox 正是这样显示的。对于不支持 meter 的浏览器，可以通过 CSS 对 meter 添加一些额外的样式，或用 JavaScript 进行改进。</p>
<ul>
<li><p>meter 元素代码示例：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Project completion status:</div><div class="line">    <span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"0.80"</span>&gt;</span>80% completed<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Car brake pad wear:</div><div class="line">    <span class="tag">&lt;<span class="name">meter</span> <span class="attr">low</span>=<span class="string">"0.25"</span> <span class="attr">high</span>=<span class="string">"0.75"</span> <span class="attr">optimum</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"0.21"</span>&gt;</span>21% worn<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Miles walked during half-marathon:</div><div class="line">    <span class="tag">&lt;<span class="name">meter</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"13.1"</span> <span class="attr">value</span>=<span class="string">"5.5"</span> <span class="attr">title</span>=<span class="string">"Miles"</span>&gt;</span>4.5<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>已经有人试过针对支持 meter 的浏览器和不支持的浏览器统一编写 meter 的 CSS 。在网上搜索“ style HTML5 meter with CSS ”(用 CSS 为 HTML5 的 meter 添加样式)，就可以找到一些解决方案(注意其中的一些用到了 JavaScript )。 meter 并不用于标记没有范围的普通测量值，如高度、宽度、距离、周长等。</p>
</li>
<li>一定不要将 meter 和 progress 元素混在一起使用。</li>
</ul>
<h1 id="progress-元素"><a href="#progress-元素" class="headerlink" title="progress 元素"></a>progress 元素</h1><p>progress 元素也是 HTML5 的新元素。前面说过，它指示<strong>某项任务的完成进度</strong>。它和 meter 元素一样，支持的会显示一个进度条，不支持的会显示文本。</p>
<ul>
<li>progress 代码示例：  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Current progress: </div><div class="line">    <span class="tag">&lt;<span class="name">progress</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span>0% saved<span class="tag">&lt;/<span class="name">progress</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="rel-属性"><a href="#rel-属性" class="headerlink" title="rel 属性"></a>rel 属性</h1><ul>
<li><p>rel 属性是可选的，即便没有它，链接也能照常工作。但对于指向另一网站的链接，推荐包含这个值。它描述包含链接的页面和链接指向的页面之间的关系。它也是另一种提升 HTML 语义化程度的方式。搜索引擎也会利用这些信息。此外，还可以对带有 <code>rel=&quot;external&quot;</code> 的链接添加不同的样式，从而告知访问者这是一个指向外部网站的链接。对任何链接到站外页面的 a 元素(即外部链接)添加 <code>rel=&quot;external&quot;</code> 是非常好的习惯。</p>
</li>
<li><p>不管怎样，应避免使用“点击此处”作为标签。例如，应使用“了解我们的销售情况”，而不是“点击此处了解我们的销售情况”。</p>
</li>
<li><p>维 基 百 科 上 有 一 份 rel 值 的 列 表：<a href="http://microformats.org/wiki/existing-rel-values/" target="_blank" rel="external">http://microformats.org/wiki/existing-rel-values/</a>，该列表还在持续更新中。</p>
</li>
</ul>
<h1 id="target-属性"><a href="#target-属性" class="headerlink" title="target 属性"></a>target 属性</h1><p>target 属性不要在大多数情况下使用。首先，应该让用户决定是否在不同的窗口或标签页打开链接，而不是让 HTML 开发人员决定。</p>
<h1 id="CSS-层叠规则"><a href="#CSS-层叠规则" class="headerlink" title="CSS 层叠规则"></a>CSS 层叠规则</h1><p>CSS 用层叠的原则来考虑<strong>特殊性</strong>(specificity)、<strong>顺序</strong>(order)和<strong>重要性</strong>(importance)，从而判断相互冲突的规则中哪个规则应该起作用。</p>
<h1 id="CSS3-新增颜色属性"><a href="#CSS3-新增颜色属性" class="headerlink" title="CSS3 新增颜色属性"></a>CSS3 新增颜色属性</h1><p>CSS3 中新增的颜色属性 HSL 相比 RGB 的优点是：<br>举例，从红变绿的话， HSL 更加的可预计，而且不需要更改原本的亮度。<br>HSL:<strong>色相</strong>(hue)/<strong>饱和度</strong>(saturation)/<strong>亮度</strong>(lightness)<br>例子:<br>红色为 hsl(0,100%,50%);<br>黄色为 hsl(60,100%,50%);<br>绿色为 hsl(120,100%,50%);<br>青色为 hsl(180,100%,50%);</p>
<h1 id="外部样式表与-import"><a href="#外部样式表与-import" class="headerlink" title="外部样式表与 @import"></a>外部样式表与 @import</h1><p>外部样式表要么是通过链接引用的，要么是导入的(通过 <code>@import</code> )，不过不推荐导入。 @import 指令会影响页面的下载速度和呈现速度，在 Internet Explorer 中影响更为明显。 Web 性能专家 Steve Souders 对此问题进行了讨论，参见<a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/" target="_blank" rel="external">http://www.stevesouders.com/blog/2009/04/09/dont-use-import/</a> 。建议不要使用 <code>@import</code> ，这主要是出于性能上的考虑。如果用了 <code>@import</code> ，当引入的样式后面有与之冲突的样式，则后出现的样式会覆盖这些引入的样式，与预期一致。</p>
<ul>
<li>外部样式表的另一个好处是，一旦浏览器在某个页面加载了它，在随后浏览引用它的页面时，通常无需再向 Web 服务器请求该文件。浏览器会将它保存到缓存里，也就是保存到用户的计算机里，并使用这个版本的文件。这样做可以加快对页面的加载。不过，不必担心。如果随后对样式表作了修改，再将它传到 Web 服务器，浏览器就会下载更新后的文件，而不是使用缓存的文件。</li>
</ul>
<h1 id="link-、-style-元素的开始标签"><a href="#link-、-style-元素的开始标签" class="headerlink" title="link 、 style 元素的开始标签"></a>link 、 style 元素的开始标签</h1><ul>
<li>HTML 早期版本要求在 link 元素定义中包含 <code>type=&quot;text/css&quot;</code> ，但 HTML5 不要求这样做。</li>
<li>HTML5 之前的版本要求在 style 开始标签中包含属性 <code>type=&quot;text/css&quot;</code> ，不过 HTML5 没有要求。</li>
<li>在 link 或 style 元素的开始标签中添加 <code>media=&quot;output&quot;</code>，其中 output 可以是 print 、 screen 或 all (尽管还有其他一些选项，但这些是最常见的) 也可以在样式表中使用<code>@media</code>规则。这种方法不需要在 link 元素中指定媒体类型。</li>
<li>通过对 link 元素添加 media 属性，可以将样式表限于特定输出。使用浏览器查看页面时， style.css 会起作用(由于使用了 <code>media=&quot;screen&quot;</code>)；打印页面时， print.css 会起作用(由于使用了 <code>media=&quot;print&quot;</code> )。</li>
</ul>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>可以在选择器中使用<strong>方括号</strong>添加关于目标元素的属性或值的信息：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://www.wikipedia.org"]</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>尽量不要使用<strong> ID 选择器</strong>。</li>
<li>除非必须特别针对目标元素，最好不要在 id 或 class 选择器中添加元素名称。(像是<code>h1.news { color: red; }</code> )</li>
<li>如果有样式冲突， .architect.bio 的规则的优先级比.architect 或.bio 的更高。</li>
<li>id 选择器会引入下面两个问题:<ul>
<li>与它们关联的样式不能在其他元素上复用</li>
<li>它们的特殊性比 class 选择器要强得多。这意味着如果要覆盖使用 id 选择器定义的样式，就要编写特殊性更强的 CSS 规则。</li>
</ul>
</li>
<li><p>.architect 和 p 之间的空格表示这个选择器会寻找任何作为 architect 类元素后代(无论是第几代)的 p 元素。</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.architect</span> <span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*得到相同效果的其他方式</span></div><div class="line">-------------------------------------- */</div><div class="line"><span class="comment">/* 是任意 article 祖先的所有 p 元素，</span></div><div class="line">这是三个中特殊性最低的一个 */</div><div class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 属于 architect 类 article 元素的祖先的任意 p 元</span></div><div class="line">素，是三个中特殊性最高的一个 */</div><div class="line"><span class="selector-tag">article</span><span class="selector-class">.architect</span> <span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这个选择器仅选择 architect 类元素的子元素(而非子子元素、子子子元素等)的 p 元素。包含于任何其他元素的 p 元素均不会被选中</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.architect</span> &gt; <span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通常最好保持较低的特殊性，让样式更易于复用。</p>
</li>
</ul>
<h1 id="，-CSS-相邻同胞结合符"><a href="#，-CSS-相邻同胞结合符" class="headerlink" title="+， CSS 相邻同胞结合符"></a>+， CSS 相邻同胞结合符</h1><p>CSS 相邻同胞结合符(adjacent sibling combinator):只有直接跟在同胞 p 元素后面的 p 元素显示为红色。如果后面还有第三个、第四个以及更多的段落，它们也将显示为红色。例如，如果要对<strong>除第一个段落以外的所有段落进行缩进</strong>，相邻同胞结合符就很有用。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">architect</span> <span class="selector-tag">p</span>+<span class="selector-tag">p</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="，普通同胞结合符"><a href="#，普通同胞结合符" class="headerlink" title="~，普通同胞结合符"></a>~，普通同胞结合符</h1><p>我们也可能会用到普通同胞结合符，通过它可以选择那些并非直接出现在另一同胞元素后面的同胞元素。它与相邻同胞结合符的唯一区别是使用～(波浪号)代替 + 分隔同胞元素。例如， <code>h1 ～ h2 { color: red; }</code>会让<strong>任何属于同一父元素的同胞 h1 后面的 h2元素显示为红色(它们可以直接相邻，也可以不直接相邻)</strong>。</p>
<h1 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h1><p>选择第一个或最后一个子元素用 <code>:first-child</code> 和 <code>:last-child</code> 伪类。这些伪类选择的是作为第一个子元素或最后一个子元素的元素(在这个例子中就是 li )。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>仅仅使用 <code>:first-child { color: red; }</code> ，可以为任何作为另一个元素的第一个子元素的元素应用样式。</li>
<li>我们可以分别使用 <code>:first-letter</code> 和 <code>:first-line</code> 伪元素只选择元素的第一个字母或第一行。</li>
<li>第一个字母前面的标点符号(如引号)会被当做第一个字母的一部分，一同被格式化。现代浏览器都支持这一特性，但 IE8 之前的版本并不是这样做的，它将标点符号本身当做第一个字母。</li>
<li>在 CSS3 中， <code>:first-line</code> 的语法为 <code>::first-line</code> ， <code>:first-letter</code> 的语法为 <code>::first-letter</code> 。注意，它们用两个冒号代替了单个冒号。这样修改的目的是将<strong>伪元素</strong>(有四个，包 括 <code>::first-line</code> 、 <code>::first-letter</code> 、 <code>::before</code> 和 <code>::after</code> ) 与 <strong>伪类</strong>( 如 <code>:first-child</code> 、<code>:link</code> 、 <code>:hover</code> 等)区分开。</li>
<li><strong>伪元素</strong>(pseudo-element)是 HTML 中并不存在的元素。例如，定义第一个字母或第一行文字时，并未在 HTML 中作相应的标记。它们是另一个元素(在本例中为 p 元素)的部分内容。</li>
<li><strong>伪类</strong>(pseudo-class)应用于一组 HTML 元素，而你无需在 HTML 代码中用类标记它们。例如，使用 <code>:first-child</code> 可以选择某元素的第一个子元素，你就不用写成<code>class=&quot;first-child&quot;</code></li>
<li>未来， <code>::first-line</code> 和 <code>::first-letter</code> 这样的双冒号语法是推荐的方式，现代浏览器也支持它们。原始的单冒号语法则被废弃了，但浏览器出于向后兼容的目的，仍然支持它们。不过， IE9 之前的 Internet Explorer 版本均不支持双冒号。因此，你可以选择继续使用单冒号语法，除非你为 IE8 及以下版本设置了单独的 CSS 。</li>
<li>按状态选择链接元素<ul>
<li>输入 link 以设置从未被激活或指向，当前也没有被激活或指向的链接的外观</li>
<li>输入 visited 以设置访问者已激活过的链接的外观</li>
<li>输入 focus ，前提是链接是通过键盘选择并已准备好激活的(例如通过 Tab 键)</li>
<li>输入 hover 以设置光标指向链接时链接的外观</li>
<li>输入 active 以设置激活过的链接的外观(更准确应该是激活时，点击是 active ,松开后是 visited )</li>
<li>要对链接指定样式，不一定要指定伪类，例如，使用 <code>a{color: red;}</code>会让链接的所有状态显示为同一种样式。不过，最好使用伪类区分不同状态的样式，这样做可以方便访问者。<ul>
<li>由于链接可能同时处于多种状态，且晚出现的规则会覆盖前面出现的规则，所以，一定要按照下面的顺序定义规则： <strong>link</strong> 、 <strong>visited</strong> 、<strong>focus</strong> 、 <strong>hover</strong> 、 <strong>active</strong> ( 缩 写 为 LVFHA)。一种助记口诀为“ Lord Vader’s Former Handle Anakin ”(达斯·维达的原名叫安纳金)</li>
<li>触屏设备(如智能手机和平板电脑)的浏览器没有桌面浏览器所具有的“鼠标悬停”(即 hover)状态。不过，在 iPhone 和 iPad 上，访问者激活链接时，确实会显示通过 :hover 指定的样式。其他设备的行为则不一而定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h1><ul>
<li><p>按属性选择元素</p>
<ul>
<li>方括号包围目标属性和目标属性值。这个例子中没有属性值，它选择的是所有具有 class 属性的段落<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-attr">[class]</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>属性选择器</strong>参考表</p>
<ul>
<li>[attribute] 匹配指定属性，不论具体值是什么</li>
<li>[attribute=”value”] 完全匹配指定属性值</li>
<li>[attribute~=”value”] 属性值是以空格分隔的多个单词，其中有一个完全匹配指定值</li>
<li>[attribute|=”value”] 属性值以 value- 打头或匹配 value</li>
<li>[attribute^=”value”] 属性值以 value 开头， value 为完整的单词或单词的一部分</li>
<li>[attribute$=”value”] 属性值以 value 结尾， value 为完整的单词或单词的一部分</li>
<li>[attribute*=”value”] 属性值为指定值的子字符串,属性值至少包含这里的 value 一次的元素将被选中。<ul>
<li>当前所有主流浏览器均支持按元素包含的属性(和属性值)选择元素。对于 CSS3 中新增的属性选择器， IE7 和 IE8 有一些异常。</li>
</ul>
</li>
</ul>
</li>
<li><p>指定元素组</p>
<ul>
<li>不同的选择器不一定非得单独成行，但很多编码人员都遵循这种惯例，易于阅读！<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span>,</div><div class="line"><span class="selector-tag">h2</span> &#123;</div><div class="line"><span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在这里有个疑问，尝试自问自答。<br>  问：用元素组选择器跟用同个 class 效果是差不多的，比如上面的 h1 , h2 ,可以都拥有相同 class 属性。那么怎么判断该用哪个呢？<br>  一句话总结：<strong>爱用哪个用哪个</strong>。<br>  与其考虑用哪个选择器的话，不如想想维护性，这点更重要。<br>  (选择器影响效率也是微乎其微..在选择器上优化得到的性能提升还没有合并一个 http 请求来得实在。)<br>  关于选择器效率有一点：选择器的匹配机制是从选择器的右边到左边进行读取的。<br>  选择器效率从高到低的排序列表:<br>  id 选择器(#id)<br>  类选择器(.className)<br>  标签选择器(div,h1,p)<br>  相邻选择器(h1+p)<br>  子选择器(ul &gt; li)<br>  后代选择器(li a)<br>  通配符选择器(*)<br>  属性选择器(a[rel=”external”])<br>  伪类选择器(a:hover,li:nth-child)</p>
</li>
</ul>
<h1 id="IE6-伪类和选择器兼容"><a href="#IE6-伪类和选择器兼容" class="headerlink" title="IE6 伪类和选择器兼容"></a>IE6 伪类和选择器兼容</h1><p>Selectivizr(<a href="http://selectivizr.com/" target="_blank" rel="external">http://selectivizr.com/</a> )：这是“一个在 Internet Explorer 6 ～ 8 中模拟 CSS3 伪类和属性选择器的 JavaScript 工具”</p>
<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><ul>
<li>sans-serif 、 cursive 、 fantasy 、 monospace 分别表示无衬线字体、手写字体、装饰字体和等宽字体。</li>
<li><a href="https://css-tricks.com/why-ems/" target="_blank" rel="external">https://css-tricks.com/why-ems/</a></li>
</ul>
<h1 id="文本大小写"><a href="#文本大小写" class="headerlink" title="文本大小写"></a>文本大小写</h1><ul>
<li>既然可以改变 HTML 里的文本，为什么还要用 text-transform 这类的 CSS 属性来修改文本显示呢？这是因为，有时，内容是你无法控制的。例如，内容可能存储在数据库里，或者来自另一个网站的新闻源。在这些情况下，只能通过 CSS 控制文本的大小写。搜索引擎通常是按它在 HTML 里输入的样子索引文本的，在搜索结果里显示标准的大小写会更容易阅读。</li>
<li>使用小型大写字母的方法:输入 <code>font-variant: small-caps</code>。与简单地缩小字号的大写字母相比，小型大写字母显得更为轻巧。</li>
<li><code>white-space: pre;</code> 输入 pre ，以让浏览器显示原文本中所有的空格和回车。或者输入 owrap ，确保所有空格不断行，也就是文本全部显示在一行；或者输入 normal ，按正常方式处理空格。</li>
</ul>
<h1 id="CSS-重置"><a href="#CSS-重置" class="headerlink" title="CSS 重置"></a>CSS 重置</h1><p>使用 CSS Reset 和 normalize.css 的原因：每个浏览器都有内置的默认样式表。 HTML 会遵照该样式表显示，除非你自己编写的 CSS 覆盖了它们。整体上，不同浏览器提供的默认样式表是相似的，但也存在一定的差异。为此，开发人员在应用他们自己的 CSS 之前，常常需要抹平这些差异。</p>
<h1 id="ul-与-inline-block"><a href="#ul-与-inline-block" class="headerlink" title="ul 与 inline-block"></a>ul 与 inline-block</h1><p>关于 inline-block 和 ul ：让 ul 水平排列，如果对 li 用 inline-block 的话貌似会让 list-style-* 出现问题。</p>
<h1 id="兼容性-CSS-前缀"><a href="#兼容性-CSS-前缀" class="headerlink" title="兼容性 CSS 前缀"></a>兼容性 CSS 前缀</h1><p>带有-webkit- 和 -moz- 这些奇怪前缀的属性可以让这些规则在旧的 Android 和 iOS 设备上起作用，同时在 Firefox 上也能正常工作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《 HTML5与 CSS3 基础教程》备忘]]></title>
      <url>http://codingme.xyz/2016/08/07/html-css-diary/</url>
      <content type="html"><![CDATA[<h1 id="Web-设计-在线网址"><a href="#Web-设计-在线网址" class="headerlink" title="Web 设计 在线网址"></a>Web 设计 在线网址</h1><p><a href="http://designingfortheweb.co.uk/" target="_blank" rel="external">http://designingfortheweb.co.uk/</a><br>—— Mark Boulton</p>
<h1 id="article-元素"><a href="#article-元素" class="headerlink" title="article 元素"></a>article 元素</h1><p>article 元素表示文档、页面、应用或网站中<em>一个独立的容器</em>，原则上是可独立分配或可再用的，就像聚合内容中的各部分。它可以是一篇论坛帖子、一篇杂志或报纸文章、一篇博客条目、一则用户提交的评论、一个交互式的小部件或小工具，或者任何其他<strong>独立的内容项</strong>。</p>
<h1 id="section-元素"><a href="#section-元素" class="headerlink" title="section 元素"></a>section 元素</h1><p>section 元素代表文档或应用的<em>一个一般的区块</em>。如果只是出于添加样式的原因要对内容添加一个容器，应使用 div 而不是 section 。在考虑何时使用 section 的时候，记住定义中“<strong>具有相似主题的一组内容</strong>”这一条是很有帮助的。这也是 section 区别于 div 的另一个原因。</p>
<h1 id="div-元素"><a href="#div-元素" class="headerlink" title="div 元素"></a>div 元素</h1><p>有关 div 的一些历史以及何时在 HTML5 中使用它:<br>在 HTML5 之前， div 是包围大块内容(如页眉、页脚、主要内容、插图、附注栏等)从而可用 CSS 为之添加样式的不二选择。之前 div 没有任何语义含义，现在也一样。 这就是 HTML5 引入 header 、 footer 、 main 、 article 、 section 、 aside 和 nav 的原因。这些类型的构造块在网页中普遍存在，因此它们可以成为具有独立含义的元素。在 HTML5 中， div 并没有消失，只是使用它的场合变少了。不过，可以肯定的是， div 应该作为最后一个备用容器，因为它没有任何语义价值。大多数时候，使用 header 、 footer 、 main (仅使用一次)、 article 、 section 、 aside 甚至 nav 代替 div 会更合适。但是，如果语义上不合适，也不必为了刻意避免使用 div 而使用上述元素。有用得上 div 的地方，只是需要限制其使用。</p>
<a id="more"></a>
<h1 id="role-属性和-ARIA-地标角色"><a href="#role-属性和-ARIA-地标角色" class="headerlink" title="role 属性和 ARIA 地标角色"></a>role 属性和 ARIA 地标角色</h1><p>关于 role 属性和 ARIA 地标角色：<br>可用性专家 Steve Faulkner 对地标角色有详细的讲解，见 <a href="http://blog.paciellogroup.com/2013/02/using-wai-aria-landmarks-2013/" target="_blank" rel="external">http://blog.paciellogroup.com/2013/02/using-wai-aria-landmarks-2013/</a> 。他还引用了另一位专家 Léonie Watson 录制的演示屏幕阅读器用户访问页面行为的视频，推荐观看！<br>地标角色只是 ARIA 规范 <a href="http://www.w3.org/TR/wai-aria/" target="_blank" rel="external">http://www.w3.org/TR/wai-aria/</a> 众多特性中的一个。如果对相关的实施指南感兴趣，可以访问 <a href="http://www.w3.org/WAI/PF/aria-practices/" target="_blank" rel="external">http://www.w3.org/WAI/PF/aria-practices/</a>。<br>可以在 CSS 选择器中使用 ARIA 角色属性，从而对使用它们的元素添加样式。</p>
<h1 id="CSS-方面目的不推荐使用-id"><a href="#CSS-方面目的不推荐使用-id" class="headerlink" title="CSS 方面目的不推荐使用 id"></a>CSS 方面目的不推荐使用 id</h1><p>但一般不推荐出于添加样式的目的使用 id 。推荐使用类为元素添加样式。在 class 和 id 名称中，通常使用短横线分隔多个单词，例如 <code>class=&quot;footer-page&quot;</code> 。</p>
<h1 id="em-元素、-cite-元素"><a href="#em-元素、-cite-元素" class="headerlink" title="em 元素、 cite 元素"></a>em 元素、 cite 元素</h1><p>em 元素用于<strong>标识强调的文本</strong>， cite 元素用于<strong>标识对艺术作品、电影、图书等内容的引用</strong>。</p>
<h1 id="b-、-i-、-em-、-strong"><a href="#b-、-i-、-em-、-strong" class="headerlink" title="b 、 i 、 em 、 strong"></a>b 、 i 、 em 、 strong</h1><ul>
<li>strong 元素表示<strong>内容的重要性</strong>，而 em 则表示<strong>内容的着重点</strong>。</li>
<li>不要使用 b 元素代替 strong ，也不要使用 i 元素代替 em 。尽管它们在浏览器中显示的样式是一样的，但它们的含义却很不一样。</li>
<li>旧版本 HTML 那时 strong 所表示文本的强调程度比 em 表示的文本要高。不过，在 HTML5 中， em 是<strong>表示强调的唯一元素</strong>，而 strong 表示的则是<strong>重要程度</strong>。</li>
<li>先一句话总结： HTML5 强调， <strong>b 和 i 应该是其他元素(如 strong 、 em 、 cite 等)都不适用时的最后选择</strong>。</li>
</ul>
<p>HTML5 将 b 重新定义为：<br>b 元素表示出于实用目的提醒读者注意的一块文字，不传达任何额外的重要性，也不表示其他的语态和语气，用于如<strong>文档摘要里的关键词</strong>、<strong>评论中的产品名</strong>、<strong>基于文本的交互式软件中指示操作的文字</strong>、<strong>文章导语</strong>等。<br>HTML5 将 i 重新定义为：<br>i 元素表示一块不同于其他文字的文字，具有不同的语态或语气，或其他不同于常规之处，用于如<strong>分类名称</strong>、<strong>技术术语</strong>、<strong>外语里的惯用语</strong>、<strong>翻译的散文</strong>、<strong>西方文字中的船舶名称</strong>等。</p>
<h1 id="small-元素"><a href="#small-元素" class="headerlink" title="small 元素"></a>small 元素</h1><p>small 表示细则一类的旁注(side comment)，通常包括<strong>免责声明</strong>、<strong>注意事项</strong>、<strong>法律限制</strong>、<strong>版权信息</strong>等。有时我们还可以用它来<strong>表示署名</strong>，或者<strong>满足许可要求</strong>。用 small 标记页面的版权信息是一种常见的做法。不过， small <strong>只适用于短语</strong>，因此不要用它标记长的法律声明，如“使用条款”和“隐私政策”页面。</p>
<h1 id="em-和-cite-不能滥用"><a href="#em-和-cite-不能滥用" class="headerlink" title="em 和 cite 不能滥用"></a>em 和 cite 不能滥用</h1><p>内容显示的样子与为其使用的标记没有关系。因此，不应该为了让文字变为斜体就使用 em 或 cite ，添加样式是 CSS 的事情。</p>
<h1 id="del-、-ins-和-s"><a href="#del-、-ins-和-s" class="headerlink" title="del 、 ins 和 s"></a>del 、 ins 和 s</h1><p>标记不再准确或不再相关的文本用 &lt;s&gt; 。仅在有语义价值的时候使用 del 、 ins 和 s 。如果只是出于装饰的原因要给文字添加下划线或删除线，可以用 CSS 实现这些效果。 HTML5 指出：“ s 元素不适用于指示文档的编辑，要标记文档中一块已移除的文本，应使用 del 元素。”有时，这之间的差异是很微妙的，只能由你决定哪种选择更符合内容的语义。</p>
<h1 id="u-元素"><a href="#u-元素" class="headerlink" title="u 元素"></a>u 元素</h1><p>同 b 、 i 、 s 和 small 一样， HTML5 重新定义了 u 元素，使之不再是无语义的、用于表现的元素。以前， u 元素用来为文本添加下划线。现在， u 元素用于<strong>非文本注解</strong>。 HTML5 对它的定义为： u 元素为一块文字添加明显的非文本注解，比如<strong>在中文中将文本标为专有名词(即中文的专名号,专名号用于表示人名、地名、朝代名等专名。)</strong>，或者<strong>标明文本拼写有误</strong>。</p>
<h1 id="figure-元素、-aside-元素"><a href="#figure-元素、-aside-元素" class="headerlink" title="figure 元素、 aside 元素"></a>figure 元素、 aside 元素</h1><p>figure ：用于识别在主文档流内被引用，但在不影响文档流的情况下可以移至他处的内容。<br>对于与内容有关的<strong>图像</strong>(如图表、图形或带有说明文字的插图)，使用 figure 。<br>不要简单地将 figure 作为在文本中嵌入独立内容实例的方法。这种情况下，通常更适合用 aside 元素。<br>aside 元素：用于标识页面中的一个区域，其内容与周围的内容无关。</p>
<h1 id="time-元素、-datetime-属性"><a href="#time-元素、-datetime-属性" class="headerlink" title="time 元素、 datetime 属性"></a>time 元素、 datetime 属性</h1><p>time 元素<strong>标记时间、日期或时间段</strong>。 datetime 属性不会单独产生任何效果，但它可以用于在 Web 应用(如日历应用)之间同步日期和时间。这就是必须使用标准的机器可读格式的原因，这样，程序之间就可以使用相同的“语言”来共享信息。<br>示例代码:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">"1952-06-12T 11:05:00"</span>&gt;</span></div><div class="line">June 12, 1952 at 11:05 a.m.</div><div class="line"> <span class="tag">&lt;/<span class="name">time</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="abbr-元素"><a href="#abbr-元素" class="headerlink" title="abbr 元素"></a>abbr 元素</h1><p><code>&lt;abbr title=&quot;National Football League&quot;&gt;NFL&lt;/abbr&gt;</code><br>不必对每个<strong>缩写词</strong>都使用 abbr ，只在需要帮助访问者了解该词含义的时候使用。<br>作为对用户的视觉提示， Firefox 和 Opera 等浏览器会对带 title 的 abbr 文字使用虚线下划线。<br>想在其他浏览器中对带 title 的 abbr 文字使用虚线下划线，可以在样式表中加上这条语句：<br><code>abbr[title] { border-bottom: 1px dotted#000; }</code><br>无论 abbr 是否添加了下划线样式，浏览器都会将 title 属性内容以提示框的形式显示出来。如果看不到 abbr 有虚线下划线，试着为其父元素的 CSS 添加 line-height 属性。</p>
<h1 id="dfn-元素"><a href="#dfn-元素" class="headerlink" title="dfn 元素"></a>dfn 元素</h1><p>dfn:Definition<br>在 HTML 中<strong>定义术语</strong>时，可以使用 dfn 元素对其作语义上的区分。 dfn 元素及其定义必须挨在一起，否则便是错误的用法。还可以在描述列表( dl 元素)中使用 dfn 。例子： <code>&lt;dfn&gt;pleonasm&lt;/dfn&gt;means &quot;a redundant word or expression&quot;</code></p>
<h1 id="kbd-、-samp-和-var"><a href="#kbd-、-samp-和-var" class="headerlink" title="kbd 、 samp 和 var"></a>kbd 、 samp 和 var</h1><ol>
<li>kbd :标记用户输入指示。 <code>&lt;li&gt;Hit &lt;kbd&gt;RETURN&lt;/kbd&gt; or &lt;kbd&gt;ENTER&lt;/kbd&gt;&lt;/li&gt;</code></li>
<li>samp ：指示程序或系统的示例输出。 <code>&lt;samp&gt;Thanks for your order!&lt;/samp&gt;</code></li>
<li>var :表示变量或占位符的值。 <code>&lt;var&gt;E&lt;/var&gt; =&lt;var&gt;m&lt;/var&gt;&lt;var&gt;c&lt;/var&gt; &lt;sup&gt;2&lt;/sup&gt;</code></li>
</ol>
<h1 id="pre-元素"><a href="#pre-元素" class="headerlink" title="pre 元素"></a>pre 元素</h1><p>不要将 pre 作为逃避以合适的语义标记内容和用 CSS 控制样式的快捷方式。例如，如果你想发布一篇在字处理软件中写好的文章，不要为了保留原来的格式，简单地将它复制、粘贴到 pre 里。相反，应该使用 p(以及其他相关的文本元素)标记内容，编写 CSS 控制页面的布局。</p>
<h1 id="创建换行"><a href="#创建换行" class="headerlink" title="创建换行"></a>创建换行</h1><ul>
<li>要确保使用 br 是最后的选择，因为该元素将表现样式带入了 HTML ，而不是让所有的呈现样式都交由 CSS 控制。例如，不要使用 br 模拟段落之间的距离。相反，应该用 p 标记两个段落并通过 CSS 的 margin 属性规定两段之间的距离。实际上，对于诗歌、街道地址等应该紧挨着出现的短行，都适合用 br 元素。</li>
<li>要尽量避免使用 br ，除非没有更好的选择，因为这样做会在 HTML 中混合表现，而不是让 CSS 控制它。(让 HTML 负责内容， CSS 负责样式/显示)</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SQL 的小注意事项]]></title>
      <url>http://codingme.xyz/2015/12/22/sql-tips/</url>
      <content type="html"><![CDATA[<h1 id="DISTINCT-和-GROUP-BY"><a href="#DISTINCT-和-GROUP-BY" class="headerlink" title="DISTINCT 和 GROUP BY"></a>DISTINCT 和 GROUP BY</h1><ul>
<li>使用 GROUP BY 子句时， SELECT 子句中不能出现聚合键之外的列名；</li>
<li>GROUP BY 子句结果的显示是无序的；</li>
<li>DISTINCT 和 GROUP BY 子句都能删除后续列中的重复数据，除此之外，它们还都会把 NULL 作为一个独立的结果返回，对多列使用时也会得到完全相同的结果。其实不仅处理结果相同，执行速度也基本上差不多，到底该用哪一个呢？</li>
</ul>
<p>但其实这个问题本身就是本末倒置的，我们应该考虑的是该 SELECT 语句是否满足需求。选择的标准其实很简单：<br><strong>在“想要删除选择结果中的重复记录”时使用 DISTINCT ；在“想要计算聚合结果”时使用 GROUP BY 。</strong><br>不使用 COUNT 等聚合函数，而只使用 GROUP BY 子句的 SELECT 语句，会让人觉得非常奇怪。难免让人产生“到底为什么要对表进行分组呢？这样做有必要吗？”等疑问。</p>
<h1 id="HAVING-和-WHERE"><a href="#HAVING-和-WHERE" class="headerlink" title="HAVING 和 WHERE"></a>HAVING 和 WHERE</h1><ul>
<li>WHERE 用例：“商品种类为衣服”、“销售单价在1000元以上”；<br>HAVING 用例：“数据行数为2行”、“平均值为500”；【 count 、 avg 】</li>
<li>WHERE 子句不能使用聚合函数。(只有 SELECT 子句和 HAVING 子句(以及 ORDER BY 子句)中能够使用聚合函数)。</li>
<li>WHERE 子句只能指定记录(行)的条件，不能用来指定组的条件(例如，“数据行数为2行”或者“平均值为500”等)。<br>因此，对集合指定条件就需要使用 HAVING 子句。</li>
<li>HAVING 子句能够使用:常数、聚合函数、聚合键。</li>
<li>有些条件既可以写在 HAVING 子句当中，又可以写在 WHERE 子句当中。这些条件就是 聚合键所对应的条件。</li>
</ul>
<a id="more"></a>
<ul>
<li><p>聚合键所对应的条件还是应该书写在 WHERE 子句中。<br>理由：</p>
<ol>
<li><p>WHERE 子句和 HAVING 子句的作用不同。<br>　　WHERE 子句 = 指定行所对应的条件<br>　　HAVING 子句 = 指定组所对应的条件</p>
</li>
<li><p>与性能即执行速度有关系<br>　　通过 WHERE 子句指定条件时，由于排序之前就对数据进行了过滤，所以能够减少排序的数据量。但 HAVING 子句是在排序之后才对数据进行分组的，因此与在 WHERE 子句中指定条件比起来，需要排序的数据量就会多得多。<br>　　WHERE 子句更具速度优势的另一个理由是，可以对 WHERE 子句指定条件所对应的列创建索引，这样也可以大幅提高处理速度。</p>
</li>
</ol>
</li>
</ul>
<h1 id="书写顺序与执行顺序"><a href="#书写顺序与执行顺序" class="headerlink" title="书写顺序与执行顺序"></a>书写顺序与执行顺序</h1><p>　　书写顺序：<br><strong>SELECT</strong> -&gt; <strong>FROM</strong> -&gt; <strong>WHERE</strong> -&gt; <strong>GROUP BY</strong> -&gt; <strong>HAVING</strong> -&gt; <strong>ORDER BY</strong><br>　　执行顺序：<br><strong>FROM</strong> -&gt; <strong>WHERE</strong> -&gt; <strong>GROUP BY</strong> -&gt; <strong>HAVING</strong> -&gt; <strong>SELECT</strong> -&gt; <strong>(DISTINCT)</strong> -&gt;<strong>ORDER BY</strong></p>
<h1 id="关于-NULL"><a href="#关于-NULL" class="headerlink" title="关于 NULL"></a>关于 NULL</h1><ol>
<li>所有包含 NULL 的计算，结果肯定是 NULL 。</li>
<li>比较运算符无法用于 NULL ，只能使用专门用来判断是否为 NULL 的运算符 <strong>IS NULL</strong></li>
<li>对 NULL 进行逻辑运算时，结果是 SQL 特有的第三种值——不确定(Unknown).所以尽量不使用 NULL ,在创建表时，要给某些列设定 NOT NULL 约束的原因就在此.</li>
</ol>
<h1 id="SQL-语句及其种类"><a href="#SQL-语句及其种类" class="headerlink" title="SQL 语句及其种类"></a>SQL 语句及其种类</h1><ol>
<li>DDL(Data Definition Language ，数据定义语言)<ul>
<li>CREATE</li>
<li>DROP</li>
<li>ALTER</li>
</ul>
</li>
<li>DML(Data Manipulation Language ，数据操作语言)<ul>
<li>SELECT</li>
<li>INSERT</li>
<li>UPDATE</li>
<li>DELETE</li>
</ul>
</li>
<li>DCL(Data Control Language ，数据控制语言)<ul>
<li>COMMIT</li>
<li>ROLLBACK</li>
<li>GRANT</li>
<li>REVOKE</li>
</ul>
</li>
</ol>
<h1 id="关于事务-Transaction"><a href="#关于事务-Transaction" class="headerlink" title="关于事务 Transaction"></a>关于事务 Transaction</h1><ol>
<li>事务处理何时开始？<br> 事务并没有标准的开始指令存在，而是根据 DBMS 的不同而不同。<br> 想 Oracle 这样不使用指令而悄悄开始事务的情况下，应该如何区分各个事务呢？<br> 通常有两种情况：<br> <strong>一、每条 SQL 语句就是一个事务(自动提交模式)。</strong><br> <strong>二、直到用户执行 COMMIT 或者 ROLLBACK 为止算作一个事务。</strong></li>
<li>自动模式情况下要特别注意 DELETE 语句，否则一旦误删回滚也无济于事。</li>
<li>ACID 特性<ul>
<li><strong>原子性(Atomicity)</strong><br>  事务结束时，其中包含的 DML 语句更新处理，要么全部执行，要么全不执行的特性。</li>
<li><strong>一致性(Consistency)</strong><br>  事务中包含的处理，要满足数据库提前设置的约束。又称为完整性。(一旦其中一句语句违反约束，就会出错无法执行，整个事务的 SQL 语句都会被取消不执行。【原子性的体现】)<br>  (例子: INSERT INTO 表 SELECT * FROM 表。执行会因为主键重复失败)</li>
<li><strong>隔离性(Isolation)</strong><br>  保证不同事务之间互不干扰的特性。该特性保证了事务之间不会互相嵌套。在某个事务中进行的更改，在该事务结束之前，对其他事务而言是不可见的。</li>
<li><strong>持久性(Durability)</strong><br>  事务(无论是提交还是回滚)一旦结束， DBMS 会保证该时点的数据状态得以保存的特性。即使由于系统故障导致数据丢失，数据库也一定能通过某些手段进行恢复。<br>  保证持久性的方法根据实现的不同而不同，最常见的是将事务的执行记录保存到硬盘等存储介质中(该执行记录称为日志)。当发生故障时，可以通过日志恢复到故障发生前的状态。</li>
</ul>
</li>
</ol>
<h1 id="关于视图"><a href="#关于视图" class="headerlink" title="关于视图"></a>关于视图</h1><ol>
<li>对多数 DBMS 来说，多重视图会降低 SQL 的性能。因此应该避免在视图的基础上创建视图。</li>
<li>视图的限制：<ul>
<li>定义视图时不能使用 ORDER BY 子句。<br>  因为视图和表一样，数据行都是没有顺序的。</li>
<li>如果定义视图的 SELECT 语句能够满足某些条件，那么这个视图就可以被更新，比较具有代表性的一些条件：<br>  <strong>一、</strong>SELECT 子句中未使用 DISTINCT<br>  <strong>二、</strong>FROM 子句中只有一张表<br>  <strong>三、</strong>未使用 GROUP BY 子句<br>  原因：视图和表需要同事进行更新，因此通过聚合得到的视图无法进行更新。<br>  <strong>四、</strong>未使用 HAVING 子句</li>
</ul>
</li>
</ol>
<h1 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h1><ol>
<li>在细分的组内进行比较时，需要使用关联子查询。</li>
<li>结合条件一定要写在子查询中。<br> 例如： <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> ‘按分类的平均单价’</div><div class="line"><span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> 商品 <span class="keyword">ID</span>, 商品名, 商品分类, 商品单价,</div><div class="line">(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(商品单价)</div><div class="line"><span class="keyword">FROM</span> 商品表 <span class="keyword">AS</span> S2</div><div class="line"><span class="keyword">WHERE</span> S1.商品分类=S2.商品分类</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 商品分类)</div><div class="line"><span class="keyword">AS</span> 商品分类_单价</div><div class="line"><span class="keyword">FROM</span> 商品表 <span class="keyword">AS</span> S1;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="EXISTS-与-IN"><a href="#EXISTS-与-IN" class="headerlink" title="EXISTS 与 IN"></a>EXISTS 与 IN</h1><p>EXISTS 的特性：<br>通常指定关联子查询作为 EXIST 的参数;<br>作为 EXISTS 参数的子查询经常会使用 SELECT *。</p>
<ol>
<li>一言以蔽之：<br> EXISTS 与 IN 的使用效率的问题，通常情况下采用 EXISTS 要比 IN 效率高，因为 IN 不走索引，但要看实际情况具体使用：<br> <strong>IN 适合于外表大而内表小的情况；</strong><br> <strong>EXISTS 适合于外表小而内表大的情况。</strong></li>
<li>IN 是把外表和内表作 hash 连接，而 EXISTS 是对外表作 loop 循环，每次 loop 循环再对内表进行查询。</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用 EXISTS ，子查询表小的用 IN ：<br> 例如：表 A(小表)，表 B(大表)</li>
<li>NOT IN 和 NOT EXISTS<br> 如果查询语句使用了 NOT IN ，那么内外表都进行全表扫描，没有用到索引；<br>而 NOT EXISTS 的子查询依然能用到表上的索引。<br>所以无论哪个表大，用 NOT EXISTS 都比 NOT IN 要快。</li>
</ol>
<p>一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> A 【小】</div><div class="line"><span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B【大】)</div><div class="line"><span class="comment">--效率低，用到了 A 表上 cc 列的索引；</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> A 【小】</div><div class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B 【大】 <span class="keyword">WHERE</span> cc=A.cc)</div><div class="line"><span class="comment">--效率高，用到了 B 表上 cc 列的索引。</span></div></pre></td></tr></table></figure>
<p>二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> B 【大】</div><div class="line"><span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> A【小】)</div><div class="line"><span class="comment">--效率高，用到了 B 表上 cc 列的索引；</span></div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> B 【大】</div><div class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> A【小】 <span class="keyword">where</span> cc=B.cc)</div><div class="line"><span class="comment">--效率低，用到了 A 表上 cc 列的索引。</span></div></pre></td></tr></table></figure>
<h1 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h1><p>应用于2张以上表的 SQL 语句</p>
<ul>
<li><p>UNION<br>  ——并集<br>注意事项：<br>作为运算对象的记录的列数必须相同；<br>作为运算对象的记录的列的数据类型必须相同；<br>可以使用任何 SELECT 语句，但 ORDER BY 语句只能在最后使用一次；<br>保留重复行使用 ALL 选项；</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line">  <span class="keyword">FROM</span> Shohin</div><div class="line"><span class="keyword">UNION</span></div><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line"> <span class="keyword">FROM</span> Shohin2</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> shohin_id;</div></pre></td></tr></table></figure>
</li>
<li><p>INTERSECT<br>  ——交集</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line">  <span class="keyword">FROM</span> Shohin</div><div class="line"><span class="keyword">INTERSECT</span></div><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line"> <span class="keyword">FROM</span> Shohin2</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> shohin_id;</div></pre></td></tr></table></figure>
</li>
<li><p>EXCEPT<br>  ——差集</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line">  <span class="keyword">FROM</span> Shohin</div><div class="line"><span class="keyword">EXCEPT</span></div><div class="line"><span class="keyword">SELECT</span> shohin_id, shohin_mei</div><div class="line">  <span class="keyword">FROM</span> Shohin2</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> shohin_id;</div><div class="line"><span class="comment">--Shohin 减去 Shohin2.</span></div></pre></td></tr></table></figure>
</li>
<li><p>JOIN<br>  ——联结<br>一、 INNER JOIN<br>内联结。<br>使用时 SELECT 子句中的列需要按照 &lt;表的别名&gt;.&lt;列名&gt; 的格式进行书写；<br>必须使用 ON 子句，书写在 FROM 和 WHERE 之间；</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TS.tenpo_id, TS.tenpo_mei,</div><div class="line">TS.shohin_id, S.shohin_mei, S.hanbai_tanka</div><div class="line"><span class="keyword">FROM</span></div><div class="line">TenpoShohin <span class="keyword">AS</span> TS</div><div class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></div><div class="line">Shohin <span class="keyword">AS</span> S</div><div class="line"><span class="keyword">ON</span> TS.shohin_id = S.shohin_id;</div></pre></td></tr></table></figure>
<p>  二、 OUTER JOIN<br>  外联结。<br>  选出单张表中全部的信息，而不像内联结只选出同时存在于两张表中的数据；<br>  通过 LEFT 和 RIGHT 指定主表;</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TS.tenpo_id, TS.tenpo_mei,</div><div class="line">S.shohin_id, S.shohin_mei, S.hanbai_tanka</div><div class="line"><span class="keyword">FROM</span></div><div class="line">Shohin <span class="keyword">AS</span> S</div><div class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></div><div class="line">TenpoShohin <span class="keyword">AS</span> TS</div><div class="line"><span class="keyword">ON</span> TS.shohin_id = S.shohin_id;</div></pre></td></tr></table></figure>
<p>  三、多张表的联结</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--三张以上表的内联结</span></div><div class="line"><span class="keyword">SELECT</span> TS.tenpo_id, TS.tenpo_mei,</div><div class="line">TS.shohin_id, S.shohin_mei,</div><div class="line">S.hanbai_tanka, ZS.zaiko_suryo</div><div class="line"><span class="keyword">FROM</span> TenpoShohin <span class="keyword">AS</span> TS</div><div class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Shohin <span class="keyword">AS</span> S</div><div class="line"><span class="keyword">ON</span> TS.shohin_id = S.shohin_id</div><div class="line">   <span class="keyword">INNER</span> <span class="keyword">JOIN</span> ZaikoShohin <span class="keyword">AS</span> ZS</div><div class="line">      <span class="keyword">ON</span> TS.shohin_id = ZS.shohin_id</div><div class="line"><span class="keyword">WHERE</span> ZS.souko_id = <span class="string">'S001'</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>四、 CROSS JOIN<br>——交叉联结。<br>表的笛卡尔集。<br>AXB={(a,b)|a 属于 A ， b 属于 B }<br>内联结可以说是交叉联结的一部分，但是外联结不能说是“交叉联结结果之外的部分”，应该说是：<br>外联结 = 主表内所有数据(包括内联结和内联结之中不存在的主表信息【空白处用 NULL 补上】)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TS.tenpo_id, TS.tenpo_mei,</div><div class="line">TS.shohin_id, S.shohin_mei</div><div class="line"><span class="keyword">FROM</span> TenpoShohin <span class="keyword">AS</span> TS</div><div class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span></div><div class="line">Shohin <span class="keyword">AS</span> S;</div></pre></td></tr></table></figure>
<h1 id="过时语法"><a href="#过时语法" class="headerlink" title="过时语法"></a>过时语法</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TS.tenpo_id, TS.tenpo_mei,</div><div class="line">TS.shohin_id, S.shohin_mei, S.hanbai_tanka</div><div class="line">  <span class="keyword">FROM</span> TenpoShohin TS, Shohin S</div><div class="line"> <span class="keyword">WHERE</span> TS.shohin_id = S.shohin_id</div><div class="line">   <span class="keyword">AND</span> TS.tenpo_id = <span class="string">'000A'</span>;</div></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>无法马上判断出到底是内联结还是外联结又或者是其他类型的联结</li>
<li>由于联结条件都写在 WHERE 子句中，无法在短时间内分辨出哪部分是联结条件，哪部分是用来选取记录的限制条件</li>
<li>我们不知道这样的语法到底还能使用多久</li>
</ul>
<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><ol>
<li>COALESCE 函数<br> 将 NULL 值变为其他值</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">COALESCE</span>(<span class="keyword">name</span>, <span class="string">'unknown'</span>) <span class="keyword">AS</span> <span class="keyword">name</span></div><div class="line"><span class="comment">--于是 name 中的 NULL 值就变成 unknown 了</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[递归的四条基本法则]]></title>
      <url>http://codingme.xyz/2015/12/06/recursion/</url>
      <content type="html"><![CDATA[<h1 id="基准情形"><a href="#基准情形" class="headerlink" title="基准情形"></a>基准情形</h1><p>必须总要有某些基准情形，它无须递归就能解出。</p>
<h1 id="不断推进"><a href="#不断推进" class="headerlink" title="不断推进"></a>不断推进</h1><p>对于那些需要递归求解的情形，每一次递归调用都必须要使状况朝向一种基准情形推进。</p>
<h1 id="设计法则。"><a href="#设计法则。" class="headerlink" title="设计法则。"></a>设计法则。</h1><p>假设所有的递归调用都能运行。</p>
<h1 id="合成效益法则。"><a href="#合成效益法则。" class="headerlink" title="合成效益法则。"></a>合成效益法则。</h1><p>在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。</p>
]]></content>
    </entry>
    
  
  
</search>
